<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HELLO</title>
  
  <subtitle>It is never too late to learn</subtitle>
  <link href="https://zhouhang-hello.gitee.io/hexo_blog/atom.xml" rel="self"/>
  
  <link href="https://zhouhang-hello.gitee.io/hexo_blog/"/>
  <updated>2021-10-05T11:22:27.648Z</updated>
  <id>https://zhouhang-hello.gitee.io/hexo_blog/</id>
  
  <author>
    <name>hello</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中key的作用</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/05/vue%E7%9A%84key/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/05/vue%E7%9A%84key/</id>
    <published>2021-10-05T08:26:35.682Z</published>
    <updated>2021-10-05T11:22:27.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue中key的作用"><a href="#vue中key的作用" class="headerlink" title="vue中key的作用"></a>vue中key的作用</h1><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>###总结</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue中key的作用&quot;&gt;&lt;a href=&quot;#vue中key的作用&quot; class=&quot;headerlink&quot; title=&quot;vue中key的作用&quot;&gt;&lt;/a&gt;vue中key的作用&lt;/h1&gt;&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>替换空格 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/03/%E5%89%91%E6%8C%87offer-2/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/03/%E5%89%91%E6%8C%87offer-2/</id>
    <published>2021-10-03T11:09:23.710Z</published>
    <updated>2021-10-03T14:55:31.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目：-2-替换空格"><a href="#题目：-2-替换空格" class="headerlink" title="题目：(2)替换空格"></a>题目：(2)替换空格</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察先知道空格的位置。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路：-1"><a href="#▉-算法思路：-1" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤：-1"><a href="#▉-步骤：-1" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现：-1"><a href="#▉-代码实现：-1" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减-1"><a href="#▉-代码缩减-1" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。-1"><a href="#▉-总结：需要注意几点。-1" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展：-1"><a href="#▉-扩展：-1" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;题目：-2-替换空格&quot;&gt;&lt;a href=&quot;#题目：-2-替换空格&quot; class=&quot;headerlink&quot; title=&quot;题目：(2)替换空格&quot;&gt;&lt;/a&gt;题目：(2)替换空格&lt;/h4&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排</summary>
      
    
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/03/%E5%89%91%E6%8C%87offer-1/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/03/%E5%89%91%E6%8C%87offer-1/</id>
    <published>2021-10-03T11:05:47.492Z</published>
    <updated>2021-10-03T11:10:42.768Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目：-1-二维数组的查找"><a href="#题目：-1-二维数组的查找" class="headerlink" title="题目：(1)二维数组的查找"></a>题目：(1)二维数组的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;题目：-1-二维数组的查找&quot;&gt;&lt;a href=&quot;#题目：-1-二维数组的查找&quot; class=&quot;headerlink&quot; title=&quot;题目：(1)二维数组的查找&quot;&gt;&lt;/a&gt;题目：(1)二维数组的查找&lt;/h4&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都</summary>
      
    
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>算法 - 双指针</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-10-02T02:17:04.625Z</published>
    <updated>2021-10-02T07:12:40.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针相关算法"><a href="#双指针相关算法" class="headerlink" title="双指针相关算法"></a>双指针相关算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    妙用双指针，会在许多的数组相关解法中有意想不到的收获，无论是算法复杂度和解题思路，都有很大的提升</p><p><img src="C:/Users/l%27x/Pictures/%E4%B8%8B%E8%BD%BD.jpeg"></p><h5 id="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分"><a href="#输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分" class="headerlink" title="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分"></a>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</h5><p>思路：</p><blockquote><p>设定两个指针</p><p>第一个指针start从数组第一个元素出发，向尾部前进</p><p>第二个指针end从数组的最后一个元素出发，向头部前进</p><p>start遍历到偶数，end遍历到奇数时，交换两个数的位置</p><p>当start&gt;end时，完成交换</p></blockquote><p>代码：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> reOrderArray(<span class="hljs-keyword">array</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">Array</span>.isArray(<span class="hljs-keyword">array</span>)) &#123;      let start = <span class="hljs-number">0</span>;      let end = <span class="hljs-keyword">array</span>.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>] % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;          <span class="hljs-keyword">start</span>++;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span>        &#125;        // 判断是否交换位置        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;          [<span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>], <span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>]] = [<span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>], <span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>]]        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;  &#125;</code></pre></div><h5 id="输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。"><a href="#输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。" class="headerlink" title="输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。"></a>输入一个递增排序的数组和一个数字<code>S</code>，在数组中查找两个数，使得他们的和正好是<code>S</code>，如果有多对数字的和等于<code>S</code>，输出两个数的乘积最小的。</h5><p>思路；</p><blockquote><p>数组中可能有多对符合条件的结果，而且要求输出乘积最小的，说明要分布在两侧 比如 <code>3,8</code> <code>5,7</code> 要取<code>3,8</code>。</p></blockquote><p>看了题目了，很像<code>leetcode</code>的第一题【两数之和】，但是题目中有一个明显不同的条件就是数组是有序的，可以使用使用大小指针求解，不断逼近结果，最后取得最终值。</p><ul><li>设定一个小索引<code>left</code>，从<code>0</code>开始</li><li>设定一个大索引<code>right</code>，从<code>array.length</code>开始</li><li>判断<code>array[left] + array[right]</code>的值<code>s</code>是否符合条件</li><li>符合条件 - 返回</li><li>大于<code>sum</code>，<code>right</code>向左移动</li><li>小于<code>sum</code>，<code>left</code>向右移动</li><li>若<code>left=right</code>，没有符合条件的结果</li></ul><blockquote><p>类似【两数之和】的解法来求解，使用<code>map</code>存储另已经遍历过的<code>key</code>，这种解法在有多个结果的情况下是有问题的，因为这样优先取得的结果是乘积较大的。例如 <code>3,8</code> <code>5,7</code> ，会优先取到<code>5,7</code>。</p></blockquote><p>代码：</p><div class="hljs code-wrapper"><pre><code class="hljs vbscript"><span class="hljs-keyword">function</span> FindNumbersWithSum(<span class="hljs-built_in">array</span>, sum) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span> &amp;&amp; <span class="hljs-built_in">array</span>.length &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">let</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;      <span class="hljs-keyword">let</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">array</span>.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">array</span>[<span class="hljs-built_in">left</span>] + <span class="hljs-built_in">array</span>[<span class="hljs-built_in">right</span>];        <span class="hljs-keyword">if</span> (s &gt; sum) &#123;          <span class="hljs-built_in">right</span>--;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; sum) &#123;          <span class="hljs-built_in">left</span>++;        &#125; <span class="hljs-keyword">else</span> &#123;          return [<span class="hljs-built_in">array</span>[<span class="hljs-built_in">left</span>], <span class="hljs-built_in">array</span>[<span class="hljs-built_in">right</span>]]        &#125;      &#125;    &#125;    return [];  &#125;</code></pre></div><h5 id="输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1-2-3-4-5-4-5-6-7-8-15-所以打印出3个连续序列1-5，5-6和7-8。"><a href="#输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1-2-3-4-5-4-5-6-7-8-15-所以打印出3个连续序列1-5，5-6和7-8。" class="headerlink" title="输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1+2+3+4+5 = 4+5+6 = 7+8 = 15 所以打印出3个连续序列1-5，5-6和7-8。"></a>输入一个正数<code>S</code>，打印出所有和为S的连续正数序列。例如：输入<code>15</code>，有序<code>1+2+3+4+5</code> = <code>4+5+6</code> = <code>7+8</code> = <code>15</code> 所以打印出3个连续序列<code>1-5</code>，<code>5-6</code>和<code>7-8</code>。</h5><p>思路：</p><blockquote><p>创建一个容器child，用于表示当前的子序列，初始元素为1,2</p><p>记录子序列的开头元素small和末尾元素big</p><p>big向右移动子序列末尾增加一个数 small向右移动子序列开头减少一个数</p><p>当子序列的和大于目标值，small向右移动，子序列的和小于目标值，big向右移动</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs maxima">function FindContinuousSequence(<span class="hljs-built_in">sum</span>) &#123;     const result = [];     const child = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];     <span class="hljs-built_in">let</span> big = <span class="hljs-number">2</span>;     <span class="hljs-built_in">let</span> small = <span class="hljs-number">1</span>;     <span class="hljs-built_in">let</span> currentSum = <span class="hljs-number">3</span>;     // 较大的数不能超过所求的数     <span class="hljs-keyword">while</span> (big &lt; <span class="hljs-built_in">sum</span>) &#123;     // 整体和小于所求的数，则忘容器李加数据       <span class="hljs-keyword">while</span> (currentSum &lt; <span class="hljs-built_in">sum</span> &amp;&amp; big &lt; <span class="hljs-built_in">sum</span>) &#123;         child.<span class="hljs-built_in">push</span>(++big);         currentSum += big;       &#125;       // 如果加了数之后发现总数大了，就移除容器前面的数       <span class="hljs-keyword">while</span> (currentSum &gt; <span class="hljs-built_in">sum</span> &amp;&amp; small &lt; big) &#123;         child.shift();         currentSum -= small++;       &#125;       // 如果总数等于所求的数，则将这种可能加入返回的数组中       <span class="hljs-keyword">if</span> (currentSum === <span class="hljs-built_in">sum</span> &amp;&amp; child.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">1</span>) &#123;         result.<span class="hljs-built_in">push</span>(child.slice());         child.<span class="hljs-built_in">push</span>(++big);         currentSum += big;       &#125;     &#125;     <span class="hljs-built_in">return</span> result;   &#125;</code></pre></div><p>总结</p><blockquote><p>双指针可以使用在数组链表等这样的数据结构中，在遍历过程中我们可以使用多个标记点来遍历数组等，或是一个在头一个在尾，获取都在一方，一个快一个慢。这样就能更灵活的操作数据</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双指针相关算法&quot;&gt;&lt;a href=&quot;#双指针相关算法&quot; class=&quot;headerlink&quot; title=&quot;双指针相关算法&quot;&gt;&lt;/a&gt;双指针相关算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/Untitled/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/Untitled/</id>
    <published>2021-10-02T02:16:48.500Z</published>
    <updated>2021-10-02T02:16:48.500Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/30/%E5%9B%BD%E5%BA%86%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/30/%E5%9B%BD%E5%BA%86%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-09-30T06:28:09.412Z</published>
    <updated>2021-10-07T07:27:35.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="国庆学习计划"><a href="#国庆学习计划" class="headerlink" title="国庆学习计划"></a>国庆学习计划</h1><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><a href="https://www.processon.com/mindmap/612703780791292dcf5eef69">https://www.processon.com/mindmap/612703780791292dcf5eef69</a></p><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210930173457183.png" alt="image-20210930173457183"></p><h3 id="作息计划"><a href="#作息计划" class="headerlink" title="作息计划"></a>作息计划</h3><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th><th align="center">🦁</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="时间计划"><a href="#时间计划" class="headerlink" title="时间计划"></a>时间计划</h3><h5 id="10-2"><a href="#10-2" class="headerlink" title="10-2"></a>10-2</h5><p>算法</p><p>详细计划</p><p>(上午)</p><p>剑指offer/leetcode常见数组内题型–刷图/写博客总结思路及一般思路</p><p>(下午)</p><p>剑指offer/leetcode常见链表内题型–刷图/写博客总结思路及一般思路</p><p>(下午)</p><p>剑指offer/leetcode常见字符串内题型–刷图/写博客总结思路及一般思路</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-3"><a href="#10-3" class="headerlink" title="10-3"></a>10-3</h5><p>算法</p><p>目标：能完成常见算法，熟悉思路</p><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>刷剑指offer/leetcode高频题(回顾)</p><p>(下午)</p><p>剑指offer/leetcode常见二叉树内题型–刷图/写博客总结思路及一般思路</p><p>(下午)</p><p>常见手写算法实现</p><p>手写jsonp</p><p>防抖节流</p><p>instanceof</p><p>call/aplay/bind</p><p>快排及性能</p><p>promise</p><p>对象扁平化/函数柯里化</p><p>数组去重</p><p>reduce</p><p>es5数组常见方法</p><p><a href="https://codetop.cc/home">https://codetop.cc/home</a> 刷高频题-写题解</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-4"><a href="#10-4" class="headerlink" title="10-4"></a>10-4</h5><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>浏览器渲染原理整理</p><p>(下午)</p><p>网络相关知识点</p><ul><li>请介绍一下HTTP和HTTPS的区别？</li><li>HTTP2与HTTP1.x相比的新特性有哪些？</li><li>请介绍一下TCP与UDP的区别，TCP的可靠性如何保证？</li><li>为什么TCP连接需要三次握手？为什么要四次挥手？画出TCP三次握手和四次挥手的全过程（并且标注ack确认号 和 seq序列号的值）</li><li>HTTP中，POST与GET的区别</li><li>HTTP的长连接和短连接分别是什么？你知道keep-alive是干什么的吗？</li><li>HTTP Request Header和Response Header里面分别都有哪些比较重要的字段？</li><li>说说你所知道的web安全及防护措施？</li><li>从输入URL到页面加载发生了什么</li><li>HTTP响应状态码</li><li>什么是浏览器缓存？</li><li>什么是CDN</li><li>websocket是否了解</li><li>jsonp的原理</li><li>跨域请求资源有哪几种方式？他们的优缺点是什么</li></ul><p>(晚上)</p><p>网络知识点/操作系统考点</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-5"><a href="#10-5" class="headerlink" title="10-5"></a>10-5</h5><p>基础知识</p><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>html及css常见面试题</p><p>(下午)</p><p>js知识巩固</p><ul><li>基本内型及转换</li><li>常用函数</li><li>闭包及原理，产生原因运用场景</li><li>原型及原型链</li><li>继承及不同方式</li><li>this指向</li><li>内存机制</li><li>执行期上下文</li><li>变量提升/模块化</li><li>setTimeout、Promise、Async / Await 的区别</li><li>垃圾回收机制</li><li>对象创建方式</li><li>深/浅拷贝</li><li>常见数组方法<ul><li><code>map</code>: 遍历数组，返回回调返回值组成的新数组</li><li><code>forEach</code>: 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</li><li><code>filter</code>: 过滤</li><li><code>some</code>: 有一项返回<code>true</code>，则整体为<code>true</code></li><li><code>every</code>: 有一项返回<code>false</code>，则整体为<code>false</code></li><li><code>join</code>: 通过指定连接符生成字符串</li><li><code>push / pop</code>: 末尾推入和弹出，改变原数组， 返回推入/弹出项</li><li><code>unshift / shift</code>: 头部推入和弹出，改变原数组，返回操作项</li><li><code>sort(fn) / reverse</code>: 排序与反转，改变原数组</li><li><code>concat</code>: 连接数组，不影响原数组， 浅拷贝</li><li><code>slice(start, end)</code>: 返回截断后的新数组，不改变原数组</li><li><code>splice(start, number, value...)</code>: 返回删除元素组成的数组，<code>value</code>为插入项，改变原数组</li><li><code>indexOf / lastIndexOf(value, fromIndex)</code>: 查找数组项，返回对应的下标</li><li><code>reduce / reduceRight(fn(prev, cur)</code>， <code>defaultPrev)</code>: 两两执行，<code>prev</code> 为上次化简函数的<code>return</code>值，<code>cur</code>为当前值(从第二项开始)</li></ul></li><li>循环方式–对象/数组 (for in/for of —)</li><li>requestAnimationFrame</li><li>。。。</li></ul><p>(晚上)</p><p>es6/node</p><ul><li><p>Promise是什么，有什么作用？</p></li><li><p>Iterator是什么，有什么作用？</p></li><li><p>Generator函数是什么，有什么作用？</p></li><li><p>8 async函数</p></li><li><p> Class、extends</p></li><li><p>module、export、import是什么，有什么作用？</p></li><li><p>日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</p></li><li><p>箭头函数的特点</p></li></ul><hr><ul><li><p>npm 模块安装机制</p></li><li><p>Node 的 Event Loop: 6个阶段</p></li><li><p>Express、koa实现原理以及对比</p></li><li><p>require 的模块加载机制</p></li><li><p>Node 的异步 I/O</p></li><li><p> <strong>V8 的垃圾回收机制</strong></p></li><li><p>webSocket</p></li><li><p>https</p></li><li><p>进程通信</p></li></ul><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-6"><a href="#10-6" class="headerlink" title="10-6"></a>10-6</h5><p>vue</p><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>flex布局</p><ul><li>常见布局</li><li>常用属性</li><li>特殊情况</li></ul><p>项目优化</p><ul><li>DNS 预解析</li><li> 缓存</li><li>使用 HTTP / 2.0</li><li>预加载</li><li>预渲染</li><li> 文件优化</li><li>。。。。</li></ul><p>(下午)</p><p>vue相关</p><ul><li>vue生命周期</li><li>Vue2.x 响应式原理</li><li>Vue是如何实现双向绑定的?</li><li>Vue组件间的参数传递</li><li>路由实现</li><li>vue路由的钩子函数</li><li>vuex是什么？怎么使用？哪种功能场景使用它？</li><li><keep-alive></keep-alive>的作用是什么?</li><li>vue-cli 工程技术集合介绍</li><li> <strong>NextTick</strong></li><li>实现 Vue SSR</li><li>Vue computed 实现</li><li>Vue complier 实现</li><li>Proxy 相比于 defineProperty 的优势</li><li>ue-router 有哪几种导航守卫?</li><li>scoped样式穿透</li><li> vue项目中的性能优化，Vue的SPA 如何优化加载速度</li><li>Proxy与Object.defineProperty的优劣对比?</li><li>Vue中的key到底有什么用？</li><li>Vue模版编译原理</li><li>Vue2.x和Vue3.x渲染器的diff算法分别说一下</li><li>vue如何兼容ie</li><li> Vue3.0 是如何变得更快的</li><li>。。。</li></ul><p>(晚上)</p><p>看一下双向绑定源码</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-7"><a href="#10-7" class="headerlink" title="10-7"></a>10-7</h5><p>算法</p><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>(下午)</p><p>(下午)</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-8"><a href="#10-8" class="headerlink" title="10-8"></a>10-8</h5><p>算法</p><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>(下午)</p><p>(下午)</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><h5 id="10-9"><a href="#10-9" class="headerlink" title="10-9"></a>10-9</h5><p>算法</p><p>详细计划</p><p>(上午)</p><p>回顾前一天学习</p><p>(下午)</p><p>(下午)</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th><th align="center">执行程度</th></tr></thead><tbody><tr><td align="center">7:00 - 8:00</td><td align="center">起床/洗漱/早餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 11:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">11:30-12:30</td><td align="center">午餐时间</td><td align="center"></td></tr><tr><td align="center">12:30 - 1:30</td><td align="center">午休</td><td align="center"></td></tr><tr><td align="center">2:00 - 5:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">5:00 - 6:30</td><td align="center">写博客</td><td align="center"></td></tr><tr><td align="center">6:30 - 8:00</td><td align="center">晚餐</td><td align="center"></td></tr><tr><td align="center">8:00 - 10:00</td><td align="center">学习</td><td align="center"></td></tr><tr><td align="center">10:00 - 10:30</td><td align="center">每日总结/回顾</td><td align="center"></td></tr><tr><td align="center">11:30</td><td align="center">睡觉</td><td align="center"></td></tr></tbody></table><p>## HTML篇<br>\1. 行内元素、块级元素<br>\2. HTML5新特性<br>\3. sessionStage和localStage</p><p>## CSS<br>\1. 盒子模型<br>\2. BFC<br>\3. 居中对齐的方式<br>\4. css选择器和优先级<br>\5. display：flex<br>\6. position<br>\7. 元素的隐藏和显示<br>\8. 伪类和伪元素的区别（不是很重点）<br>\9. CSS3新特性（重点：动画、过渡、translate）<br>\10. 如何画三角形</p><p>## JavaScript<br>\1. 闭包（必考）<br>\2. 作用域<br>\3. 原型<br>\4. 继承<br>\5. 模块化<br>\6. 异步编程<br>\7. es6新特性<br>\8. 事件循环</p><p>## vue<br>\1. 生命周期<br>\2. 组件通信<br>\3. 数据双向绑定<br>\4. nextTick<br>\5. diff算法（这里会了解到vnode、key相关的东西）<br>\6. watch和computed</p><p>## vue router<br>就原理</p><p>## vuex<br>怎么用</p><p>## webpack<br>常见的loader、plugins，会一些配置就说，不会的话就跳过</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;国庆学习计划&quot;&gt;&lt;a href=&quot;#国庆学习计划&quot; class=&quot;headerlink&quot; title=&quot;国庆学习计划&quot;&gt;&lt;/a&gt;国庆学习计划&lt;/h1&gt;&lt;h3 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络知识点总结</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/25/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/25/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-09-25T00:08:08.868Z</published>
    <updated>2021-10-07T07:27:52.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络知识点总结"><a href="#网络知识点总结" class="headerlink" title="网络知识点总结"></a>网络知识点总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理一下常见的网络面试题</p><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><blockquote><p>HTTP：超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息</p><p>–  HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息</p><p>HTTPS：超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>– 它的工作流程一般如以下方式：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS 数据传输过程是加密的，安全性较好。<br>使用 HTTPS 协议需要到申请证书，一般需要一定费用。<br>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p></blockquote><h3 id="从输入URL到页面加载发生了什么总体来说分为以下几个过程"><a href="#从输入URL到页面加载发生了什么总体来说分为以下几个过程" class="headerlink" title="从输入URL到页面加载发生了什么总体来说分为以下几个过程:"></a>从输入URL到页面加载发生了什么总体来说分为以下几个过程:</h3><blockquote><ol><li>DNS解析</li></ol><p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。 先进行DNS域名解析，先查看本地hosts文件，查看有没有当前域名对应的ip地址，若有直接发起请求，没有的话会在本地域名服务器去查找，该查找属于递归查找，如果本地域名服务器没查找到，会从根域名服务器查找，该过程属于迭代查找，根域名会告诉你从哪个与服务器查找，最后查找到对应的ip地址后把对应规则保存到本地的hosts文件中。<br>这里顺便提一下DNS优化方案：<br>（1）DNS缓存（DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。）<br>（2）DNS负载均衡（DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。）</p><ol start="2"><li><p>TCP连接<br>进行http请求，三次握手四次挥手建立断开连接。<br>这里要提醒一点，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。</p></li><li><p>发送HTTP请求<br>TCP连接建立完毕后，浏览器可以和服务器开始通信，发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。<br>HTTP请求报文是由三部分组成:<br>请求行：</p></li></ol><p>// 请求方法是GET，路径为根路径，HTTP协议版本为1.1<br>GET / HTTP/1.1</p><p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。<br>请求头：请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>请求报头中常见的字段：</p><p>Accept用于指定客户端用于接受哪些类型的信息<br>Accept-Encoding与Accept类似，它用于指定接受的编码方式。<br>Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。<br>请求体： 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求头中有一些与请求正文相关的信息<br>4. 服务器处理请求并返回HTTP报文<br>HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。<br>HTTP响应报文也是由三部分组成:<br>状态码（下文有详细介绍）<br>响应头<br>响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。<br>常见的响应报头字段有: Server, Connection…。<br>响应体<br>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。<br>5. 浏览器解析渲染页面<br>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;<strong>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</strong>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br>6. 连接结束</p></blockquote><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><blockquote><div class="hljs code-wrapper"><pre><code>信息响应(100–199)——表示请求已被接受，但需要后续处理。例如：</code></pre></div><p>100（Continue）客户端应继续发送请求。<br>101（Switching Protocols）需要切换协议，服务器通过的Upgrade响应头字段通知客户端。<br>成功响应(200–299)——表示请求已成功被服务器接收、理解、并接受。</p><p>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>201（Created）请求已经被实现，而且有一个新的资源已经依据请求的需要而创建。在RESTFul风格的URL设计中，通常用来响应POST请求。<br><strong>202（Accepted）服务器已接受请求，但尚未处理。</strong>比如POST一个资源应当返回201，但由于性能原因未能立即创建，可以返回202。<br>204（No Content）服务器成功处理了请求，但不需要返回任何实体内容，204响应禁止包含任何消息体。浏览器收到该响应后不应产生文档视图的变化。<br>205（Reset Content）服务器成功处理了请求，但不需要返回任何实体内容，205响应禁止包含任何消息体。 与204不同的是，返回此状态码的响应要求请求者重置文档视图。比如用户刚刚提交一个表单，返回205后页面重置，用户可以立即填写下一个表单。<br>206（Partial Content）HTTP协议允许分片传输。请求头中包含Range字段时，响应需要只返回Range指定的那一段。响应中应包含Content-Range来指示返回内容的范围。<br>重定向(300–399)——这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，重定向目标在本次响应的Location头字段中指明。</p><p>301（Moved Permanently）被请求的资源已永久移动到新位置，也就是永久重定向。<br>应用场景：域名更改，访问原始域名重定向到新的域名<br>302（Found）请求的资源现在临时从不同的URI响应请求。也就是临时重定向，<br>303（See Other）对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 303响应禁止被缓存。<br>303会使得浏览器直接GET那个资源，不需用户同意。这是Web应用中最常见的重定向方式。<br>304（Not Modified）表示可以在缓存中取数据（协商缓存）<br>304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存，因此在Web开发中你可以看到大量的304响应。 服务器给出的相应中通常会包含Etag来标识资源ID<br>客户端错误(400–499)——这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体。</p><p>400（Bad Request）<br>由于包含语法错误，当前请求无法被服务器理解。400通常在服务器端表单验证失败时返回。<br>401（Unauthorized）无权访问<br>当前请求需要用户验证，响应中会包含一个WWW-Authenticate字段来询问用户的授权信息,输入验证信息并点击确定，浏览器会根据你的输入填写Authorization头并重新发送请求。<br>403（Forbidden）<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。403和401一样，需要在相应消息体中需要给出原因。除非是一个HEAD请求。<br>404（Not Found）找不到资源<br>这太常见了。就是请求所希望得到的资源未被在服务器上发现。当通常用于当服务器不想揭示到底为何请求被拒绝时，比如应当返回500时服务器不愿透露自己的错误。<br>405（Method Not Allowed）请求行中指定的请求方法不能被用于请求相应的资源。在Web开发中通常是因为客户端和服务器的方法不一致，比如客户端通过PUT来修改一个资源，而服务器把它实现为POST方法。 开发中统一规范就好了。<br>413（Request Entity Too Large）上传的资源大小超过服务器限制的大小<br>一般的服务器都会设置HTTP请求消息体的最大长度，当然这是一种阻挡攻击的手段。 例如你在使用HTTP方式来访问Git仓库，如果你在仓库中加入了大的二进制文件（通常为目标文件或多媒体文件）， 在Push时服务器很可能会返回413错误。如果切换为ssh协议就不会有这样的问题了，服务器只能限制整个仓库的大小。<br>414（Request-URI Too Large）<br>当URI太长时，服务器可以返回414. 当HTTP协议并未规定URI应当有多长。这取决于浏览器和服务器的设置， 在服务器中当然你想设置多长都可以，但是浏览器是你决定不了的，而且不同的厂商在采用不同的长度限制，可以认为最短的是2K：<br>服务器错误 (500–599)<br>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 并且响应消息体中应当给出理由，除非是HEAD请求。</p><p>500（Internal Server Error）服务器错误<br>通常是代码出错，后台Bug。一般的Web服务器通常会给出抛出异常的调用堆栈。 然而多数服务器即使在生产环境也会打出调用堆栈，这显然是不安全的。<br>502（Bad Gateway）<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>如果你在用HTTP代理来翻墙，或者你配置了nginx来反向代理你的应用，你可能会常常看到它。<br>503 服务器超负荷<br>504（Gateway Time-out）<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。<br>注意与502的区别：502是接收到了无效响应比如Connection Refused； 504是响应超时，通常是被墙了。</p></blockquote><h3 id="三次握手过程理解"><a href="#三次握手过程理解" class="headerlink" title="三次握手过程理解"></a>三次握手过程理解</h3><blockquote><p>​    </p></blockquote><h3 id="四次挥手过程理解"><a href="#四次挥手过程理解" class="headerlink" title="四次挥手过程理解"></a>四次挥手过程理解</h3><blockquote></blockquote><h3 id="tcp-和udp有什么区别"><a href="#tcp-和udp有什么区别" class="headerlink" title="tcp 和udp有什么区别"></a>tcp 和udp有什么区别</h3><blockquote><p>1.连接方面</p><p>tcp面向连接，udp不需要连接<br>tcp需要三次握手四次挥手请求连接<br>2.可靠性</p><p>tcp是可靠传输；一旦传输过程中丢包的话会进行重传<br>udp是不可靠传输，但会最大努力交付<br>3.工作效率</p><p>UDP实时性高，比TCP工作效率高<br>因为不需要建立连接，更不需要复杂的握手挥手以及复杂的算法，也没有重传机制<br>4.是否支持多对多</p><p>TCP是点对点的<br>UDP支持一对一，一对多，多对多<br>5.首部大小</p><p>tcp首部占20字节<br>udp首部占8字节</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络知识点总结&quot;&gt;&lt;a href=&quot;#网络知识点总结&quot; class=&quot;headerlink&quot; title=&quot;网络知识点总结&quot;&gt;&lt;/a&gt;网络知识点总结&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vuex使用</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/23/vuex%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/23/vuex%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-23T03:02:25.530Z</published>
    <updated>2021-09-23T06:49:25.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MOGu面经</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/20/position%E5%8F%96%E5%80%BC/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/20/position%E5%8F%96%E5%80%BC/</id>
    <published>2021-09-20T00:08:08.868Z</published>
    <updated>2021-09-26T14:01:15.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="position取值"><a href="#position取值" class="headerlink" title="position取值"></a>position取值</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;position取值&quot;&gt;&lt;a href=&quot;#position取值&quot; class=&quot;headerlink&quot; title=&quot;position取值&quot;&gt;&lt;/a&gt;position取值&lt;/h1&gt;</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/17/axios%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/17/axios%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-09-17T01:39:56.538Z</published>
    <updated>2021-09-24T07:57:25.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios拦截器接口配置与使用"><a href="#axios拦截器接口配置与使用" class="headerlink" title="axios拦截器接口配置与使用"></a>axios拦截器接口配置与使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习期间遇到了一个axios拦截器接口配置的问题，这里总结一下相关使用</p><p>附上官方文档(<a href="http://axios-js.com/zh-cn/docs/index.html">http://axios-js.com/zh-cn/docs/index.html</a>)</p><p> ▉ 什么是axios拦截器、为什么要使用axios拦截器？</p><blockquote><ul><li><p> Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p></li><li><p>页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；如果请求数非常多，单独对每一个请求进行处理会变得非常麻烦，程序的优雅性也会大打折扣。好在强大的axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</p></li><li><p>它有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等</p></li></ul></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210917154842286.png" alt="image-20210917154842286" style="zoom:50%;" /><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//   在http.js中引入axios</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>   <span class="hljs-comment">//引入 axios</span><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>; <span class="hljs-comment">// 引入qs模块，用来序列化post类型的数据，某些请求会用得到</span><span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>    <span class="hljs-comment">//引入 element-ui 的 Message 模块，用于信息提示</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span>     <span class="hljs-comment">//引入 vuex 中的数据</span><span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span>   <span class="hljs-comment">//引入拿到的权限tocken</span><span class="hljs-comment">// create an axios instance   创建axios实例</span><span class="hljs-keyword">const</span> service = axios.create(&#123;配置信息...&#125;)</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs awk">`配置引入`import Qs from <span class="hljs-string">&#x27;qs&#x27;</span>;export default&#123;  <span class="hljs-regexp">//</span> 请求的接口，在请求的时候，如axios.get(url,config);这里的url会覆盖掉config中的url  url: <span class="hljs-string">&#x27;&#x27;</span>,  <span class="hljs-regexp">//</span> 请求的接口  baseURL:   <span class="hljs-regexp">//</span> 默认请求方法  title: <span class="hljs-string">&#x27;&#x27;</span>,  method: <span class="hljs-string">&#x27;post&#x27;</span>,  <span class="hljs-regexp">//</span> 在发送请求之前对请求数据做处理  transformRequest: [    <span class="hljs-keyword">function</span>(data) &#123;      <span class="hljs-regexp">//</span> 为了避免qs格式化时对内层对象的格式化先把内层的对象转为      <span class="hljs-regexp">//</span> data.strSQL = base64encode(data.strSQL)      <span class="hljs-regexp">//</span> 由于使用的form-data传数据所以要格式化      data = Qs.stringify(data);      return data;    &#125;,  ],  <span class="hljs-regexp">//</span> 提前处理返回的数据=  transformResponse: [    <span class="hljs-keyword">function</span>(data) &#123;      return data;    &#125;,  ],  <span class="hljs-regexp">//</span> 请求头信息  headers: &#123;      &#125;,  <span class="hljs-regexp">//</span> 默认parameter参数  params: &#123;  &#125;,  <span class="hljs-regexp">//</span> 序列化param  paramsSerializer: <span class="hljs-keyword">function</span>(params) &#123;    return Qs.stringify(params);  &#125;,  <span class="hljs-regexp">//</span> 默认post参数，使用axios.post(url,&#123;&#125;,config);如果没有额外的也必须要用一个空对象，否则会报错  data: &#123;  &#125;,  <span class="hljs-regexp">//</span> 设置超时时间  timeout: <span class="hljs-number">500000000</span>,  <span class="hljs-regexp">//</span> 是否跨站点访问控制请求  <span class="hljs-regexp">//</span> withCredentials: false, <span class="hljs-regexp">//</span> default  withCredentials: true, <span class="hljs-regexp">//</span> 自动携带cookie  <span class="hljs-regexp">//</span> 返回数据类型  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-regexp">//</span> default  <span class="hljs-regexp">//</span> 将upload事件注释掉，防止跨域状态下发起option请求  <span class="hljs-regexp">//</span> onUploadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event  <span class="hljs-regexp">//</span> &#125;,  <span class="hljs-regexp">//</span> onDownloadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event  <span class="hljs-regexp">//</span> &#125;,  maxContentLength: <span class="hljs-number">2000</span>,  validateStatus: <span class="hljs-keyword">function</span>(status) &#123;    return status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-regexp">//</span> default  &#125;,  <span class="hljs-regexp">//</span> `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  <span class="hljs-regexp">//</span> 如果设置为<span class="hljs-number">0</span>，将不会 follow 任何重定向  maxRedirects: <span class="hljs-number">5</span>,&#125;;</code></pre></div><p> ▉ 请求拦截器</p><blockquote><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.request.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(config) &#123;    // 在发起请求请做一些业务处理    <span class="hljs-keyword">return</span> <span class="hljs-type">config</span>;  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;    // 对请求失败做处理    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;  &#125;);</code></pre></div></blockquote><p> ▉ 响应拦截器</p><blockquote><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.response.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(response) &#123;    // 对响应数据做处理    <span class="hljs-keyword">return</span> <span class="hljs-type">response</span>;  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;    // 对响应错误做处理    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;  &#125;);</code></pre></div></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios拦截器接口配置与使用&quot;&gt;&lt;a href=&quot;#axios拦截器接口配置与使用&quot; class=&quot;headerlink&quot; title=&quot;axios拦截器接口配置与使用&quot;&gt;&lt;/a&gt;axios拦截器接口配置与使用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>H5新特性</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/15/H5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/15/H5%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-09-15T00:08:08.868Z</published>
    <updated>2021-10-07T07:28:41.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H5新特性"><a href="#H5新特性" class="headerlink" title="H5新特性"></a>H5新特性</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;H5新特性&quot;&gt;&lt;a href=&quot;#H5新特性&quot; class=&quot;headerlink&quot; title=&quot;H5新特性&quot;&gt;&lt;/a&gt;H5新特性&lt;/h1&gt;</summary>
      
    
    
    
    <category term="html" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/html/"/>
    
    
    <category term="html" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-09-15T00:08:08.868Z</published>
    <updated>2021-10-04T12:29:56.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是用来模拟具有树状结构性质的数据集合,顾名思义，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”</p><h3 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h3><blockquote><p>1.第n层的节点数最多为2n个节点</p><p>2.n层二叉树最多有20+…+2n=2n+1-1个节点</p><p>3.第一个非叶子节点：length/2</p><p>4.一个节点的孩子节点：2n、2n+1</p></blockquote><h3 id="基础遍历"><a href="#基础遍历" class="headerlink" title="基础遍历"></a>基础遍历</h3><h5 id="▉前序遍历"><a href="#▉前序遍历" class="headerlink" title="▉前序遍历"></a>▉前序遍历</h5><blockquote><p>​    若二叉树为空,则空操作返回,否则</p><ol><li><strong>先</strong>访问<strong>根</strong>结点</li><li>前序遍历<strong>左</strong>子树,</li><li>前序遍历<strong>右</strong>子树.</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092241832.png" alt="image-20210923092241832" style="zoom:50%;" /></p><ul><li><p>递归遍历</p><blockquote><p>先序递归遍历的思路是先遍历根结点，将值存入数组，然后递归遍历：先左结点，将值存入数组，继续向下遍历，然后再回溯遍历右结点，将值存入数组，这样递归循环。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组var preOrderRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        preListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中        preOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树        preOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树    &#125;&#125;preOrderRec(tree);console.log(preListRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]</code></pre></div></li><li><p>非递归遍历</p><blockquote><p>先序非递归遍历是利用了栈，将根结点放入栈中，然后再取出来，将值放入结果数组，然后如果存在右子树，将右子树压入栈，如果存在左子树，将左子树压入栈，然后循环判断栈是否为空，重复上述步骤。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListUnRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组var preOrderUnRecursion = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历            node = stack.pop(); <span class="hljs-regexp">//</span>从栈中取出一个结点            preListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中            <span class="hljs-keyword">if</span> (node.right) stack.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树压入栈            <span class="hljs-keyword">if</span> (node.left) stack.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树压入栈        &#125;    &#125;&#125;preOrderUnRecursion(tree);console.log(preListUnRec);</code></pre></div></li></ul><h5 id="▉中序遍历"><a href="#▉中序遍历" class="headerlink" title="▉中序遍历"></a>▉中序遍历</h5><blockquote><p>​    若树为空,则空操作返回,否则</p><ol><li>从根结点开始(注意不是先访问根结点)</li><li>中序遍历根结点的左子树,然后是访问根结点</li><li>中序遍历右子树</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092324252.png" alt="image-20210923092324252" style="zoom:50%;" /></p><p>递归遍历</p><blockquote><p>中序递归遍历的思路是先递归遍历左子树，从最后一个左子树开始存入数组，然后回溯遍历双亲结点，再是右子树，这样递归循环</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组var inOrderRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        inOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树        inListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中        inOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树    &#125;&#125;inOrderRec(tree);console.log(inListRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]</code></pre></div><p>非递归遍历</p><blockquote><p>非递归遍历的思路是将当前结点压入栈，然后将左子树当做当前结点，如果当前结点为空，将双亲结点取出来，将值保存进数组，然后将右子树当做当前结点，进行循环。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListUnRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组var inOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var stack = []; <span class="hljs-regexp">//</span>建立一个栈        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span> || node) &#123; <span class="hljs-regexp">//</span>如果栈不为空或结点不为空，则循环遍历            <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>如果结点不为空                stack.push(node); <span class="hljs-regexp">//</span>将结点压入栈                node = node.left; <span class="hljs-regexp">//</span>将左子树作为当前结点            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span>左子树为空，即没有左子树的情况                node = stack.pop(); <span class="hljs-regexp">//</span>将结点取出来                inListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中                node = node.right; <span class="hljs-regexp">//</span>将右结点作为当前结点            &#125;        &#125;    &#125;&#125;inOrderUnRec(tree);console.log(inListUnRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]</code></pre></div><h5 id="▉后序遍历"><a href="#▉后序遍历" class="headerlink" title="▉后序遍历"></a>▉后序遍历</h5><blockquote><p>​    若树为空,则空操作返回，否则</p><ol><li>从左到右先叶子后结点的方式遍历访问左右子树</li><li>最后是访问根结点.</li></ol></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092350092.png" alt="image-20210923092350092" style="zoom:50%;" /><p>递归</p><blockquote><p>递归遍历也是和上面的差不多，先走左子树，当左子树没有孩子结点时，将此结点的值放入数组中，然后回溯遍历双亲结点的右结点，递归遍历。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组var postOrderRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        postOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树        postOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树        postListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中    &#125;&#125;postOrderRec(tree);console.log(postListRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]</code></pre></div><p>非递归</p><blockquote><p>这里使用了一个tmp变量来记录上一次出栈、入栈的结点。思路是先把根结点和左树推入栈，然后取出左树，再推入右树，取出，最后取根结点</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListUnRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组var postOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈        var tmp = null; <span class="hljs-regexp">//</span>定义缓存变量        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历            tmp = stack[stack.length - <span class="hljs-number">1</span>]; <span class="hljs-regexp">//</span>将栈顶的值保存在tmp中            <span class="hljs-keyword">if</span> (tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果存在左子树                stack.push(tmp.left); <span class="hljs-regexp">//</span>将左子树结点压入栈            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp.right &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果结点存在右子树                stack.push(tmp.right); <span class="hljs-regexp">//</span>将右子树压入栈中            &#125; <span class="hljs-keyword">else</span> &#123;                postListUnRec.push(stack.pop().value);                node = tmp;            &#125;        &#125;    &#125;&#125;postOrderUnRec(tree);console.log(postListUnRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]</code></pre></div><p>▉广度遍历</p><blockquote><p>广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。<br>实现原理：使用数组模拟队列，首先将根结点归入队列。当队列不为空时，执行循环：取出队列的一个结点，如果该节点有左子树，则将该节点的左子树存入队列；如果该节点有右子树，则将该节点的右子树存入队列。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var breadthList = []; <span class="hljs-regexp">//</span>定义保存广度遍历结果的数组var breadthTraversal = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var que = [node]; <span class="hljs-regexp">//</span>将二叉树放入队列        <span class="hljs-keyword">while</span> (que.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>判断队列是否为空            node = que.shift(); <span class="hljs-regexp">//</span>从队列中取出一个结点            breadthList.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值保存到数组            <span class="hljs-keyword">if</span> (node.left) que.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树放入队列            <span class="hljs-keyword">if</span> (node.right) que.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树放入队列        &#125;    &#125;&#125;breadthTraversal(tree);console.log(breadthList);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ]</code></pre></div><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><blockquote><p>第一步：先考虑用递归的方式解决问题，注意递归的终止条件。有的递归需要用到回溯法和全局变量</p><p>第二步：如果递归无法解决问题，考虑迭代法，具体的迭代方式参考层序遍历和非递归遍历</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，用的是一般为后序，例如单纯求深度就用前序，二叉树找所有路径也用了前序，这是为了方便让父节点指向子节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MOGu面经</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/13/MOGU/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/13/MOGU/</id>
    <published>2021-09-13T00:08:08.868Z</published>
    <updated>2021-09-23T03:02:43.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MOGU面经收集"><a href="#MOGU面经收集" class="headerlink" title="MOGU面经收集"></a>MOGU面经收集</h1><p>2019-08-14</p><blockquote><ol><li>说一些 ES6 你擅长的东西（说了let、const、proxy、promise，面：说有深度的，我：。。。）</li><li>b === b + 1?如何实现</li><li>JS 可以实现多线程吗？</li><li>setTimeout 和 promise 谁先执行的题</li><li>点一个链接直接实现点赞功能，原理？</li><li>短连接变成长连接使用了哪些知识点。</li><li>节流防抖实现</li><li>首屏加载问题</li><li>性能优化</li><li>项目</li></ol></blockquote><p> 2019-08-30 </p><blockquote><p>vue<br>1.对整个vue的了解程度<br>2.vue生命周期<br>3.如何用函数的方式调用组件</p><p>css<br>4.em和rem区别</p><p>js<br>5.let const var 区别<br>6.const一个对象，它的值可以变吗，为什么<br>优化<br>7.图片很多怎么减少http请求<br>8.跨域的方式<br>9 .印象深刻的项目经验</p></blockquote><p>2019-08-19(一面)</p><blockquote><p>自我介绍</p><p>实习做的事，遇到了哪些困难，做了什么优化</p><p>画一个三角形</p><p>排序算法（手写快排）</p><p>js继承（手写两个）</p><p>new的过程</p><p>虚拟dom（解决了什么困难）</p><p>ajax过程</p><p>apply 、 call 、bind异同</p><p>闭包</p><p>深浅拷贝</p><p>瀑布流实现</p><p>重排重绘</p><p>使用vue中遇到哪些问题</p><p>为什么Object.defineProperty监听不到数组长度等变化</p><p>输入url到页面展示过程</p></blockquote><p> 2019-08-13 </p><blockquote><p>1.自我介绍<br>2.讲一下项目做了些什么（原型用的什么工具）<br>3.项目工程化思维<br>4.标准盒模型，ie盒模型<br>5.水平垂直居中<br>6.响应式<br>7.rem<br>8.ui框架改变样式不影响其他人<br>9.子代选择器和后代选择器的权重<br>10.实现一个动画<br>11.重排重绘<br>12.怎么让动画更加流畅<br>13.前端搜索，不同条件下可能有相同的结果（结果会很多，1000条数据），你怎么去优化（缓存？？分页？？）<br>14.浏览器的存储<br>15.图片预加载和懒加载<br>16.防抖节流（口述节流算法）<br>17.闭包，内存泄漏（怎么解决内存泄漏）<br>18.永久绑定作用域，构建一个公共函数，但是不传对象参数，怎么绑定（？？）<br>19.让a === a + e(常量) 可以实现吗<br>20.js线程<br>21.setTimeout是一个线程吗<br>21.事件委托<br>22.实现长url转换为一个短的url<br>23.302（可以实现刚才的url转换吗）<br>24.vue生命周期<br>25.vue兄弟组件通信<br>26.diff算法<br>27.template渲染过程<br>28.jsonp<br>29.场景题：你老板的手机，看你们开发的微信小程序，遇到了白屏的情况，问你怎么排查问题（问题可能不会复现，你怎么保证添加数据去复现这个场景）<br>30.场景题：直播行业发达，怎么给每个人的发送的消息加一个唯一的标识，相当于id的样子，如何实现<br>31.平时除了做项目还会做些什么<br>(体会就是项目上最好就是讲项目难点，为什么会出现，怎么一步步去解决的<br>项目上做了什么功能，你怎么实现的，你怎么去做项目的)</p></blockquote><p>2017-08-31 </p><blockquote><p>​    一面（2017.08.17，50min） </p><p> 头天晚上投了简历，第二天HR就打电话约面试了，效率很高。 </p><ol><li><p> 自我介绍 </p></li><li><p> 对<a href="">前端</a>这个行业怎么看，为什么要做<a href="">前端</a>？ </p></li><li><p> 对自己未来的规划？ </p></li><li><p> 说一下你理解的<a href="">前端</a>开发流程？ </p></li><li><p> 如何理解 <a href="">JavaScript</a> 闭包？ </p></li><li><p> 如何理解 <a href="">JavaScript</a> this 关键字？ </p></li><li><p> <a href="">JavaScript</a> 基本数据类型？ </p></li><li><p> Undifined 和 Null 的区别？ </p></li><li><p> 了解的 <a href="">JavaScript</a> 数组方法？ </p></li><li><p> CSS单位 rem 和 em 的区别？ </p></li><li><p> 了解的原生 <a href="">JavaScript</a> 方法？ </p></li><li><p> CSS 选择器优先级？ </p></li><li><p> 如何理解 HTML 语义化？ </p></li><li><p> 如何取消一个事件监听？ </p></li><li><p> ‘==’ 和 ‘===’ 的区别？ </p></li><li><p> 如何选择<a href="">前端</a>框架？ </p></li><li><p> 你的优点和缺点是什么？ </p></li><li><p> 当你在一个团队的时候，你的憧憬是什么？ </p></li><li><p>还有什么想问我的？ </p><p>基础问了一点，问了很多关于<a href="">职业规划</a>的问题。中规中矩。</p></li></ol><p>作者：梦游计<br>链接：<a href="https://www.nowcoder.com/discuss/33673?type=2&amp;order=3&amp;pos=22&amp;page=1">https://www.nowcoder.com/discuss/33673?type=2&amp;order=3&amp;pos=22&amp;page=1</a><br>来源：牛客网</p><h3 id="二面（2017-8-21，30min）"><a href="#二面（2017-8-21，30min）" class="headerlink" title="二面（2017.8.21，30min）"></a>二面（2017.8.21，30min）</h3><ol><li> 聊<a href="">项目</a> </li><li> 从什么时候接触<a href="">前端</a>的？ </li><li> 你专业方向是J2EE，当时为什么不选择J2EE？ </li><li> <a href="">JavaScript</a> 和其他语言的面向对象的区别？ </li><li> 继续聊<a href="">项目</a> </li><li> 兼职实习在做什么？ </li><li> 上一次面试官问的什么问题，哪些答的好，哪些答的不好，之后有查过嘛？ </li><li> 还有什么要问我的？</li></ol></blockquote><p>面试准备</p><blockquote><p>1.const<br>2.let var 之间的区别<br>4、es6中的const解释解释<br>9.em和rem区别<br>3.js部分，const，let和 var 的区别。<br>4.js部分，数组遍历map和forEach的区别。</p><div class="hljs code-wrapper"><pre><code class="hljs gcode">能用forEach<span class="hljs-comment">()</span>做到的，map<span class="hljs-comment">()</span>同样可以。反过来也是如此。map<span class="hljs-comment">()</span>会分配内存空间存储新数组并返回，forEach<span class="hljs-comment">()</span>不会返回数据。forEach<span class="hljs-comment">()</span>允许callback更改原始数组的元素。map<span class="hljs-comment">()</span>返回新的数组。</code></pre></div><p>5.css部分，em和rem怎么做自适应。<br>8.函数提升和变量提升优先级</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">函数提升 优于变量解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第<span class="hljs-number">40</span>页提到函数声明是优于变量提升的。可见代码<span class="hljs-built_in">console</span>.log(getName)<span class="hljs-keyword">var</span> getName = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;<span class="hljs-comment">// 输出为函数getName</span>注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了)</code></pre></div><p>JS深拷贝的用处，哪里会用到？</p><blockquote><p>浅拷贝<br>深拷贝</p></blockquote><p>7、闭包以及带来问题<br>闭包知道吗？它可能出现的问题呢<br>10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）<br>11、flex实现水平垂直居中<br>12、align-items:center是不是只针对垂直<br>css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟<br>CSS布局技巧<br>跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？<br>6.跨域问题<br>6.常用的跨域方式。<br>项目有没跨域问题<br>5.作用域链<br><a href="https://juejin.im/post/58ed9c0ea0bb9f006a4c28cd">JavaScript深入之作用域链</a><br><a href="https://juejin.im/post/5c8290455188257e5d0ec64f">深入理解JavaScript作用域和作用域链</a></p><div class="hljs code-wrapper"><pre><code class="hljs gcode">作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级<span class="hljs-comment">(词法层面上的父级)</span>执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</code></pre></div><p>第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。<br>然后继续回答原型链。</p><p>2、Promise了解多少</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span> 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。pending，异步任务正在进行。resolved (也可以叫fulfilled)，异步任务执行成功。rejected，异步任务执行失败。回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的<span class="hljs-built_in">Promise</span>.resolve(value)类方法，该方法返回一个以 value 值解析后的 <span class="hljs-built_in">Promise</span> 对象<span class="hljs-number">1</span>、如果这个值是个 thenable（即带有 then 方法），返回的 <span class="hljs-built_in">Promise</span> 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）<span class="hljs-number">2</span>、如果传入的 value 本身就是 <span class="hljs-built_in">Promise</span> 对象，  则该对象作为 <span class="hljs-built_in">Promise</span>.resolve 方法的返回值返回。<span class="hljs-number">3</span>、其他情况以该值为成功状态返回一个 <span class="hljs-built_in">Promise</span> 对象。<span class="hljs-built_in">Promise</span>.all的用法：谁跑的慢，以谁为准执行回调。  all接收一个数组参数，里面的值最终都算返回<span class="hljs-built_in">Promise</span>对象  all方法可以说是<span class="hljs-built_in">Promise</span>中很常用的方法了，它的作用就是将一个数组的<span class="hljs-built_in">Promise</span>对象放在其中，当全部resolve的时候就会执行then方法，当有一个reject的时候就会执行<span class="hljs-keyword">catch</span>，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。<span class="hljs-built_in">Promise</span>.race的用法：谁跑的快，以谁为准执行回调它的作用是将一个<span class="hljs-built_in">Promise</span>数组放入race中，哪个先执行完，race就直接执行完，并从then中取值。<span class="hljs-built_in">Promise</span>.prototype.catch  实例方法，捕获异常，函数形式：<span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params">err</span>)</span>&#123;&#125;, err 是 <span class="hljs-keyword">catch</span> 注册 之前的回调抛出的异常信息。<span class="hljs-built_in">Promise</span>.prototype.then  实例方法，为 <span class="hljs-built_in">Promise</span> 注册回调函数，函数形式：<span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params">vlaue</span>)</span>&#123;&#125;，value 是上一个任务的返回结果，then 中的函数一定要 <span class="hljs-keyword">return</span> 一个结果或者一个新的 <span class="hljs-built_in">Promise</span> 对象，才可以让之后的then 回调接收。<span class="hljs-built_in">Promise</span>.reject类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。<span class="hljs-built_in">Promise</span>的立即执行性<span class="hljs-built_in">Promise</span> 三种状态<span class="hljs-built_in">Promise</span> 状态的不可逆性then方法链式调用<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span></code></pre></div><p>promise有了解吗<br>Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。）</p><p>3.React 生命周期，如果要合并 props 和 state 在哪进行<br>4.React 组件想用函数调用的方式使用，怎么设计<br>react如果更新了父组件，子组件没有更新，会都重新渲染吗？<br>react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道<br>react相关的redux的原理？<br>7.你印象比较深的项目或者代码<br>我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render<br>挂载组件到指定节点，然后通过更新 props 使用<br>html css js擅长哪部分？<br>我回答擅长js，但他居然没有继续问下去了</p><p>3、es5和es6了解多少<br>es5,es6哪个用的多点？<br>3、es5和es6了解多少</p><div class="hljs code-wrapper"><pre><code class="hljs livescript">变量声明：<span class="hljs-keyword">let</span> <span class="hljs-keyword">const</span>字符串模板解构赋值 对象对对象 数组对数组扩展运算符箭头函数  不需要 <span class="hljs-keyword">function</span> 关键字来创建函数  省略 <span class="hljs-keyword">return</span> 关键字  继承当前上下文的 <span class="hljs-built_in">this</span> 关键字<span class="hljs-keyword">import</span>导入模块、<span class="hljs-keyword">export</span>导出模块<span class="hljs-built_in">Promise</span>数组常用方法：<span class="hljs-built_in">Array</span>.isArray<span class="hljs-keyword">map</span>filterforEacheveryreducespliceindexOfsliceconcatreverse()join()<span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>()<span class="hljs-built_in">Array</span>.<span class="hljs-keyword">of</span>()copyWitchfindfindIndexkeys()values()<span class="hljs-class"><span class="hljs-keyword">class</span> 静态、私有、共有</span>生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的<span class="hljs-keyword">function</span>多了个星号*，在其函数体内可以使用<span class="hljs-keyword">yield</span>关键字,有意思的是函数会在每个<span class="hljs-keyword">yield</span>后暂停。可以暂停并重新开始执行的函数generators 可以扮演三种角色  迭代器(数据生产者)  观察者(数据消费者)  协作程序(数据生产者和消费者)</code></pre></div><p><a href="https://segmentfault.com/a/1190000012358863">es6 Generators详解</a></p><p>2.CSS sprite(雪碧图或者精灵图)<br><a href="https://www.cnblogs.com/evenyao/p/9262371.html">CSS Sprite “精灵图”</a><br><a href="https://blog.csdn.net/CamilleZJ/article/details/80406645">CSS Sprite雪碧图</a></p><div class="hljs code-wrapper"><pre><code class="hljs arduino">用CSS的<span class="hljs-string">&quot;background-image&quot;</span>，<span class="hljs-string">&quot;background-repeat&quot;</span>，<span class="hljs-string">&quot;background-position&quot;</span>的组合进行背景定位，<span class="hljs-built_in">background</span>-<span class="hljs-built_in">position</span>可以用数字精确的定位出背景图片的位置。CSS Sprites 的优点：减少图片字节减少网页HTTP请求，提高网页性能减少命名难的问题缺点图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。</code></pre></div><p>事件节流？刚看过，没印象了，哭。<br>情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖</p><p>vue和react差别，<br>8、问了vue有没有做过项目，然后就没有了<br>1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。<br>2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。<br>问了一个异步加载组件，不用标签引入的方法。<br>让你实现vue你怎么实现……<br>说说vue的双向绑定（顺带把响应式说了）<br>说说Vue的diff过程</p><div class="hljs code-wrapper"><pre><code class="hljs maxima">如果不了解virtual dom，要理解<span class="hljs-built_in">diff</span>的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。<span class="hljs-built_in">diff</span>的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。在采取<span class="hljs-built_in">diff</span>算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。<span class="hljs-built_in">diff</span>流程图当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点判断两节点是否值得比较，值得比较则执行patchVnode不值得比较则用Vnode替换oldVnode如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法这个函数做了以下事情：  找到对应的真实dom，称为el  判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接<span class="hljs-built_in">return</span>  如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。  如果oldVnode有子节点而Vnode没有，则删除el的子节点  如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el  如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要updateChildren先说一下这个函数做了什么  将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来  oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的<span class="hljs-number">2</span>个变量相互比较，一共有<span class="hljs-number">4</span>种比较方式。如果<span class="hljs-number">4</span>种比较都没匹配，如果设置了<span class="hljs-built_in">key</span>，就会用<span class="hljs-built_in">key</span>进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</code></pre></div><p>v-model，v-bind 和v-click</p><div class="hljs code-wrapper"><pre><code class="hljs dart">v-bind  动态地绑定一个或多个特性、或一个组件 prop 到表达式。<span class="hljs-number">1</span>:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=<span class="hljs-string">&quot;表达式&quot;</span>v-model 在表单控件或者组件上创建双向绑定。v-<span class="hljs-keyword">on</span> 指令用于监听DOM事件 形式如：v-<span class="hljs-keyword">on</span>:click  缩写为 <span class="hljs-meta">@click</span>;[VUE中的v-<span class="hljs-keyword">if</span>与v-<span class="hljs-keyword">show</span>](http:<span class="hljs-comment">//www.cnblogs.com/wmhuang/p/5420344.html)</span>手段：v-<span class="hljs-keyword">if</span>是动态的向DOM树内添加或者删除DOM元素；v-<span class="hljs-keyword">show</span>是通过设置DOM元素的display样式属性控制显隐；编译过程：v-<span class="hljs-keyword">if</span>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-<span class="hljs-keyword">show</span>只是简单的基于css切换；编译条件：v-<span class="hljs-keyword">if</span>是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)v-<span class="hljs-keyword">if</span>是动态的向DOM树内添加或者删除DOM元素；v-<span class="hljs-keyword">show</span>是通过设置DOM元素的display样式属性控制显隐；v-<span class="hljs-keyword">show</span>是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；性能消耗：v-<span class="hljs-keyword">if</span>有更高的切换消耗；v-<span class="hljs-keyword">show</span>有更高的初始渲染消耗；使用场景：v-<span class="hljs-keyword">if</span>适合运营条件不大可能改变；v-<span class="hljs-keyword">show</span>适合频繁切换。v-<span class="hljs-keyword">if</span> 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-<span class="hljs-keyword">if</span> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-<span class="hljs-keyword">show</span> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说， v-<span class="hljs-keyword">if</span> 有更高的切换开销，而 v-<span class="hljs-keyword">show</span> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-<span class="hljs-keyword">show</span> 较好；如果在运行时条件不太可能改变，则使用 v-<span class="hljs-keyword">if</span> 较好。</code></pre></div><p>function a(){}，a的<strong>proto</strong> 指向哪，Function呢？Object呢？<br>js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。</p><p>1.就我这次面试表现而言，有哪方面需要提升或者欠缺的<br>3.团队技术栈？<br>然后项目……照着你简历上的问，<br>技术选型，遇到的困难，解决思路，</p><p>面试中印象最深的问题<br>场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。<br>然后开始面试，很少技术问题<br>项目难点，如何解决的<br>有没有想过进入一个团队实习之后会有哪些压力大的事情？<br>有没有了解前端的新技术<br>有没有参加线下前端活动<br>会去看哪些博客或者社区<br>CSS动画和JS动画。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript"> (<span class="hljs-number">1</span>)浏览器可以对动画进行优化。  <span class="hljs-number">1</span>、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:<span class="hljs-number">1</span>)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒<span class="hljs-number">60</span>帧。<span class="hljs-number">2</span>)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。  <span class="hljs-number">2</span>、强制使用硬件加速 （通过 GPU 来提高动画性能）  (<span class="hljs-number">2</span>)代码相对简单,性能调优方向固定  (<span class="hljs-number">3</span>)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码缺点：　　<span class="hljs-number">1</span>、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告 　  <span class="hljs-number">2</span>、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。JavaScript  (<span class="hljs-number">1</span>)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。  (<span class="hljs-number">2</span>)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成  (<span class="hljs-number">3</span>)CSS3有兼容性问题，而JS大多时候没有兼容性问题缺点：　　　(<span class="hljs-number">1</span>)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。  (<span class="hljs-number">2</span>)代码的复杂度高于CSS动画</code></pre></div><p>后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下<br>webpack的打包目录为啥是这样的，知道原理吗？<br>大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊<br>7.项目印象深刻的部分和难点。<br>二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况<br>自我介绍<br>项目介绍<br>你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？<br>一个骰子，5个面，你怎么实现它（一个面你怎么布局）<br>说说事件循环<br>假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）<br>1、自我介绍 + 项目介绍（难点）<br>5、事件委托<br>6、任务队列<br>9、一个场景题（关于使用调试工具的）<br>13、bootstrap中的栅格式<br>一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了</p><p>重绘&amp;&amp;回流<br>vue differ<br>vue 生命周期<br>跨域<br>自我介绍</p><p>JavaScript 怎么实现 OOP<br>原型继承与类继承的区别<br>闭包的应用场景<br>关系完整性约束</p><p>Cookie &amp; Session 的区别<br>Session 的实现原理<br>HTTP 请求方法中哪些是幂等性的<br>跨域处理方案<br>JSONP 的缺点以及安全隐患<br>为什么要做单元测试<br>黑盒测试与白盒测试的区别<br>怎样实现测试覆盖率<br>Async &amp; Await 的使用</p><p>块级元素、行内元素、inline-block 的区别<br>水平居中的方法<br>String、Array 常用的方法<br>输入一个 URL 到呈现页面的过程<br>Vue.js 组件的生命周期<br>Git 怎么合并提交记录<br>Linux 常用的命令<br>HTTP2 新特性</p><p>常见的 Web 攻击手段以及防范措施<br>对 Ajax 的理解<br>对闭包的理解<br>对事件机制的理解<br>对 HTTP 的理解<br>GET &amp; POST 的区别<br>HTTP2 和 HTTP1 有什么不同<br>对 JavaScript 各大框架的理解<br>对 jQuery 的理解<br>页面性能优化<br>计算机网络分层<br>输入 <a href="http://www.qq.com/">www.qq.com</a> 到呈现页面的过程<br>事件机制（W3C 标准）<br>事件代理<br>XSS、CSRF 的防范<br>token 的实现原理<br>熟练使用JS实现Json、XML格式的数据发送与数据解析；<br>3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器；</p><p>自我介绍<br>事件流<br>vue nextTick原理<br>vue react区别<br>web优化<br>移动端的优化有特别了解过吗<br>css flex了解过吗<br>如何前端监控错误，<br>koa有学过吗<br>事件循环说一说<br>web新技术了解过哪些，最近有去学习哪些东西<br>PWA你能详细说说吗<br>service worker<br>h5 worker<br>非受控组件 与受控组件<br>const let var区别<br>三道题<br>有自己写过webpack插件吗<br>webpack loader 和plugin区别<br>实现promise<br>大数相加<br>纯js写一个动画，5s由快到慢，速度自定义<br>（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）<br>自我介绍，说一下怎么学习前端的，以及做的项目的亮点<br>web优化<br>缓存（协商，强制说一说）<br>CDN</p><div class="hljs code-wrapper"><pre><code class="hljs scss">CDN的全称是<span class="hljs-attribute">Content</span> Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。降低核心系统负载 加速用户访问CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</code></pre></div><p>DNS如何查询域名的<br>node中间件原理<br>跨域<br>作用域<br>一个页面白屏，分析原因<br>数据结构链表<br>怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）<br>cookie了解吗<br>cookie的属性，怎么存储<br>web安全，xss csrf<br>css响应式布局<br>token生成过程<br>前端新技术<br>PWA讲一讲<br>serviceworker<br>h5 worker<br>智商题<br>3.45分夹角<br>两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离<br>10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来</p><p>三面<br>自我介绍<br>web优化<br>css动画<br>csrf如何防御<br>如何生成token<br>Vue的diff能详细说一说吗<br>Vue子组件你的子组件方法是放在哪里的<br>Vue自定义指令<br>微信小程序接触过吗<br>微信小程序原理<br>TCP三次握手第三次失败了 客户端和服务端是如何处理的<br>301，302状态码区别，以及什么时候会返回这些状态。<br>node如何升级到webSoket<br>如何添加header头<br>DNS迭代和递归区别<br>前端怎么设置cookie过期<br>有看过源码吗<br>看过哪些书<br>能来实习的时间<br>智商题<br>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的<br>算法 最大的回文字符<br>北森<br>一面<br>面试官非常nice，善于引导<br>自我介绍<br>你的项目<br>能说下vue如何收集依赖双向绑定的吗<br>能说下vue如何更新节点的吗<br>node如何打印时间与错误<br>webpack构建流程<br>webpack如何找到依赖关系的<br>webpack如何配置<br>vue和react区别<br>react生命周期<br>函数式组件，如何给状态（hook）<br>原型链，原型知道多少<br>es6了解哪些<br>promise.resolve()<br>http状态码<br>post请求之前先发送Option条件<br>get,post,put,delete区别（冥等）<br>二面<br>面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的<br>vue,react，你更倾向于哪一个，为什么<br>es6模块cmd amd 区别<br>跨域<br>深拷贝，浅拷贝<br>post发送Option的条件<br>输入URL到浏览器会发生什么<br>TCP为什么三次握手<br>TCP为什么四次挥手<br>HTTP为什么基于TCP协议<br>vue diff过程<br>vue如果同一个数据，很短的时间内连续更新 会怎么样。<br>算法题<br>[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]</p><p>三面<br>面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以<br>有这样一个数组，你如何扁平化<br>如果用字符串形式会出现什么问题<br>跨域你如何处理的<br>能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。<br>你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）<br>能具体一点说说吗，说一点就可以<br>你觉得你相比其他实习生的优点和缺点在哪里</p><p>前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。<br>了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MOGU面经收集&quot;&gt;&lt;a href=&quot;#MOGU面经收集&quot; class=&quot;headerlink&quot; title=&quot;MOGU面经收集&quot;&gt;&lt;/a&gt;MOGU面经收集&lt;/h1&gt;&lt;p&gt;2019-08-14&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;说一些 ES6 你</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vue源码解读🍺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-09-10T00:08:08.868Z</published>
    <updated>2021-09-25T04:45:18.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue源码解读"><a href="#vue源码解读" class="headerlink" title="vue源码解读"></a>vue源码解读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在深入学习vue，打算对源码做一些了解</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros">├── benchmarks                  性能、基准测试├── dist                        构建打包的输出目录├── examples                    案例目录├── flow                        flow 语法的类型声明├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的│   ├── vue-server-renderer│   ├── vue-template-compiler│   ├── weex-template-compiler│   └── weex-vue-framework├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件├── src                         vue 源码目录│   ├── compiler                编译器│   ├── core                    运行时的核心包│   │   ├── components          全局组件，比如 keep-alive│   │   ├── config.js           一些默认配置项│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等│   │   ├──<span class="hljs-built_in"> instance </span>           Vue 实例相关的，比如 Vue 构造函数就在这个目录下│   │   ├── observer            响应式原理│   │   ├── util                工具方法│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿│   ├── platforms               平台相关的编译器代码│   │   ├── web│   │   └── weex│   ├──<span class="hljs-built_in"> server </span>                 服务端渲染相关├── test                        测试目录├── types                       TS 类型声明</code></pre></div><h3 id="源码学习方法"><a href="#源码学习方法" class="headerlink" title="源码学习方法"></a>源码学习方法</h3><h3 id="flow-类型检测"><a href="#flow-类型检测" class="headerlink" title="flow 类型检测"></a>flow 类型检测</h3><blockquote><p>​    Flow就是JavaScript的静态类型检查工具，由Facebook团队于2014年的Scale Conference上首次提出。该库的目标在于检查JavaScript中的类型错误，开发者通常不需要修改代码即可使用，故使用成本很低。同时，它也提供额外语法支持，使得开发者能更大程度地发挥Flow的作用。总结一句话：将javascript从弱类型语言变成了强类型语言。</p><p>Flow支持原始数据类型，其中void对应js中的undefined</p><p>基本内型  boolean / number/  string  /null  /void</p><p>引用内型   Object / Array  /Function  /自定义Class</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue源码解读&quot;&gt;&lt;a href=&quot;#vue源码解读&quot; class=&quot;headerlink&quot; title=&quot;vue源码解读&quot;&gt;&lt;/a&gt;vue源码解读&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>html面试题🦗</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/26/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/26/html%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-08-26T08:26:03.787Z</published>
    <updated>2021-09-24T08:22:35.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html面试题"><a href="#html面试题" class="headerlink" title="html面试题"></a>html面试题</h1><h2 id="html知识点总结"><a href="#html知识点总结" class="headerlink" title="html知识点总结"></a>html知识点总结</h2><p>平时遇到的面试题的一些总结</p><ol><li><p>对WEB标准以及W3C的理解与认识？</p></li><li><p>Doctype作用，HTML5 为什么只需要写 <!DOCTYPE HTML></p></li><li><p> 行内元素有哪些，块级元素有哪些，空(void)元素有那些</p></li><li><p>简述一下你对HTML语义化的理解</p></li><li><p>HTML5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p></li><li><p>描述一下 cookie，sessionStorage 和 localStorage 的区别</p></li><li><p>如何实现浏览器内多个标签页之间的通信</p></li><li><p>HTML5的离线存储怎么使用，解释一下工作原理</p></li><li><p>src与href的区别</p></li><li><p>表单提交中Get和Post方式的区别</p></li><li><p>iframe有那些缺点？</p></li><li><p>语义化的理解</p></li><li><p>…</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;html面试题&quot;&gt;&lt;a href=&quot;#html面试题&quot; class=&quot;headerlink&quot; title=&quot;html面试题&quot;&gt;&lt;/a&gt;html面试题&lt;/h1&gt;&lt;h2 id=&quot;html知识点总结&quot;&gt;&lt;a href=&quot;#html知识点总结&quot; class=&quot;header</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="-面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器地址栏输入url到显示页面的步骤 🕸️</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/13/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/13/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</id>
    <published>2021-08-13T06:19:51.820Z</published>
    <updated>2021-09-13T01:47:07.378Z</updated>
    
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2021-08-12T03:38:59.577Z</published>
    <updated>2021-09-23T07:15:06.590Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目二：二维数组的查找"><a href="#题目二：二维数组的查找" class="headerlink" title="题目二：二维数组的查找"></a>题目二：二维数组的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>Example:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>Solve:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;题目二：二维数组的查找&quot;&gt;&lt;a href=&quot;#题目二：二维数组的查找&quot; class=&quot;headerlink&quot; title=&quot;题目二：二维数组的查找&quot;&gt;&lt;/a&gt;题目二：二维数组的查找&lt;/h4&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增</summary>
      
    
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>promise笔记🤓</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/promise/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/promise/</id>
    <published>2021-08-12T01:23:27.086Z</published>
    <updated>2021-09-25T04:45:07.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise笔记"><a href="#Promise笔记" class="headerlink" title="Promise笔记"></a>Promise笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Promise</code>本质上是一个对象,js的标准内置对象，官方对他的描述就是：Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p><blockquote><p>  面试时相关问题</p></blockquote><div class="hljs code-wrapper"><pre><code>1、了解 Promise 吗？2、Promise 解决的痛点是什么？3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。4、Promise 如何使用？5、Promise 常用的方法有哪些？它们的作用是什么？6、Promise 在事件循环中的执行过程是怎样的？7、Promise 的业界实现都有哪些？8、能不能手写一个 Promise 的 polyfill。</code></pre></div><blockquote><p>用来解决的问题</p></blockquote><p>众所周知，<code>promise</code>解决了js的回调地狱问题(层层调用，嵌套无底洞)…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Promise笔记&quot;&gt;&lt;a href=&quot;#Promise笔记&quot; class=&quot;headerlink&quot; title=&quot;Promise笔记&quot;&gt;&lt;/a&gt;Promise笔记&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>diff算法⛏️</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/diff%E7%AE%97%E6%B3%95/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/diff%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-11T06:58:41.630Z</published>
    <updated>2021-09-24T07:57:33.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;diff算法&quot;&gt;&lt;a href=&quot;#diff算法&quot; class=&quot;headerlink&quot; title=&quot;diff算法&quot;&gt;&lt;/a&gt;diff算法&lt;/h1&gt;</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定💻</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</id>
    <published>2021-08-11T00:08:08.868Z</published>
    <updated>2021-09-15T09:57:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a>vue双向绑定</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vue的双向绑定&amp;响应式原理是框架的</p><p> ▉ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue双向绑定&quot;&gt;&lt;a href=&quot;#vue双向绑定&quot; class=&quot;headerlink&quot; title=&quot;vue双向绑定&quot;&gt;&lt;/a&gt;vue双向绑定&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
