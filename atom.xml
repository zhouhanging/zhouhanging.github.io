<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HELLO</title>
  
  <subtitle>It is never too late to learn</subtitle>
  <link href="https://zhouhang-hello.gitee.io/hexo_blog/atom.xml" rel="self"/>
  
  <link href="https://zhouhang-hello.gitee.io/hexo_blog/"/>
  <updated>2021-09-23T06:49:25.617Z</updated>
  <id>https://zhouhang-hello.gitee.io/hexo_blog/</id>
  
  <author>
    <name>hello</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vuex使用</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/23/vuex%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/23/vuex%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-23T03:02:25.530Z</published>
    <updated>2021-09-23T06:49:25.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/17/axios%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/17/axios%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-09-17T01:39:56.538Z</published>
    <updated>2021-09-24T07:57:25.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios拦截器接口配置与使用"><a href="#axios拦截器接口配置与使用" class="headerlink" title="axios拦截器接口配置与使用"></a>axios拦截器接口配置与使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习期间遇到了一个axios拦截器接口配置的问题，这里总结一下相关使用</p><p>附上官方文档(<a href="http://axios-js.com/zh-cn/docs/index.html">http://axios-js.com/zh-cn/docs/index.html</a>)</p><p> ▉ 什么是axios拦截器、为什么要使用axios拦截器？</p><blockquote><ul><li><p> Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p></li><li><p>页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；如果请求数非常多，单独对每一个请求进行处理会变得非常麻烦，程序的优雅性也会大打折扣。好在强大的axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</p></li><li><p>它有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等</p></li></ul></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210917154842286.png" alt="image-20210917154842286" style="zoom:50%;" /><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//   在http.js中引入axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>   <span class="hljs-comment">//引入 axios</span><br><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>; <span class="hljs-comment">// 引入qs模块，用来序列化post类型的数据，某些请求会用得到</span><br><span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>    <span class="hljs-comment">//引入 element-ui 的 Message 模块，用于信息提示</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span>     <span class="hljs-comment">//引入 vuex 中的数据</span><br><span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span>   <span class="hljs-comment">//引入拿到的权限tocken</span><br><br><span class="hljs-comment">// create an axios instance   创建axios实例</span><br><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>配置信息...<br>&#125;)<br><br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">`配置引入`<br>import Qs from <span class="hljs-string">&#x27;qs&#x27;</span>;<br>export default&#123;<br>  <span class="hljs-regexp">//</span> 请求的接口，在请求的时候，如axios.get(url,config);这里的url会覆盖掉config中的url<br>  url: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-regexp">//</span> 请求的接口<br>  baseURL: <br>  <span class="hljs-regexp">//</span> 默认请求方法<br>  title: <span class="hljs-string">&#x27;&#x27;</span>,<br>  method: <span class="hljs-string">&#x27;post&#x27;</span>,<br>  <span class="hljs-regexp">//</span> 在发送请求之前对请求数据做处理<br>  transformRequest: [<br>    <span class="hljs-keyword">function</span>(data) &#123;<br>      <span class="hljs-regexp">//</span> 为了避免qs格式化时对内层对象的格式化先把内层的对象转为<br>      <span class="hljs-regexp">//</span> data.strSQL = base64encode(data.strSQL)<br>      <span class="hljs-regexp">//</span> 由于使用的form-data传数据所以要格式化<br>      data = Qs.stringify(data);<br>      return data;<br>    &#125;,<br>  ],<br><br>  <span class="hljs-regexp">//</span> 提前处理返回的数据=<br>  transformResponse: [<br>    <span class="hljs-keyword">function</span>(data) &#123;<br>      return data;<br>    &#125;,<br>  ],<br>  <span class="hljs-regexp">//</span> 请求头信息<br>  headers: &#123;<br>    <br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 默认parameter参数<br>  params: &#123;<br><br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 序列化param<br>  paramsSerializer: <span class="hljs-keyword">function</span>(params) &#123;<br>    return Qs.stringify(params);<br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 默认post参数，使用axios.post(url,&#123;&#125;,config);如果没有额外的也必须要用一个空对象，否则会报错<br>  data: &#123;<br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 设置超时时间<br>  timeout: <span class="hljs-number">500000000</span>,<br><br>  <span class="hljs-regexp">//</span> 是否跨站点访问控制请求<br>  <span class="hljs-regexp">//</span> withCredentials: false, <span class="hljs-regexp">//</span> default<br>  withCredentials: true, <span class="hljs-regexp">//</span> 自动携带cookie<br><br>  <span class="hljs-regexp">//</span> 返回数据类型<br>  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-regexp">//</span> default<br><br>  <span class="hljs-regexp">//</span> 将upload事件注释掉，防止跨域状态下发起option请求<br><br>  <span class="hljs-regexp">//</span> onUploadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;<br>  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event<br>  <span class="hljs-regexp">//</span> &#125;,<br>  <span class="hljs-regexp">//</span> onDownloadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;<br>  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event<br>  <span class="hljs-regexp">//</span> &#125;,<br>  maxContentLength: <span class="hljs-number">2000</span>,<br>  validateStatus: <span class="hljs-keyword">function</span>(status) &#123;<br>    return status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-regexp">//</span> default<br>  &#125;,<br>  <span class="hljs-regexp">//</span> `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目<br>  <span class="hljs-regexp">//</span> 如果设置为<span class="hljs-number">0</span>，将不会 follow 任何重定向<br>  maxRedirects: <span class="hljs-number">5</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p> ▉ 请求拦截器</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.request.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(config) &#123;<br>    // 在发起请求请做一些业务处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">config</span>;<br>  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;<br>    // 对请求失败做处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;<br>  &#125;);<br></code></pre></div></td></tr></table></figure></blockquote><p> ▉ 响应拦截器</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.response.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(response) &#123;<br>    // 对响应数据做处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">response</span>;<br>  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;<br>    // 对响应错误做处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;<br>  &#125;);<br></code></pre></div></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios拦截器接口配置与使用&quot;&gt;&lt;a href=&quot;#axios拦截器接口配置与使用&quot; class=&quot;headerlink&quot; title=&quot;axios拦截器接口配置与使用&quot;&gt;&lt;/a&gt;axios拦截器接口配置与使用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-09-15T00:08:08.868Z</published>
    <updated>2021-09-23T01:37:16.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是用来模拟具有树状结构性质的数据集合,顾名思义，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”</p><h3 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h3><blockquote><p>1.第n层的节点数最多为2n个节点</p><p>2.n层二叉树最多有20+…+2n=2n+1-1个节点</p><p>3.第一个非叶子节点：length/2</p><p>4.一个节点的孩子节点：2n、2n+1</p></blockquote><h3 id="基础遍历"><a href="#基础遍历" class="headerlink" title="基础遍历"></a>基础遍历</h3><h5 id="▉前序遍历"><a href="#▉前序遍历" class="headerlink" title="▉前序遍历"></a>▉前序遍历</h5><blockquote><p>​    若二叉树为空,则空操作返回,否则</p><ol><li><strong>先</strong>访问<strong>根</strong>结点</li><li>前序遍历<strong>左</strong>子树,</li><li>前序遍历<strong>右</strong>子树.</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092241832.png" alt="image-20210923092241832" style="zoom:50%;" /></p><ul><li><p>递归遍历</p><blockquote><p>先序递归遍历的思路是先遍历根结点，将值存入数组，然后递归遍历：先左结点，将值存入数组，继续向下遍历，然后再回溯遍历右结点，将值存入数组，这样递归循环。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组<br>var preOrderRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        preListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中<br>        preOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树<br>        preOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树<br>    &#125;<br>&#125;<br>preOrderRec(tree);<br>console.log(preListRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]<br><br></code></pre></div></td></tr></table></figure></li><li><p>非递归遍历</p><blockquote><p>先序非递归遍历是利用了栈，将根结点放入栈中，然后再取出来，将值放入结果数组，然后如果存在右子树，将右子树压入栈，如果存在左子树，将左子树压入栈，然后循环判断栈是否为空，重复上述步骤。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListUnRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组<br>var preOrderUnRecursion = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈<br>        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历<br>            node = stack.pop(); <span class="hljs-regexp">//</span>从栈中取出一个结点<br>            preListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中<br>            <span class="hljs-keyword">if</span> (node.right) stack.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树压入栈<br>            <span class="hljs-keyword">if</span> (node.left) stack.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树压入栈<br>        &#125;<br>    &#125;<br>&#125;<br>preOrderUnRecursion(tree);<br>console.log(preListUnRec);<br><br></code></pre></div></td></tr></table></figure></li></ul><h5 id="▉中序遍历"><a href="#▉中序遍历" class="headerlink" title="▉中序遍历"></a>▉中序遍历</h5><blockquote><p>​    若树为空,则空操作返回,否则</p><ol><li>从根结点开始(注意不是先访问根结点)</li><li>中序遍历根结点的左子树,然后是访问根结点</li><li>中序遍历右子树</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092324252.png" alt="image-20210923092324252" style="zoom:50%;" /></p><p>递归遍历</p><blockquote><p>中序递归遍历的思路是先递归遍历左子树，从最后一个左子树开始存入数组，然后回溯遍历双亲结点，再是右子树，这样递归循环</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组<br>var inOrderRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        inOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树<br>        inListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中<br>        inOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树<br>    &#125;<br>&#125;<br>inOrderRec(tree);<br>console.log(inListRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]<br><br></code></pre></div></td></tr></table></figure><p>非递归遍历</p><blockquote><p>非递归遍历的思路是将当前结点压入栈，然后将左子树当做当前结点，如果当前结点为空，将双亲结点取出来，将值保存进数组，然后将右子树当做当前结点，进行循环。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListUnRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组<br>var inOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var stack = []; <span class="hljs-regexp">//</span>建立一个栈<br>        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span> || node) &#123; <span class="hljs-regexp">//</span>如果栈不为空或结点不为空，则循环遍历<br>            <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>如果结点不为空<br>                stack.push(node); <span class="hljs-regexp">//</span>将结点压入栈<br>                node = node.left; <span class="hljs-regexp">//</span>将左子树作为当前结点<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span>左子树为空，即没有左子树的情况<br>                node = stack.pop(); <span class="hljs-regexp">//</span>将结点取出来<br>                inListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中<br>                node = node.right; <span class="hljs-regexp">//</span>将右结点作为当前结点<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>inOrderUnRec(tree);<br>console.log(inListUnRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><h5 id="▉后序遍历"><a href="#▉后序遍历" class="headerlink" title="▉后序遍历"></a>▉后序遍历</h5><blockquote><p>​    若树为空,则空操作返回，否则</p><ol><li>从左到右先叶子后结点的方式遍历访问左右子树</li><li>最后是访问根结点.</li></ol></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092350092.png" alt="image-20210923092350092" style="zoom:50%;" /><p>递归</p><blockquote><p>递归遍历也是和上面的差不多，先走左子树，当左子树没有孩子结点时，将此结点的值放入数组中，然后回溯遍历双亲结点的右结点，递归遍历。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组<br>var postOrderRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        postOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树<br>        postOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树<br>        postListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中<br>    &#125;<br>&#125;<br>postOrderRec(tree);<br>console.log(postListRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><p>非递归</p><blockquote><p>这里使用了一个tmp变量来记录上一次出栈、入栈的结点。思路是先把根结点和左树推入栈，然后取出左树，再推入右树，取出，最后取根结点</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListUnRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组<br>var postOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈<br>        var tmp = null; <span class="hljs-regexp">//</span>定义缓存变量<br>        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历<br>            tmp = stack[stack.length - <span class="hljs-number">1</span>]; <span class="hljs-regexp">//</span>将栈顶的值保存在tmp中<br>            <span class="hljs-keyword">if</span> (tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果存在左子树<br>                stack.push(tmp.left); <span class="hljs-regexp">//</span>将左子树结点压入栈<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp.right &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果结点存在右子树<br>                stack.push(tmp.right); <span class="hljs-regexp">//</span>将右子树压入栈中<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                postListUnRec.push(stack.pop().value);<br>                node = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>postOrderUnRec(tree);<br>console.log(postListUnRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><p>▉广度遍历</p><blockquote><p>广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。<br>实现原理：使用数组模拟队列，首先将根结点归入队列。当队列不为空时，执行循环：取出队列的一个结点，如果该节点有左子树，则将该节点的左子树存入队列；如果该节点有右子树，则将该节点的右子树存入队列。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var breadthList = []; <span class="hljs-regexp">//</span>定义保存广度遍历结果的数组<br>var breadthTraversal = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var que = [node]; <span class="hljs-regexp">//</span>将二叉树放入队列<br>        <span class="hljs-keyword">while</span> (que.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>判断队列是否为空<br>            node = que.shift(); <span class="hljs-regexp">//</span>从队列中取出一个结点<br>            breadthList.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值保存到数组<br>            <span class="hljs-keyword">if</span> (node.left) que.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树放入队列<br>            <span class="hljs-keyword">if</span> (node.right) que.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树放入队列<br>        &#125;<br>    &#125;<br>&#125;<br>breadthTraversal(tree);<br>console.log(breadthList);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><blockquote><p>第一步：先考虑用递归的方式解决问题，注意递归的终止条件。有的递归需要用到回溯法和全局变量</p><p>第二步：如果递归无法解决问题，考虑迭代法，具体的迭代方式参考层序遍历和非递归遍历</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，用的是一般为后序，例如单纯求深度就用前序，二叉树找所有路径也用了前序，这是为了方便让父节点指向子节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MOGu面经</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/13/MOGU/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/13/MOGU/</id>
    <published>2021-09-13T00:08:08.868Z</published>
    <updated>2021-09-23T03:02:43.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MOGU面经收集"><a href="#MOGU面经收集" class="headerlink" title="MOGU面经收集"></a>MOGU面经收集</h1><p>2019-08-14</p><blockquote><ol><li>说一些 ES6 你擅长的东西（说了let、const、proxy、promise，面：说有深度的，我：。。。）</li><li>b === b + 1?如何实现</li><li>JS 可以实现多线程吗？</li><li>setTimeout 和 promise 谁先执行的题</li><li>点一个链接直接实现点赞功能，原理？</li><li>短连接变成长连接使用了哪些知识点。</li><li>节流防抖实现</li><li>首屏加载问题</li><li>性能优化</li><li>项目</li></ol></blockquote><p> 2019-08-30 </p><blockquote><p>vue<br>1.对整个vue的了解程度<br>2.vue生命周期<br>3.如何用函数的方式调用组件</p><p>css<br>4.em和rem区别</p><p>js<br>5.let const var 区别<br>6.const一个对象，它的值可以变吗，为什么<br>优化<br>7.图片很多怎么减少http请求<br>8.跨域的方式<br>9 .印象深刻的项目经验</p></blockquote><p>2019-08-19(一面)</p><blockquote><p>自我介绍</p><p>实习做的事，遇到了哪些困难，做了什么优化</p><p>画一个三角形</p><p>排序算法（手写快排）</p><p>js继承（手写两个）</p><p>new的过程</p><p>虚拟dom（解决了什么困难）</p><p>ajax过程</p><p>apply 、 call 、bind异同</p><p>闭包</p><p>深浅拷贝</p><p>瀑布流实现</p><p>重排重绘</p><p>使用vue中遇到哪些问题</p><p>为什么Object.defineProperty监听不到数组长度等变化</p><p>输入url到页面展示过程</p></blockquote><p> 2019-08-13 </p><blockquote><p>1.自我介绍<br>2.讲一下项目做了些什么（原型用的什么工具）<br>3.项目工程化思维<br>4.标准盒模型，ie盒模型<br>5.水平垂直居中<br>6.响应式<br>7.rem<br>8.ui框架改变样式不影响其他人<br>9.子代选择器和后代选择器的权重<br>10.实现一个动画<br>11.重排重绘<br>12.怎么让动画更加流畅<br>13.前端搜索，不同条件下可能有相同的结果（结果会很多，1000条数据），你怎么去优化（缓存？？分页？？）<br>14.浏览器的存储<br>15.图片预加载和懒加载<br>16.防抖节流（口述节流算法）<br>17.闭包，内存泄漏（怎么解决内存泄漏）<br>18.永久绑定作用域，构建一个公共函数，但是不传对象参数，怎么绑定（？？）<br>19.让a === a + e(常量) 可以实现吗<br>20.js线程<br>21.setTimeout是一个线程吗<br>21.事件委托<br>22.实现长url转换为一个短的url<br>23.302（可以实现刚才的url转换吗）<br>24.vue生命周期<br>25.vue兄弟组件通信<br>26.diff算法<br>27.template渲染过程<br>28.jsonp<br>29.场景题：你老板的手机，看你们开发的微信小程序，遇到了白屏的情况，问你怎么排查问题（问题可能不会复现，你怎么保证添加数据去复现这个场景）<br>30.场景题：直播行业发达，怎么给每个人的发送的消息加一个唯一的标识，相当于id的样子，如何实现<br>31.平时除了做项目还会做些什么<br>(体会就是项目上最好就是讲项目难点，为什么会出现，怎么一步步去解决的<br>项目上做了什么功能，你怎么实现的，你怎么去做项目的)</p></blockquote><p>2017-08-31 </p><blockquote><p>​    一面（2017.08.17，50min） </p><p> 头天晚上投了简历，第二天HR就打电话约面试了，效率很高。 </p><ol><li><p> 自我介绍 </p></li><li><p> 对<a href="">前端</a>这个行业怎么看，为什么要做<a href="">前端</a>？ </p></li><li><p> 对自己未来的规划？ </p></li><li><p> 说一下你理解的<a href="">前端</a>开发流程？ </p></li><li><p> 如何理解 <a href="">JavaScript</a> 闭包？ </p></li><li><p> 如何理解 <a href="">JavaScript</a> this 关键字？ </p></li><li><p> <a href="">JavaScript</a> 基本数据类型？ </p></li><li><p> Undifined 和 Null 的区别？ </p></li><li><p> 了解的 <a href="">JavaScript</a> 数组方法？ </p></li><li><p> CSS单位 rem 和 em 的区别？ </p></li><li><p> 了解的原生 <a href="">JavaScript</a> 方法？ </p></li><li><p> CSS 选择器优先级？ </p></li><li><p> 如何理解 HTML 语义化？ </p></li><li><p> 如何取消一个事件监听？ </p></li><li><p> ‘==’ 和 ‘===’ 的区别？ </p></li><li><p> 如何选择<a href="">前端</a>框架？ </p></li><li><p> 你的优点和缺点是什么？ </p></li><li><p> 当你在一个团队的时候，你的憧憬是什么？ </p></li><li><p>还有什么想问我的？ </p><p>基础问了一点，问了很多关于<a href="">职业规划</a>的问题。中规中矩。</p></li></ol><p>作者：梦游计<br>链接：<a href="https://www.nowcoder.com/discuss/33673?type=2&amp;order=3&amp;pos=22&amp;page=1">https://www.nowcoder.com/discuss/33673?type=2&amp;order=3&amp;pos=22&amp;page=1</a><br>来源：牛客网</p><h3 id="二面（2017-8-21，30min）"><a href="#二面（2017-8-21，30min）" class="headerlink" title="二面（2017.8.21，30min）"></a>二面（2017.8.21，30min）</h3><ol><li> 聊<a href="">项目</a> </li><li> 从什么时候接触<a href="">前端</a>的？ </li><li> 你专业方向是J2EE，当时为什么不选择J2EE？ </li><li> <a href="">JavaScript</a> 和其他语言的面向对象的区别？ </li><li> 继续聊<a href="">项目</a> </li><li> 兼职实习在做什么？ </li><li> 上一次面试官问的什么问题，哪些答的好，哪些答的不好，之后有查过嘛？ </li><li> 还有什么要问我的？</li></ol></blockquote><p>面试准备</p><blockquote><p>1.const<br>2.let var 之间的区别<br>4、es6中的const解释解释<br>9.em和rem区别<br>3.js部分，const，let和 var 的区别。<br>4.js部分，数组遍历map和forEach的区别。</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">能用forEach<span class="hljs-comment">()</span>做到的，map<span class="hljs-comment">()</span>同样可以。反过来也是如此。<br>map<span class="hljs-comment">()</span>会分配内存空间存储新数组并返回，forEach<span class="hljs-comment">()</span>不会返回数据。<br>forEach<span class="hljs-comment">()</span>允许callback更改原始数组的元素。map<span class="hljs-comment">()</span>返回新的数组。<br></code></pre></div></td></tr></table></figure><p>5.css部分，em和rem怎么做自适应。<br>8.函数提升和变量提升优先级</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">函数提升 优于变量<br>解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第<span class="hljs-number">40</span>页提到函数声明是优于变量提升的。可见代码<br><span class="hljs-built_in">console</span>.log(getName)<br><span class="hljs-keyword">var</span> getName = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-comment">// 输出为函数getName</span><br>注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了)<br></code></pre></div></td></tr></table></figure><p>JS深拷贝的用处，哪里会用到？</p><blockquote><p>浅拷贝<br>深拷贝</p></blockquote><p>7、闭包以及带来问题<br>闭包知道吗？它可能出现的问题呢<br>10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）<br>11、flex实现水平垂直居中<br>12、align-items:center是不是只针对垂直<br>css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟<br>CSS布局技巧<br>跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？<br>6.跨域问题<br>6.常用的跨域方式。<br>项目有没跨域问题<br>5.作用域链<br><a href="https://juejin.im/post/58ed9c0ea0bb9f006a4c28cd">JavaScript深入之作用域链</a><br><a href="https://juejin.im/post/5c8290455188257e5d0ec64f">深入理解JavaScript作用域和作用域链</a></p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">作用域链，是由当前环境与上层环境的一系列变量对象组成，<br>它保证了当前执行环境对符合访问权限的变量和函数的有序访问。<br><br>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，<br>就会从父级<span class="hljs-comment">(词法层面上的父级)</span>执行上下文的变量对象中查找，一直找到<br>全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对<br>象构成的链表就叫做作用域链。<br></code></pre></div></td></tr></table></figure><p>第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。<br>然后继续回答原型链。</p><p>2、Promise了解多少</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span> 是异步编程的一种解决方案：<br>从语法上讲，promise是一个对象，从它可以获取异步操作的消息；<br>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。<br>promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；<br>状态一旦改变，就不会再变。创造promise实例后，它会立即执行。<br><br>pending，异步任务正在进行。<br>resolved (也可以叫fulfilled)，异步任务执行成功。<br>rejected，异步任务执行失败。<br><br>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise可以支持多个并发的请求，获取并发请求中的数据<br>这个promise可以解决异步的问题，本身不能说promise是异步的<br><br><span class="hljs-built_in">Promise</span>.resolve(value)<br>类方法，该方法返回一个以 value 值解析后的 <span class="hljs-built_in">Promise</span> 对象<br><span class="hljs-number">1</span>、如果这个值是个 thenable（即带有 then 方法），返回的 <span class="hljs-built_in">Promise</span> <br>对象会“跟随”这个 thenable 的对象，采用它的最终状态<br>（指 resolved/rejected/pending/settled）<br><span class="hljs-number">2</span>、如果传入的 value 本身就是 <span class="hljs-built_in">Promise</span> 对象，<br>  则该对象作为 <span class="hljs-built_in">Promise</span>.resolve 方法的返回值返回。<br><span class="hljs-number">3</span>、其他情况以该值为成功状态返回一个 <span class="hljs-built_in">Promise</span> 对象。<br><br><span class="hljs-built_in">Promise</span>.all的用法：谁跑的慢，以谁为准执行回调。<br>  all接收一个数组参数，里面的值最终都算返回<span class="hljs-built_in">Promise</span>对象<br>  all方法可以说是<span class="hljs-built_in">Promise</span>中很常用的方法了，它的作用就是将一个数组的<span class="hljs-built_in">Promise</span>对象放在其中，当全部resolve的时候就会执行then方法，当有一个reject的时候就会执行<span class="hljs-keyword">catch</span>，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。<br><span class="hljs-built_in">Promise</span>.race的用法：谁跑的快，以谁为准执行回调<br>它的作用是将一个<span class="hljs-built_in">Promise</span>数组放入race中，哪个先执行完，race就直接执行完，并从then中取值。<br><span class="hljs-built_in">Promise</span>.prototype.catch<br>  实例方法，捕获异常，函数形式：<span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params">err</span>)</span>&#123;&#125;, err 是 <span class="hljs-keyword">catch</span> 注册 之前的回调抛出的异常信息。<br><span class="hljs-built_in">Promise</span>.prototype.then<br>  实例方法，为 <span class="hljs-built_in">Promise</span> 注册回调函数，函数形式：<span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params">vlaue</span>)</span>&#123;&#125;，value 是上一个任务的返回结果，then 中的函数一定要 <span class="hljs-keyword">return</span> 一个结果或者一个新的 <span class="hljs-built_in">Promise</span> 对象，才可以让之后的then 回调接收。<br><span class="hljs-built_in">Promise</span>.reject<br>类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。<br><br><span class="hljs-built_in">Promise</span>的立即执行性<br><span class="hljs-built_in">Promise</span> 三种状态<br><span class="hljs-built_in">Promise</span> 状态的不可逆性<br>then方法链式调用<br><br><span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span><br></code></pre></div></td></tr></table></figure><p>promise有了解吗<br>Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。）</p><p>3.React 生命周期，如果要合并 props 和 state 在哪进行<br>4.React 组件想用函数调用的方式使用，怎么设计<br>react如果更新了父组件，子组件没有更新，会都重新渲染吗？<br>react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道<br>react相关的redux的原理？<br>7.你印象比较深的项目或者代码<br>我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render<br>挂载组件到指定节点，然后通过更新 props 使用<br>html css js擅长哪部分？<br>我回答擅长js，但他居然没有继续问下去了</p><p>3、es5和es6了解多少<br>es5,es6哪个用的多点？<br>3、es5和es6了解多少</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">变量声明：<span class="hljs-keyword">let</span> <span class="hljs-keyword">const</span><br>字符串模板<br>解构赋值 对象对对象 数组对数组<br>扩展运算符<br>箭头函数<br>  不需要 <span class="hljs-keyword">function</span> 关键字来创建函数<br>  省略 <span class="hljs-keyword">return</span> 关键字<br>  继承当前上下文的 <span class="hljs-built_in">this</span> 关键字<br><span class="hljs-keyword">import</span>导入模块、<span class="hljs-keyword">export</span>导出模块<br><span class="hljs-built_in">Promise</span><br>数组常用方法：<br><span class="hljs-built_in">Array</span>.isArray<br><span class="hljs-keyword">map</span><br>filter<br>forEach<br>every<br>reduce<br>splice<br>indexOf<br>slice<br>concat<br>reverse()<br>join()<br><br><span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>()<br><span class="hljs-built_in">Array</span>.<span class="hljs-keyword">of</span>()<br>copyWitch<br>find<br>findIndex<br>keys()<br>values()<br><span class="hljs-class"><span class="hljs-keyword">class</span> 静态、私有、共有</span><br><br>生成器（ generator）是能返回一个迭代器的函数。<br>生成器函数也是一种函数，最直观的表现就是比普通的<span class="hljs-keyword">function</span>多了个星号*，<br>在其函数体内可以使用<span class="hljs-keyword">yield</span>关键字,有意思的是函数会在每个<span class="hljs-keyword">yield</span>后暂停。<br><br>可以暂停并重新开始执行的函数<br><br>generators 可以扮演三种角色<br>  迭代器(数据生产者)<br>  观察者(数据消费者)<br>  协作程序(数据生产者和消费者)<br></code></pre></div></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000012358863">es6 Generators详解</a></p><p>2.CSS sprite(雪碧图或者精灵图)<br><a href="https://www.cnblogs.com/evenyao/p/9262371.html">CSS Sprite “精灵图”</a><br><a href="https://blog.csdn.net/CamilleZJ/article/details/80406645">CSS Sprite雪碧图</a></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">用CSS的<span class="hljs-string">&quot;background-image&quot;</span>，<span class="hljs-string">&quot;background-repeat&quot;</span>，<span class="hljs-string">&quot;background-position&quot;</span><br>的组合进行背景定位，<span class="hljs-built_in">background</span>-<span class="hljs-built_in">position</span>可以用数字精确的定位出背景图片的位置。<br>CSS Sprites 的优点：<br>减少图片字节<br>减少网页HTTP请求，提高网页性能<br>减少命名难的问题<br>缺点<br>图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景<br>在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂<br>维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。<br></code></pre></div></td></tr></table></figure><p>事件节流？刚看过，没印象了，哭。<br>情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖</p><p>vue和react差别，<br>8、问了vue有没有做过项目，然后就没有了<br>1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。<br>2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。<br>问了一个异步加载组件，不用标签引入的方法。<br>让你实现vue你怎么实现……<br>说说vue的双向绑定（顺带把响应式说了）<br>说说Vue的diff过程</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">如果不了解virtual dom，要理解<span class="hljs-built_in">diff</span>的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。<br><br>我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。<br><span class="hljs-built_in">diff</span>的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。<br><br>在采取<span class="hljs-built_in">diff</span>算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。<br><span class="hljs-built_in">diff</span>流程图<br>当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，<br>订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。<br><br>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点<br>判断两节点是否值得比较，值得比较则执行patchVnode<br>不值得比较则用Vnode替换oldVnode<br>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。<br><br>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法<br>这个函数做了以下事情：<br>  找到对应的真实dom，称为el<br>  判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接<span class="hljs-built_in">return</span><br>  如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。<br>  如果oldVnode有子节点而Vnode没有，则删除el的子节点<br>  如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el<br>  如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要<br>updateChildren<br>先说一下这个函数做了什么<br>  将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来<br>  oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的<span class="hljs-number">2</span>个变量相互比较，一共有<span class="hljs-number">4</span>种比较方式。如果<span class="hljs-number">4</span>种比较都没匹配，如果设置了<span class="hljs-built_in">key</span>，就会用<span class="hljs-built_in">key</span>进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。<br></code></pre></div></td></tr></table></figure><p>v-model，v-bind 和v-click</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">v-bind  动态地绑定一个或多个特性、或一个组件 prop 到表达式。<br><span class="hljs-number">1</span>:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，<br>在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=<span class="hljs-string">&quot;表达式&quot;</span><br><br>v-model 在表单控件或者组件上创建双向绑定。<br>v-<span class="hljs-keyword">on</span> 指令用于监听DOM事件 形式如：v-<span class="hljs-keyword">on</span>:click  缩写为 <span class="hljs-meta">@click</span>;<br><br><br>[VUE中的v-<span class="hljs-keyword">if</span>与v-<span class="hljs-keyword">show</span>](http:<span class="hljs-comment">//www.cnblogs.com/wmhuang/p/5420344.html)</span><br>手段：v-<span class="hljs-keyword">if</span>是动态的向DOM树内添加或者删除DOM元素；<br>v-<span class="hljs-keyword">show</span>是通过设置DOM元素的display样式属性控制显隐；<br>编译过程<br>：v-<span class="hljs-keyword">if</span>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<br>v-<span class="hljs-keyword">show</span>只是简单的基于css切换；<br>编译条件：<br>v-<span class="hljs-keyword">if</span>是惰性的，如果初始条件为假，则什么也不做；<br>只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)<br>v-<span class="hljs-keyword">if</span>是动态的向DOM树内添加或者删除DOM元素；<br>v-<span class="hljs-keyword">show</span>是通过设置DOM元素的display样式属性控制显隐；<br>v-<span class="hljs-keyword">show</span>是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；<br>性能消耗：<br>v-<span class="hljs-keyword">if</span>有更高的切换消耗；v-<span class="hljs-keyword">show</span>有更高的初始渲染消耗；<br>使用场景：<br>v-<span class="hljs-keyword">if</span>适合运营条件不大可能改变；v-<span class="hljs-keyword">show</span>适合频繁切换。<br><br><br>v-<span class="hljs-keyword">if</span> 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-<span class="hljs-keyword">if</span> 也是惰性的：<br>如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-<span class="hljs-keyword">show</span> 就简单得多——不管初始条件是什么，<br>元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说， v-<span class="hljs-keyword">if</span> 有更高的切换开销，而 v-<span class="hljs-keyword">show</span> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-<span class="hljs-keyword">show</span> 较好；<br>如果在运行时条件不太可能改变，则使用 v-<span class="hljs-keyword">if</span> 较好。<br></code></pre></div></td></tr></table></figure><p>function a(){}，a的<strong>proto</strong> 指向哪，Function呢？Object呢？<br>js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。</p><p>1.就我这次面试表现而言，有哪方面需要提升或者欠缺的<br>3.团队技术栈？<br>然后项目……照着你简历上的问，<br>技术选型，遇到的困难，解决思路，</p><p>面试中印象最深的问题<br>场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。<br>然后开始面试，很少技术问题<br>项目难点，如何解决的<br>有没有想过进入一个团队实习之后会有哪些压力大的事情？<br>有没有了解前端的新技术<br>有没有参加线下前端活动<br>会去看哪些博客或者社区<br>CSS动画和JS动画。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"> (<span class="hljs-number">1</span>)浏览器可以对动画进行优化。<br>  <span class="hljs-number">1</span>、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:<span class="hljs-number">1</span>)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒<span class="hljs-number">60</span>帧。<span class="hljs-number">2</span>)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。<br>  <span class="hljs-number">2</span>、强制使用硬件加速 （通过 GPU 来提高动画性能）<br>  (<span class="hljs-number">2</span>)代码相对简单,性能调优方向固定<br>  (<span class="hljs-number">3</span>)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码<br>缺点：<br>　　<span class="hljs-number">1</span>、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告<br> 　  <span class="hljs-number">2</span>、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。<br><br>JavaScript<br>  (<span class="hljs-number">1</span>)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。<br>  (<span class="hljs-number">2</span>)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成<br>  (<span class="hljs-number">3</span>)CSS3有兼容性问题，而JS大多时候没有兼容性问题<br>缺点：<br>　　　(<span class="hljs-number">1</span>)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。<br>  (<span class="hljs-number">2</span>)代码的复杂度高于CSS动画<br></code></pre></div></td></tr></table></figure><p>后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下<br>webpack的打包目录为啥是这样的，知道原理吗？<br>大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊<br>7.项目印象深刻的部分和难点。<br>二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况<br>自我介绍<br>项目介绍<br>你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？<br>一个骰子，5个面，你怎么实现它（一个面你怎么布局）<br>说说事件循环<br>假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）<br>1、自我介绍 + 项目介绍（难点）<br>5、事件委托<br>6、任务队列<br>9、一个场景题（关于使用调试工具的）<br>13、bootstrap中的栅格式<br>一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了</p><p>重绘&amp;&amp;回流<br>vue differ<br>vue 生命周期<br>跨域<br>自我介绍</p><p>JavaScript 怎么实现 OOP<br>原型继承与类继承的区别<br>闭包的应用场景<br>关系完整性约束</p><p>Cookie &amp; Session 的区别<br>Session 的实现原理<br>HTTP 请求方法中哪些是幂等性的<br>跨域处理方案<br>JSONP 的缺点以及安全隐患<br>为什么要做单元测试<br>黑盒测试与白盒测试的区别<br>怎样实现测试覆盖率<br>Async &amp; Await 的使用</p><p>块级元素、行内元素、inline-block 的区别<br>水平居中的方法<br>String、Array 常用的方法<br>输入一个 URL 到呈现页面的过程<br>Vue.js 组件的生命周期<br>Git 怎么合并提交记录<br>Linux 常用的命令<br>HTTP2 新特性</p><p>常见的 Web 攻击手段以及防范措施<br>对 Ajax 的理解<br>对闭包的理解<br>对事件机制的理解<br>对 HTTP 的理解<br>GET &amp; POST 的区别<br>HTTP2 和 HTTP1 有什么不同<br>对 JavaScript 各大框架的理解<br>对 jQuery 的理解<br>页面性能优化<br>计算机网络分层<br>输入 <a href="http://www.qq.com/">www.qq.com</a> 到呈现页面的过程<br>事件机制（W3C 标准）<br>事件代理<br>XSS、CSRF 的防范<br>token 的实现原理<br>熟练使用JS实现Json、XML格式的数据发送与数据解析；<br>3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器；</p><p>自我介绍<br>事件流<br>vue nextTick原理<br>vue react区别<br>web优化<br>移动端的优化有特别了解过吗<br>css flex了解过吗<br>如何前端监控错误，<br>koa有学过吗<br>事件循环说一说<br>web新技术了解过哪些，最近有去学习哪些东西<br>PWA你能详细说说吗<br>service worker<br>h5 worker<br>非受控组件 与受控组件<br>const let var区别<br>三道题<br>有自己写过webpack插件吗<br>webpack loader 和plugin区别<br>实现promise<br>大数相加<br>纯js写一个动画，5s由快到慢，速度自定义<br>（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）<br>自我介绍，说一下怎么学习前端的，以及做的项目的亮点<br>web优化<br>缓存（协商，强制说一说）<br>CDN</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">CDN的全称是<span class="hljs-attribute">Content</span> Delivery Network，即内容分发网络。<br>其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，<br>使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联<br>网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、<br>负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近<br>的服务节点上。<br><br>其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，<br>提高用户访问网站的响应速度。<br>降低核心系统负载 加速用户访问<br>CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源<br></code></pre></div></td></tr></table></figure><p>DNS如何查询域名的<br>node中间件原理<br>跨域<br>作用域<br>一个页面白屏，分析原因<br>数据结构链表<br>怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）<br>cookie了解吗<br>cookie的属性，怎么存储<br>web安全，xss csrf<br>css响应式布局<br>token生成过程<br>前端新技术<br>PWA讲一讲<br>serviceworker<br>h5 worker<br>智商题<br>3.45分夹角<br>两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离<br>10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来</p><p>三面<br>自我介绍<br>web优化<br>css动画<br>csrf如何防御<br>如何生成token<br>Vue的diff能详细说一说吗<br>Vue子组件你的子组件方法是放在哪里的<br>Vue自定义指令<br>微信小程序接触过吗<br>微信小程序原理<br>TCP三次握手第三次失败了 客户端和服务端是如何处理的<br>301，302状态码区别，以及什么时候会返回这些状态。<br>node如何升级到webSoket<br>如何添加header头<br>DNS迭代和递归区别<br>前端怎么设置cookie过期<br>有看过源码吗<br>看过哪些书<br>能来实习的时间<br>智商题<br>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的<br>算法 最大的回文字符<br>北森<br>一面<br>面试官非常nice，善于引导<br>自我介绍<br>你的项目<br>能说下vue如何收集依赖双向绑定的吗<br>能说下vue如何更新节点的吗<br>node如何打印时间与错误<br>webpack构建流程<br>webpack如何找到依赖关系的<br>webpack如何配置<br>vue和react区别<br>react生命周期<br>函数式组件，如何给状态（hook）<br>原型链，原型知道多少<br>es6了解哪些<br>promise.resolve()<br>http状态码<br>post请求之前先发送Option条件<br>get,post,put,delete区别（冥等）<br>二面<br>面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的<br>vue,react，你更倾向于哪一个，为什么<br>es6模块cmd amd 区别<br>跨域<br>深拷贝，浅拷贝<br>post发送Option的条件<br>输入URL到浏览器会发生什么<br>TCP为什么三次握手<br>TCP为什么四次挥手<br>HTTP为什么基于TCP协议<br>vue diff过程<br>vue如果同一个数据，很短的时间内连续更新 会怎么样。<br>算法题<br>[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]</p><p>三面<br>面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以<br>有这样一个数组，你如何扁平化<br>如果用字符串形式会出现什么问题<br>跨域你如何处理的<br>能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。<br>你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）<br>能具体一点说说吗，说一点就可以<br>你觉得你相比其他实习生的优点和缺点在哪里</p><p>前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。<br>了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MOGU面经收集&quot;&gt;&lt;a href=&quot;#MOGU面经收集&quot; class=&quot;headerlink&quot; title=&quot;MOGU面经收集&quot;&gt;&lt;/a&gt;MOGU面经收集&lt;/h1&gt;&lt;p&gt;2019-08-14&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;说一些 ES6 你</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/%E9%97%AD%E5%8C%85/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/%E9%97%AD%E5%8C%85/</id>
    <published>2021-09-10T09:22:15.192Z</published>
    <updated>2021-09-24T07:54:47.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于初学者来说，闭包似乎有一点神秘，当了解过js的执行期上下文之后，或许就会豁然开朗，在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。</p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><blockquote><p>在javascript中，Javascript有着特殊的变量作用域，–全局变量和局部变量</p><ul><li><p>就在于函数内部可以直接读取全局变量</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">  　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br>  <br>  　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  　　　　alert(n);</span></span><br><span class="hljs-function"><span class="hljs-comment">  　　&#125;</span></span><br><span class="hljs-function">  </span><br><span class="hljs-function">  　　<span class="hljs-title">f1</span><span class="hljs-params">()</span>;</span> <span class="hljs-comment">// 999</span><br></code></pre></div></td></tr></table></figure></li></ul><ul><li><p>在函数外部自然无法读取函数内的局部变量</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">  　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<br>  　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>; <span class="hljs-comment">// 使用var--如果不用的话，你实际上声明了一个全局变量！</span><br>  　　&#125;<br>  <br>  　　alert(n); <span class="hljs-comment">// error</span><br></code></pre></div></td></tr></table></figure></li></ul></blockquote><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote><ul><li><p>[[scope]] : 每个JavaScript函数都是一个对象。对象中有些属性我们可以访问，但有些不可以，这些属性仅提供JavaScript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合</p></li><li><p>作用域链 ： [[scope]]中存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链</p></li><li><p>运行期上下文 ： 当函数执行的前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>第一次执行 test()   -&gt; AO{} // AO用完就不用了</p><p>第二次执行 test()   -&gt; AO{} // 另外的AO</p><p>……</p></li><li><p>查找变量 ：在哪个函数里面查找变量，就从哪个函数的作用域链的顶端依次向下查找函数类对象，</p></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> bb = <span class="hljs-number">234</span>;<br>        aa = <span class="hljs-number">0</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> aa = <span class="hljs-number">123</span>;<br>    b();<br>    <span class="hljs-built_in">console</span>.log(aa)<br>&#125;<br><br><span class="hljs-keyword">var</span> glob = <span class="hljs-number">100</span>;<br>a();<br></code></pre></div></td></tr></table></figure><p>0是最顶端，1次之，查找顺序是从顶端往下</p><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210924094318982.png" alt="image-20210924094318982"><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210924094335484.png" alt="image-20210924094335484"></p><p>理解过程：bb的AO是拿到aa的AO，就是同一个AO，bb只是引用了aa的AO，GO也是同一个，<code>function b()&#123;&#125;</code>执行完，干掉的是b自己的AO(销毁执行期上下文)(去掉连接线)，下一次<code>function b</code>执行时，产生全新的b的AO，b执行完只销毁自己的AO，不会销毁a的AO，<code>function a()&#123;&#125;</code>执行完，会把a自己的AO销毁【会把<code>function b</code>也销毁】，只剩GO(回归到a被定义的时候)，等下一次function a再被执行时，会产生一个全新的AO。。。周而复始</p></blockquote><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210924152003108.png" alt="image-20210924152003108"></p><h3 id="执行期上下文"><a href="#执行期上下文" class="headerlink" title="执行期上下文"></a>执行期上下文</h3><blockquote><p>每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><p>js执行三部曲：1 语法分析 2 预编译 3 解释执行  </p><p>JavaScript 中有三种执行上下文类型</p><ul><li><p><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p></li><li><p><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，<code>不过是在函数被调用时创建的</code>。函数上下文可以有任意多个。每当一个新的执行上下文被创建。</p></li><li><p><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>。</p><p>在javascript中，使用后进先出数据结构的执行栈来存储代码运行时创建的所有执行上下文，也就是在其它编程语言中所说的“调用栈”，当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p></li></ul></blockquote><h3 id="闭包的产生"><a href="#闭包的产生" class="headerlink" title="闭包的产生"></a>闭包的产生</h3><blockquote><p>当内部函数被保存到外部时，将会生成闭包，闭包导致原有作用域链不释放，造成内存泄漏</p><p><code>--内存泄漏就是内存占用，内存被占用的越多，内存就变得越少，就像内存被泄漏了一样</code></p><p>出于种种原因，我们有时候需要得到函数内的局部变量，正常情况下，这是办不到的，只有通过变通方法才能实现。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br><br>　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　alert(n);<br>　　　　&#125;<br><br>　　　　<span class="hljs-keyword">return</span> f2;<br><br>　　&#125;<br><br>　　<span class="hljs-keyword">var</span> result=f1();<br><br>　　result(); <span class="hljs-comment">// 999</span><br></code></pre></div></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>上一节代码中的f2函数，就是闭包。直观来讲，闭包就是能够读取其他函数内部变量的函数。</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p><p><code>但凡是内部的函数被保存到外部，一定生成闭包</code></p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote><ul><li>实现公有变量</li><li>可以做缓存</li><li>可以实现封装，属性私有化</li><li>模块化开发，防止污染全局变量</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于初</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue源码解读🍺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-09-10T00:08:08.868Z</published>
    <updated>2021-09-25T04:45:18.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue源码解读"><a href="#vue源码解读" class="headerlink" title="vue源码解读"></a>vue源码解读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在深入学习vue，打算对源码做一些了解</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">├── benchmarks                  性能、基准测试<br>├── dist                        构建打包的输出目录<br>├── examples                    案例目录<br>├── flow                        flow 语法的类型声明<br>├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的<br>│   ├── vue-server-renderer<br>│   ├── vue-template-compiler<br>│   ├── weex-template-compiler<br>│   └── weex-vue-framework<br>├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件<br>├── src                         vue 源码目录<br>│   ├── compiler                编译器<br>│   ├── core                    运行时的核心包<br>│   │   ├── components          全局组件，比如 keep-alive<br>│   │   ├── config.js           一些默认配置项<br>│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等<br>│   │   ├──<span class="hljs-built_in"> instance </span>           Vue 实例相关的，比如 Vue 构造函数就在这个目录下<br>│   │   ├── observer            响应式原理<br>│   │   ├── util                工具方法<br>│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿<br>│   ├── platforms               平台相关的编译器代码<br>│   │   ├── web<br>│   │   └── weex<br>│   ├──<span class="hljs-built_in"> server </span>                 服务端渲染相关<br>├── test                        测试目录<br>├── types                       TS 类型声明<br><br></code></pre></div></td></tr></table></figure><h3 id="源码学习方法"><a href="#源码学习方法" class="headerlink" title="源码学习方法"></a>源码学习方法</h3><h3 id="flow-类型检测"><a href="#flow-类型检测" class="headerlink" title="flow 类型检测"></a>flow 类型检测</h3><blockquote><p>​    Flow就是JavaScript的静态类型检查工具，由Facebook团队于2014年的Scale Conference上首次提出。该库的目标在于检查JavaScript中的类型错误，开发者通常不需要修改代码即可使用，故使用成本很低。同时，它也提供额外语法支持，使得开发者能更大程度地发挥Flow的作用。总结一句话：将javascript从弱类型语言变成了强类型语言。</p><p>Flow支持原始数据类型，其中void对应js中的undefined</p><p>基本内型  boolean / number/  string  /null  /void</p><p>引用内型   Object / Array  /Function  /自定义Class</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue源码解读&quot;&gt;&lt;a href=&quot;#vue源码解读&quot; class=&quot;headerlink&quot; title=&quot;vue源码解读&quot;&gt;&lt;/a&gt;vue源码解读&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>html面试题🦗</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/26/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/26/html%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-08-26T08:26:03.787Z</published>
    <updated>2021-09-24T08:22:35.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html面试题"><a href="#html面试题" class="headerlink" title="html面试题"></a>html面试题</h1><h2 id="html知识点总结"><a href="#html知识点总结" class="headerlink" title="html知识点总结"></a>html知识点总结</h2><p>平时遇到的面试题的一些总结</p><ol><li><p>对WEB标准以及W3C的理解与认识？</p></li><li><p>Doctype作用，HTML5 为什么只需要写 <!DOCTYPE HTML></p></li><li><p> 行内元素有哪些，块级元素有哪些，空(void)元素有那些</p></li><li><p>简述一下你对HTML语义化的理解</p></li><li><p>HTML5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p></li><li><p>描述一下 cookie，sessionStorage 和 localStorage 的区别</p></li><li><p>如何实现浏览器内多个标签页之间的通信</p></li><li><p>HTML5的离线存储怎么使用，解释一下工作原理</p></li><li><p>src与href的区别</p></li><li><p>表单提交中Get和Post方式的区别</p></li><li><p>iframe有那些缺点？</p></li><li><p>语义化的理解</p></li><li><p>…</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;html面试题&quot;&gt;&lt;a href=&quot;#html面试题&quot; class=&quot;headerlink&quot; title=&quot;html面试题&quot;&gt;&lt;/a&gt;html面试题&lt;/h1&gt;&lt;h2 id=&quot;html知识点总结&quot;&gt;&lt;a href=&quot;#html知识点总结&quot; class=&quot;header</summary>
      
    
    
    
    <category term="面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="-面试" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器地址栏输入url到显示页面的步骤 🕸️</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/13/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/13/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</id>
    <published>2021-08-13T06:19:51.820Z</published>
    <updated>2021-09-13T01:47:07.378Z</updated>
    
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2021-08-12T03:38:59.577Z</published>
    <updated>2021-09-23T07:15:06.590Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目二：二维数组的查找"><a href="#题目二：二维数组的查找" class="headerlink" title="题目二：二维数组的查找"></a>题目二：二维数组的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>Example:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><br><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><br><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span><br></code></pre></div></td></tr></table></figure><p><strong>Solve:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 性能分析：</span><br><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><br><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<br>    <span class="hljs-comment">//定义哨兵结点</span><br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);<br>    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span><br>    <span class="hljs-comment">//存储计算后的链表</span><br>    <span class="hljs-keyword">let</span> sumNode = head;<br>    <span class="hljs-comment">//定义进位变量</span><br>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span><br>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span><br>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;<br>            num1 = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            num1 = l1.val;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;<br>            num2 = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            num2 = l2.val;<br>        &#125;<br>        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span><br>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span><br>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span><br>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;<br>        <span class="hljs-comment">//判断是否需要存储进位值 1</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;<br>           carray = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            carray = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span><br>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)<br>        <span class="hljs-comment">//将指针指向下一链表结点</span><br>        current = current.next;<br>        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span><br>            l1 = l1;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>            l2 = l2.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span><br>            l2 = l2;<br>        &#125;<br>        <span class="hljs-comment">// l1 为不为 null 才满足条件</span><br>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span><br>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span><br>    &#125;<br>    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;<br>        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回哨兵结点之后的链表</span><br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<br>    <span class="hljs-comment">//定义哨兵结点</span><br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);<br>    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span><br>    <span class="hljs-comment">//存储计算后的链表</span><br>    <span class="hljs-keyword">let</span> sumNode = head;<br>    <span class="hljs-comment">//定义进位变量</span><br>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span><br>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span><br>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span><br>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;<br>        <span class="hljs-comment">//判断是否需要存储进位值 1</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;<br>           carray = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            carray = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span><br>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)<br>        <span class="hljs-comment">//将指针指向下一链表结点</span><br>        current = current.next;<br>        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span><br>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件<br>        l1 = l1 ? l1.next : l1;<br>        l2 = l2 ? l2.next : l2;<br>    &#125;<br>    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;<br>        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回哨兵结点之后的链表</span><br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span><br>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><br><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span><br>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br><span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span><br>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<br><span class="hljs-comment">//依次类推.....</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;题目二：二维数组的查找&quot;&gt;&lt;a href=&quot;#题目二：二维数组的查找&quot; class=&quot;headerlink&quot; title=&quot;题目二：二维数组的查找&quot;&gt;&lt;/a&gt;题目二：二维数组的查找&lt;/h4&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增</summary>
      
    
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
    <category term="剑指offer" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>promise笔记🤓</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/promise/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/12/promise/</id>
    <published>2021-08-12T01:23:27.086Z</published>
    <updated>2021-09-25T04:45:07.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise笔记"><a href="#Promise笔记" class="headerlink" title="Promise笔记"></a>Promise笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Promise</code>本质上是一个对象,js的标准内置对象，官方对他的描述就是：Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p><blockquote><p>  面试时相关问题</p></blockquote><div class="hljs code-wrapper"><pre><code>1、了解 Promise 吗？2、Promise 解决的痛点是什么？3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。4、Promise 如何使用？5、Promise 常用的方法有哪些？它们的作用是什么？6、Promise 在事件循环中的执行过程是怎样的？7、Promise 的业界实现都有哪些？8、能不能手写一个 Promise 的 polyfill。</code></pre></div><blockquote><p>用来解决的问题</p></blockquote><p>众所周知，<code>promise</code>解决了js的回调地狱问题(层层调用，嵌套无底洞)…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Promise笔记&quot;&gt;&lt;a href=&quot;#Promise笔记&quot; class=&quot;headerlink&quot; title=&quot;Promise笔记&quot;&gt;&lt;/a&gt;Promise笔记&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>diff算法⛏️</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/diff%E7%AE%97%E6%B3%95/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/diff%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-11T06:58:41.630Z</published>
    <updated>2021-09-24T07:57:33.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;diff算法&quot;&gt;&lt;a href=&quot;#diff算法&quot; class=&quot;headerlink&quot; title=&quot;diff算法&quot;&gt;&lt;/a&gt;diff算法&lt;/h1&gt;</summary>
      
    
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/vue/"/>
    
    
    <category term="vue" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定💻</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/11/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</id>
    <published>2021-08-11T00:08:08.868Z</published>
    <updated>2021-09-15T09:57:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a>vue双向绑定</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vue的双向绑定&amp;响应式原理是框架的</p><p> ▉ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue双向绑定&quot;&gt;&lt;a href=&quot;#vue双向绑定&quot; class=&quot;headerlink&quot; title=&quot;vue双向绑定&quot;&gt;&lt;/a&gt;vue双向绑定&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数组去重💪</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2021-08-06T09:22:57.144Z</published>
    <updated>2021-09-24T07:57:13.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中的10种，面试官很有可能对你刮目相看。<br>在真实的项目中碰到的数组去重，一般都是后台去处理，很少让前端处理数组去重。虽然日常项目用到的概率比较低，但还是需要了解一下，以防面试的时候可能回被问到。</p><p>注：写的匆忙，加上这几天有点忙，还没有非常认真核对过，不过思路是没有问题，可能一些小细节出错而已。</p><h2 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h2><h2 id="一、利用ES6-Set去重（ES6中最常用）"><a href="#一、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="一、利用ES6 Set去重（ES6中最常用）"></a>一、利用ES6 Set去重（ES6中最常用）</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span> (arr) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Set</span>(arr))<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>console.log(<span class="hljs-keyword">unique</span>(arr))<br> //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;&#125;, &#123;&#125;]<br></code></pre></div></td></tr></table></figure><p>不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。</p><h2 id="二、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#二、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="二、利用for嵌套for，然后splice去重（ES5中最常用）"></a>二、利用for嵌套for，然后splice去重（ES5中最常用）</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr)&#123;            <br>        <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>; i&lt;arr.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(var j=i+<span class="hljs-number">1</span>; j&lt;arr.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(arr[i]==arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个<br>                    arr.splice(j,<span class="hljs-number">1</span>);<br>                    j<span class="hljs-comment">--;</span><br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-keyword">return</span> arr;<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>    console.log(<span class="hljs-keyword">unique</span>(arr))<br>    //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //<span class="hljs-keyword">NaN</span>和&#123;&#125;没有去重，两个<span class="hljs-keyword">null</span>直接消失了<br></code></pre></div></td></tr></table></figure><p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。<br>想快速学习更多常用的ES6语法，可以看我之前的文章<a href="https://segmentfault.com/a/1190000016068235">《学习ES6笔记──工作中常用到的ES6语法》</a>。</p><h2 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    var <span class="hljs-keyword">array</span> = [];<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span> .indexOf(arr[i]) === <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">array</span> .push(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>console.log(<span class="hljs-keyword">unique</span>(arr))<br>   // [<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //<span class="hljs-keyword">NaN</span>、&#123;&#125;没有去重<br></code></pre></div></td></tr></table></figure><p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p><h2 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    arr = arr.sort()<br>    var arrry= [arr[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] !== arr[i<span class="hljs-number">-1</span>]) &#123;<br>            arrry.push(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arrry;<br>&#125;<br>     var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>// [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>, &quot;NaN&quot;, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, &quot;true&quot;, undefined]      //<span class="hljs-keyword">NaN</span>、&#123;&#125;没有去重<br></code></pre></div></td></tr></table></figure><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p><h2 id="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"><a href="#五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）" class="headerlink" title="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"></a>五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    var arrry= [];<br>     var  obj = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!obj[arr[i]]) &#123;<br>            arrry.push(arr[i])<br>            obj[arr[i]] = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj[arr[i]]++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arrry;<br>&#125;<br>    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;]    //两个<span class="hljs-keyword">true</span>直接去掉了，<span class="hljs-keyword">NaN</span>和&#123;&#125;去重<br></code></pre></div></td></tr></table></figure><h2 id="六、利用includes"><a href="#六、利用includes" class="headerlink" title="六、利用includes"></a>六、利用includes</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    var <span class="hljs-keyword">array</span> =[];<br>    <span class="hljs-keyword">for</span>(var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>( !<span class="hljs-keyword">array</span>.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值<br>                    <span class="hljs-keyword">array</span>.push(arr[i]);<br>              &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span><br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>    console.log(<span class="hljs-keyword">unique</span>(arr))<br>    //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重<br></code></pre></div></td></tr></table></figure><h2 id="七、利用hasOwnProperty"><a href="#七、利用hasOwnProperty" class="headerlink" title="七、利用hasOwnProperty"></a>七、利用hasOwnProperty</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    var obj = &#123;&#125;;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">function</span>(item, <span class="hljs-keyword">index</span>, arr)&#123;<br>        <span class="hljs-keyword">return</span> obj.hasOwnProperty(typeof item + item) ? <span class="hljs-keyword">false</span> : (obj[typeof item + item] = <span class="hljs-keyword">true</span>)<br>    &#125;)<br>&#125;<br>    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了<br></code></pre></div></td></tr></table></figure><p>利用hasOwnProperty 判断是否存在对象属性</p><h2 id="八、利用filter"><a href="#八、利用filter" class="headerlink" title="八、利用filter"></a>八、利用filter</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">function</span>(item, <span class="hljs-keyword">index</span>, arr) &#123;<br>    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素<br>    <span class="hljs-keyword">return</span> arr.indexOf(item, <span class="hljs-number">0</span>) === <span class="hljs-keyword">index</span>;<br>  &#125;);<br>&#125;<br>    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]<br></code></pre></div></td></tr></table></figure><h2 id="九、利用递归去重"><a href="#九、利用递归去重" class="headerlink" title="九、利用递归去重"></a>九、利用递归去重</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>        var <span class="hljs-keyword">array</span>= arr;<br>        var len = <span class="hljs-keyword">array</span>.length;<br><br>    <span class="hljs-keyword">array</span>.sort(<span class="hljs-keyword">function</span>(a,b)&#123;   //排序后更加方便去重<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;)<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">loop</span>(<span class="hljs-keyword">index</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> &gt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span>] === <span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span><span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-keyword">array</span>.splice(<span class="hljs-keyword">index</span>,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">loop</span>(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);    //递归<span class="hljs-keyword">loop</span>，然后数组去重<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">loop</span>(len<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;<br>&#125;<br> var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;a&quot;, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>, &#123;…&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, undefined]<br></code></pre></div></td></tr></table></figure><h2 id="十、利用Map数据结构去重"><a href="#十、利用Map数据结构去重" class="headerlink" title="十、利用Map数据结构去重"></a>十、利用Map数据结构去重</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> arrayNonRepeatfy(arr) &#123;<br>  let map = <span class="hljs-built_in">new</span> Map();<br>  let <span class="hljs-keyword">array</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Array</span>();  // 数组用于返回结果<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span>(map .has(arr[i])) &#123;  // 如果有该key值<br>      map .<span class="hljs-keyword">set</span>(arr[i], <span class="hljs-keyword">true</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>      map .<span class="hljs-keyword">set</span>(arr[i], <span class="hljs-keyword">false</span>);   // 如果没有该key值<br>      <span class="hljs-keyword">array</span> .push(arr[i]);<br>    &#125;<br>  &#125; <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span> ;<br>&#125;<br> var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>    console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;a&quot;, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>, &#123;…&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, undefined]<br></code></pre></div></td></tr></table></figure><p>创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</p><h2 id="十一、利用reduce-includes"><a href="#十一、利用reduce-includes" class="headerlink" title="十一、利用reduce+includes"></a>十一、利用reduce+includes</h2><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">function unique(arr)&#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-params">(prev,cur)</span> =&gt;</span> prev.includes(cur) ? prev : [...prev,cur],[]);<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br><span class="hljs-built_in">console</span>.log(unique(arr));<br><span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">15</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-string">&quot;NaN&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;a&quot;</span>, &#123;…&#125;, &#123;…&#125;]<br></code></pre></div></td></tr></table></figure><h2 id="十二、-…new-Set-arr"><a href="#十二、-…new-Set-arr" class="headerlink" title="十二、[…new Set(arr)]"></a>十二、[…new Set(arr)]</h2><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">[.<span class="hljs-built_in">..new</span> <span class="hljs-keyword">Set</span>(arr)] <br><span class="hljs-comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组去重&quot;&gt;&lt;a href=&quot;#数组去重&quot; class=&quot;headerlink&quot; title=&quot;数组去重&quot;&gt;&lt;/a&gt;数组去重&lt;/h1&gt;&lt;p&gt;数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>模块化✊</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-08-06T09:19:49.341Z</published>
    <updated>2021-09-24T07:55:45.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化🔓"><a href="#模块化🔓" class="headerlink" title="模块化🔓"></a>模块化🔓</h1><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。参见阮一峰老师的文章 <a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/module-loader">module-loader</a> 。</p><h2 id="一、CommonJS"><a href="#一、CommonJS" class="headerlink" title="一、CommonJS"></a>一、CommonJS</h2><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义模块math.js</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123; <span class="hljs-comment">//在这里写上需要向外暴露的函数、变量</span><br>  add: add,<br>  basicNum: basicNum<br>&#125;<br><br><span class="hljs-comment">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="hljs-keyword">var</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math&#x27;</span>);<br>math.add(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 引用核心模块时，不需要带路径</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br>http.createService(...).listen(<span class="hljs-number">3000</span>);<br>复制代码<br></code></pre></div></td></tr></table></figure><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><h2 id="二、AMD和require-js"><a href="#二、AMD和require-js" class="headerlink" title="二、AMD和require.js"></a>二、AMD和require.js</h2><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">/** 网页中引入<span class="hljs-keyword">require</span>.js及main.js **<span class="hljs-regexp">/</span><br><span class="hljs-regexp">&lt;script src=&quot;js/require</span>.js<span class="hljs-string">&quot; data-main=&quot;</span>js/main<span class="hljs-string">&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">/** main.js 入口文件/主模块 **/</span><br><span class="hljs-string">// 首先用config()指定各模块路径和引用名</span><br><span class="hljs-string">require.config(&#123;</span><br><span class="hljs-string">  baseUrl: &quot;</span>js/<span class="hljs-class"><span class="hljs-keyword">lib</span>&quot;,</span><br>  <span class="hljs-symbol">paths:</span> &#123;<br>    <span class="hljs-string">&quot;jquery&quot;</span>: <span class="hljs-string">&quot;jquery.min&quot;</span>,  <span class="hljs-regexp">//</span>实际路径为js/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">jquery</span>.<span class="hljs-title">min</span>.<span class="hljs-title">js</span></span><br>    <span class="hljs-string">&quot;underscore&quot;</span>: <span class="hljs-string">&quot;underscore.min&quot;</span>,<br>  &#125;<br>&#125;);<br>/<span class="hljs-regexp">/ 执行基本操作</span><br><span class="hljs-regexp">require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;</span><br><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ some code here</span><br><span class="hljs-regexp">&#125;);</span><br><span class="hljs-regexp">复制代码</span><br></code></pre></div></td></tr></table></figure><p>引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 定义math.js模块</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        add: add,<br>        basicNum :basicNum<br>    &#125;;<br>&#125;);<br><span class="hljs-comment">// 定义一个依赖underscore.js的模块</span><br>define([<span class="hljs-string">&#x27;underscore&#x27;</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> classify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">list</span></span>)</span>&#123;<br>    _.countBy(<span class="hljs-keyword">list</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">30</span> ? <span class="hljs-string">&#x27;old&#x27;</span> : <span class="hljs-string">&#x27;young&#x27;</span>;<br>    &#125;)<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>    classify :classify<br>  &#125;;<br>&#125;)<br><br><span class="hljs-comment">// 引用模块，将模块放在[]内</span><br><span class="hljs-keyword">require</span>([<span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-string">&#x27;math&#x27;</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$, math</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> sum = math.add(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>  $(<span class="hljs-string">&quot;#sum&quot;</span>).html(sum);<br>&#125;);<br>复制代码<br></code></pre></div></td></tr></table></figure><h2 id="三、CMD和sea-js"><a href="#三、CMD和sea-js" class="headerlink" title="三、CMD和sea.js"></a>三、CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">define([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c, d, e, f)</span> </span>&#123; <br>    <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>      b.foo()<br>    &#125; <br>&#125;);<br>复制代码<br></code></pre></div></td></tr></table></figure><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/** AMD写法 **/</span><br>define([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e, f</span>) </span>&#123; <br>     <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span><br>    a.doSomething();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>        b.doSomething()<br>    &#125; <br>&#125;);<br><br><span class="hljs-comment">/** CMD写法 **/</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>); <span class="hljs-comment">//在需要时申明</span><br>    a.doSomething();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>);<br>        b.doSomething();<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">/** sea.js **/</span><br><span class="hljs-comment">// 定义模块 math.js</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery.js&#x27;</span>);<br>    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <span class="hljs-built_in">exports</span>.add = add;<br>&#125;);<br><span class="hljs-comment">// 加载模块</span><br>seajs.use([<span class="hljs-string">&#x27;math.js&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sum = math.add(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>);<br>&#125;);<br>复制代码<br></code></pre></div></td></tr></table></figure><h2 id="四、ES6-Module"><a href="#四、ES6-Module" class="headerlink" title="四、ES6 Module"></a>四、ES6 Module</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">/** 定义模块 math.js **/</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br>export &#123; basicNum, add &#125;;<br><br><span class="hljs-comment">/** 引用模块 **/</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> &#123; basicNum, add &#125; from &#x27;./math&#x27;;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">(ele)</span> </span>&#123;<br>    ele.textContent = add(<span class="hljs-number">99</span> + basicNum);<br>&#125;<br>复制代码<br></code></pre></div></td></tr></table></figure><p>如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了<code>export default</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于ADM的引用写法。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/** export default **/</span><br><span class="hljs-comment">//定义输出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; basicNum, add &#125;;<br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">ele</span>) </span>&#123;<br>    ele.textContent = math.add(<span class="hljs-number">99</span> + math.basicNum);<br>&#125;<br>复制代码<br></code></pre></div></td></tr></table></figure><p>ES6的模块不是对象，<code>import</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h2 id="五、-ES6-模块与-CommonJS-模块的差异"><a href="#五、-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="五、 ES6 模块与 CommonJS 模块的差异"></a>五、 ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>原文作者：subwaydown<br>原文链接：<a href="https://juejin.cn/post/6844903576309858318">https://juejin.cn/post/6844903576309858318</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化🔓&quot;&gt;&lt;a href=&quot;#模块化🔓&quot; class=&quot;headerlink&quot; title=&quot;模块化🔓&quot;&gt;&lt;/a&gt;模块化🔓&lt;/h1&gt;&lt;p&gt;模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>BFC🚓</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/BFC/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/BFC/</id>
    <published>2021-08-06T07:25:51.805Z</published>
    <updated>2021-08-11T05:59:40.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p><code>常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</code></p><ul><li>普通流 (normal flow)</li></ul><blockquote><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></blockquote><ul><li>浮动 (float)</li></ul><blockquote><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></blockquote><ul><li>绝对定位 (absolute positioning)</li></ul><blockquote><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p></blockquote><p><strong>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong></p><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p><p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h4 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h4><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h4 id="BFC-特性及应用"><a href="#BFC-特性及应用" class="headerlink" title="BFC 特性及应用"></a>BFC 特性及应用</h4><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>div&#123;<br>    width: 100px;<br>    height: 100px;<br>    background: lightblue;<br>    margin: 100px;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>.container &#123;<br>    overflow: hidden;<br>&#125;<br>p &#123;<br>    width: 100px;<br>    height: 100px;<br>    background: lightblue;<br>    margin: 100px;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这时候，两个盒子边距就变成了 200px</p><p><img src="https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_720w.png" alt="img"></p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>效果如图：</p><p><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, <br>也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h1&gt;&lt;p&gt;&lt;code&gt;常见的定位方案，定位方案是控制元素的布局，有三种常见方案:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通流 (norma</summary>
      
    
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/css/"/>
    
    
    <category term="css" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>数组常用api🎇</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/</id>
    <published>2021-08-06T06:34:50.663Z</published>
    <updated>2021-09-24T07:57:02.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组常用api✊"><a href="#数组常用api✊" class="headerlink" title="数组常用api✊"></a>数组常用api✊</h1><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组:"></a>创建一个数组:</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> 字面量方式:<br>    <span class="hljs-regexp">//</span> 这个方法也是我们最常用的，在初始化数组的时候 相当方便<br>    var a = [<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>];  <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>];<br>    <span class="hljs-regexp">//</span> 构造器:<br>    <span class="hljs-regexp">//</span> 实际上 new Array === Array,加不加new 一点影响都没有。<br>    var a = Array(); <span class="hljs-regexp">//</span> [] <br>    var a = Array(<span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> [,,] <br>    var a = Array(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> [ <span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span> ]<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="ES6-Array-of-返回由所有参数值组成的数组"><a href="#ES6-Array-of-返回由所有参数值组成的数组" class="headerlink" title="ES6 Array.of()  返回由所有参数值组成的数组"></a>ES6 Array.of()  返回由所有参数值组成的数组</h4><p>定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。</p><p>目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-keyword">let</span> a = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// [3,11,8]</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3]</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="ES6-Arrary-from-将两类对象转为真正的数组"><a href="#ES6-Arrary-from-将两类对象转为真正的数组" class="headerlink" title="ES6 Arrary.from() 将两类对象转为真正的数组"></a>ES6 Arrary.from() 将两类对象转为真正的数组</h4><p>定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。</p><p>参数：</p><p>第一个参数(必需):要转化为真正数组的对象。</p><p>第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。</p><p>第三个参数(可选): 用来绑定this。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 对象拥有length属性<br>    let obj = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>, length: <span class="hljs-number">3</span>&#125;;<br>    let arr = Array.from(obj); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象<br>    let arr = Array.from(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]<br>    let arr = Array.from(new Set([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>])); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><hr><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h3><p>数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。</p><h4 id="改变原数组的方法-9个"><a href="#改变原数组的方法-9个" class="headerlink" title="改变原数组的方法(9个):"></a>改变原数组的方法(9个):</h4><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">    let a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    ES5:<br>     a.splice()<span class="hljs-regexp">/ a.sort() /</span> a.<span class="hljs-keyword">pop</span>()<span class="hljs-regexp">/ a.shift()/</span>  a.<span class="hljs-keyword">push</span>()<span class="hljs-regexp">/ a.unshift()/</span> a.<span class="hljs-keyword">reverse</span>()<br>    ES6:<br>    a.copyWithin() / a.fill<br>复制代码<br></code></pre></div></td></tr></table></figure><p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。</p><h4 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h4><p>定义： splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p><p>语法： <code>array.splice(index,howmany,item1,.....,itemX)</code></p><p>参数:</p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX： 可选。向数组添加的新项目。</li></ol><p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p><p>eg1:删除元素</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,</span> <span class="hljs-number">3</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从数组下标0开始，删除3个元素</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(-1,</span> <span class="hljs-number">3</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> [<span class="hljs-number">7</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>eg2: 删除并添加</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">     <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,3,&#x27;添加&#x27;);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;添加&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span><br>     <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">b.splice(-2,3,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">console.log(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>eg3: 不删除只添加:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [] <span class="hljs-string">没有删除元素，返回空数组</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">b.splice(-1,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [] <span class="hljs-string">没有删除元素，返回空数组</span><br>    <span class="hljs-string">console.log(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>,<span class="hljs-number">7</span>] <span class="hljs-string">在最后一个元素的前面添加两个元素</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>从上述三个栗子可以得出:</p><ol><li>数组如果元素不够，会删除到最后一个元素为止</li><li>操作的元素，包括开始的那个元素</li><li>可以添加很多个元素</li><li>添加是在开始的元素前面添加的</li></ol><h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h4><p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p><p>参数可选: 规定排序顺序的比较函数。</p><p>默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> 字符串排列 看起来很正常<br>    var a = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>    a.sort(); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Mango&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>]<br>    <span class="hljs-regexp">//</span> 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的<br>    vara = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>];<br>    console.log(a.sort()) <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>];<br>复制代码<br></code></pre></div></td></tr></table></figure><p><strong>比较函数的两个参数：</strong></p><p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p><ul><li>若比较函数返回值&lt;0，那么a将排到b的前面;</li><li>若比较函数返回值=0，那么a 和 b 相对位置不变；</li><li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li></ul><p>对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章<a href="https://juejin.cn/post/6844903507439419399">深入了解javascript的sort方法</a></p><p><strong>sort排序常见用法</strong>：</p><ol><li><p>数组元素为数字的升序、降序:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"> <span class="hljs-string">var</span> <span class="hljs-string">array</span> <span class="hljs-string">=</span>  [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>,<span class="hljs-number">20</span>,<span class="hljs-number">4</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>]<span class="hljs-string">;</span><br> <span class="hljs-string">//</span> <span class="hljs-string">升序</span> <span class="hljs-string">a-b</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0</span>   <span class="hljs-string">a将排到b的前面，按照a的大小来排序的</span> <br> <span class="hljs-string">//</span> <span class="hljs-string">比如被减数a是10，减数是20</span>  <span class="hljs-number">10</span><span class="hljs-number">-20</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0</span>   <span class="hljs-string">被减数a(10)在减数b(20)前面</span>   <br> <span class="hljs-string">array.sort(function(a,b)&#123;</span><br>   <span class="hljs-string">return</span> <span class="hljs-string">a-b;</span><br> <span class="hljs-string">&#125;);</span><br> <span class="hljs-string">console.log(array);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>]<span class="hljs-string">;</span><br> <span class="hljs-string">//</span> <span class="hljs-string">降序</span> <span class="hljs-string">被减数和减数调换了</span>  <span class="hljs-number">20</span><span class="hljs-number">-10</span><span class="hljs-string">&gt;0</span> <span class="hljs-string">被减数b(20)在减数a(10)的前面</span><br> <span class="hljs-string">array.sort(function(a,b)&#123;</span><br>   <span class="hljs-string">return</span> <span class="hljs-string">b-a;</span><br> <span class="hljs-string">&#125;);</span><br> <span class="hljs-string">console.log(array);</span> <span class="hljs-string">//</span> [<span class="hljs-number">25</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<span class="hljs-string">;</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure></li><li><p>数组多条件排序</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"> var <span class="hljs-keyword">array</span> = [<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span>,age:<span class="hljs-number">2</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">5</span>,age:<span class="hljs-number">4</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">6</span>,age:<span class="hljs-number">10</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">9</span>,age:<span class="hljs-number">6</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">2</span>,age:<span class="hljs-number">8</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span>,age:<span class="hljs-number">9</span>&#125;];<br>     <span class="hljs-keyword">array</span><span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span>(a,b)&#123;<br>         <span class="hljs-keyword">if</span>(a<span class="hljs-built_in">.id</span> === b<span class="hljs-built_in">.id</span>)&#123;// 如<span class="hljs-built_in">果id</span>的值相等，按照age的值降序<br>             <span class="hljs-keyword">return</span> b.age - a.age<br>         &#125;<span class="hljs-keyword">else</span>&#123; // 如<span class="hljs-built_in">果id</span>的值不相等，按<span class="hljs-built_in">照id</span>的值升序<br>             <span class="hljs-keyword">return</span> a<span class="hljs-built_in">.id</span> - b<span class="hljs-built_in">.id</span><br>         &#125;<br>     &#125;)<br>  // [&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">6</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">9</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">2</span>&#125;] <br>复制代码<br></code></pre></div></td></tr></table></figure></li><li><p>自定义比较函数，天空才是你的极限</p></li></ol><p>类似的：<strong>运用好返回值，我们可以写出任意符合自己需求的比较函数</strong></p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery">    var <span class="hljs-keyword">array</span> = [<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;];<br>    <span class="hljs-keyword">array</span><span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span>(a,b)&#123;<br>        <span class="hljs-keyword">if</span>(a<span class="hljs-built_in">.name</span> === <span class="hljs-string">&#x27;Koro1&#x27;</span>)&#123;// 如<span class="hljs-built_in">果name</span>是<span class="hljs-string">&#x27;Koro1&#x27;</span> 返回-<span class="hljs-number">1</span> ，-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span> a排在b的前面<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123; // 如果不是的话，a排在b的后面<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>    &#125;)<br>    // [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;] <br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h4><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p><p>参数: 无。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.pop();</span>  <span class="hljs-string">//</span> <span class="hljs-number">3</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h4><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p><p>参数: 无。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.shift();</span>  <span class="hljs-string">//</span> <span class="hljs-number">1</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h4><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p>参数:  item1, item2, …, itemX ,要添加到数组末尾的元素</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.push(&#x27;末尾&#x27;);</span>  <span class="hljs-string">//</span> <span class="hljs-number">4</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;末尾&#x27;</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><p>参数:  item1, item2, …, itemX ,要添加到数组开头的元素</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.unshift(&#x27;开头&#x27;);</span>  <span class="hljs-string">//</span> <span class="hljs-number">4</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;开头&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h4><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p><p>参数: 无</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">a.reverse();</span>  <br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="ES6-copyWithin-指定位置的成员复制到其他位置"><a href="#ES6-copyWithin-指定位置的成员复制到其他位置" class="headerlink" title="ES6: copyWithin() 指定位置的成员复制到其他位置"></a>ES6: copyWithin() 指定位置的成员复制到其他位置</h4><p>定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.copy<span class="hljs-constructor">Within(<span class="hljs-params">target</span>, <span class="hljs-params">start</span> = 0, <span class="hljs-params">end</span> = <span class="hljs-params">this</span>.<span class="hljs-params">length</span>)</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>三个参数都是数值，如果不是，会自动转为数值.</p><ol><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。</li></ol><p>浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持</p><p>eg:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">        <span class="hljs-regexp">//</span> -<span class="hljs-number">2</span>相当于<span class="hljs-number">3</span>号位，-<span class="hljs-number">1</span>相当于<span class="hljs-number">4</span>号位<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)<br>        <span class="hljs-regexp">//</span> [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>        var a=[<span class="hljs-string">&#x27;OB1&#x27;</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-string">&#x27;OB2&#x27;</span>,<span class="hljs-string">&#x27;Koro2&#x27;</span>,<span class="hljs-string">&#x27;OB3&#x27;</span>,<span class="hljs-string">&#x27;Koro3&#x27;</span>,<span class="hljs-string">&#x27;OB4&#x27;</span>,<span class="hljs-string">&#x27;Koro4&#x27;</span>,<span class="hljs-string">&#x27;OB5&#x27;</span>,<span class="hljs-string">&#x27;Koro5&#x27;</span>]<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>位置开始被替换,<span class="hljs-number">3</span>位置开始读取要替换的 <span class="hljs-number">5</span>位置前面停止替换<br>        a.copyWithin(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>        <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;OB1&quot;</span>,<span class="hljs-string">&quot;Koro1&quot;</span>,<span class="hljs-string">&quot;Koro2&quot;</span>,<span class="hljs-string">&quot;OB3&quot;</span>,<span class="hljs-string">&quot;OB3&quot;</span>,<span class="hljs-string">&quot;Koro3&quot;</span>,<span class="hljs-string">&quot;OB4&quot;</span>,<span class="hljs-string">&quot;Koro4&quot;</span>,<span class="hljs-string">&quot;OB5&quot;</span>,<span class="hljs-string">&quot;Koro5&quot;</span>] <br>复制代码<br></code></pre></div></td></tr></table></figure><p>从上述栗子:</p><ol><li>第一个参数是开始被替换的元素位置</li><li>要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取</li><li>数组的长度不会改变</li><li><strong>读了几个元素就从开始被替换的地方替换几个元素</strong></li></ol><h4 id="ES6-fill-填充数组"><a href="#ES6-fill-填充数组" class="headerlink" title="ES6: fill() 填充数组"></a>ES6: fill() 填充数组</h4><p>定义:  使用给定值，填充一个数组。</p><p>参数:</p><p>第一个元素(必须): 要填充数组的值</p><p>第二个元素(可选): 填充的开始位置,默认值为0</p><p>第三个元素(可选)：填充的结束位置，默认是为<code>this.length</code></p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill%23%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">MDN浏览器兼容</a></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].fill(<span class="hljs-number">7</span>)<br>    <span class="hljs-regexp">//</span> [<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]<br>    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].fill(<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><hr><h3 id="不改变原数组的方法-8个"><a href="#不改变原数组的方法-8个" class="headerlink" title="不改变原数组的方法(8个):"></a>不改变原数组的方法(8个):</h3><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">    ES5：<br>    slice、<span class="hljs-keyword">join</span>、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、<br>    ES7：<br>    <span class="hljs-keyword">includes</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h4><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p><p><strong>注意</strong>：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。</p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">    <span class="hljs-keyword">array</span>.<span class="hljs-keyword">slice</span>(<span class="hljs-keyword">begin</span>, <span class="hljs-keyword">end</span>);<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。</p><p>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</p><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">    let a= [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];<br>    let b=a.slice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); // [<span class="hljs-string">&#x27;hello&#x27;</span>]<br>    a[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;改变原数组&#x27;</span>;<br>    console.log(a,b); // [<span class="hljs-string">&#x27;改变原数组&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>] [<span class="hljs-string">&#x27;hello&#x27;</span>]<br>    b[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;改变拷贝的数组&#x27;</span>;<br>     console.log(a,b); // [<span class="hljs-string">&#x27;改变原数组&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>] [<span class="hljs-string">&#x27;改变拷贝的数组&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><p>如上：新数组是浅拷贝的，<strong>元素是简单数据类型，改变之后不会互相干扰</strong>。</p><p>如果是<strong>复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变</strong>。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a= [&#123;name:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;];<br>    let b=a.slice();<br>    console.log(b,a); <span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OBKoro1&quot;</span>&#125;]  [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OBKoro1&quot;</span>&#125;]<br>    <span class="hljs-regexp">//</span> a[<span class="hljs-number">0</span>].name=<span class="hljs-string">&#x27;改变原数组&#x27;</span>;<br>    <span class="hljs-regexp">//</span> console.log(b,a); <span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变原数组&quot;</span>&#125;] [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变原数组&quot;</span>&#125;]<br>    <span class="hljs-regexp">//</span> b[<span class="hljs-number">0</span>].name=<span class="hljs-string">&#x27;改变拷贝数组&#x27;</span>,b[<span class="hljs-number">0</span>].koro=<span class="hljs-string">&#x27;改变拷贝数组&#x27;</span>;<br>    <span class="hljs-regexp">//</span>  [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>,<span class="hljs-string">&quot;koro&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>&#125;] [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>,<span class="hljs-string">&quot;koro&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>&#125;]<br>复制代码<br></code></pre></div></td></tr></table></figure><p>原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。</p><h4 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join()  数组转字符串"></a>join()  数组转字符串</h4><p>定义:  join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p><p>语法:</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">    array.<span class="hljs-keyword">join</span>(<span class="hljs-built_in">str</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">let</span> a= [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];<br>    <span class="hljs-keyword">let</span> str=a.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// &#x27;hello,world&#x27;</span><br>    <span class="hljs-keyword">let</span> str2=a.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;+&#x27;</span>); <span class="hljs-comment">// &#x27;hello+world&#x27;</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">let</span> a= [[<span class="hljs-string">&#x27;OBKoro1&#x27;</span>,<span class="hljs-string">&#x27;23&#x27;</span>],<span class="hljs-string">&#x27;test&#x27;</span>];<br>    <span class="hljs-keyword">let</span> str1=a.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// OBKoro1,23,test</span><br>    <span class="hljs-keyword">let</span> b= [&#123;name:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>,age:<span class="hljs-string">&#x27;23&#x27;</span>&#125;,<span class="hljs-string">&#x27;test&#x27;</span>];<br>    <span class="hljs-keyword">let</span> str2 = b.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// [object Object],test</span><br>    <span class="hljs-comment">// 对象转字符串推荐JSON.stringify(obj);</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>所以，<code>join()/toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用<code>join()/toString()</code>,如果是对象的话，对象会被转为<code>[object Object]</code>字符串。</p><h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：无。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">    <span class="hljs-keyword">let</span> a=[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;abcd&#x27;</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()];<br>    <span class="hljs-keyword">let</span> str=a.toLocaleString(); <span class="hljs-comment">// [object Object],23,abcd,2018/5/28 下午1:52:20 </span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>如上述栗子：调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的<code>toLocaleString</code>方法，对象调用对象的<code>toLocaleString</code>,Date调用Date的<code>toLocaleString</code>。</p><h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a>toString() 数组转字符串 不推荐</h4><p>定义: toString() 方法可把数组转换为由逗号链接起来的字符串。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数: 无。</p><p>该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p><p><strong>值得注意的是</strong>：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">   let b= [ <span class="hljs-string">&#x27;toString&#x27;</span>,<span class="hljs-string">&#x27;演示&#x27;</span>].toString(); <span class="hljs-regexp">//</span> toString,演示<br>   let a= [<span class="hljs-string">&#x27;调用toString&#x27;</span>,<span class="hljs-string">&#x27;连接在我后面&#x27;</span>]+<span class="hljs-string">&#x27;啦啦啦&#x27;</span>; <span class="hljs-regexp">//</span> 调用toString,连接在我后面啦啦啦<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="cancat"><a href="#cancat" class="headerlink" title="cancat"></a>cancat</h4><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p><p>语法：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    var newArr =oldArray.concat(<span class="hljs-built_in">array</span>X,<span class="hljs-built_in">array</span>X,......,<span class="hljs-built_in">array</span>X)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：</p><p>arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p><p>eg1:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">//连接两个数组</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">newVal=a.concat(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">连接三个数组</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">c</span> <span class="hljs-string">=</span> [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>    <span class="hljs-string">let</span> <span class="hljs-string">newVal2</span> <span class="hljs-string">=</span> <span class="hljs-string">a.concat(b,</span> <span class="hljs-string">c);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">添加元素</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">newVal3</span> <span class="hljs-string">=</span> <span class="hljs-string">a.concat(&#x27;添加元素&#x27;,b,</span> <span class="hljs-string">c,&#x27;再加一个&#x27;);</span> <br>    <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;添加元素&quot;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&quot;再加一个&quot;</span>]<br>   <span class="hljs-string">//</span> <span class="hljs-string">合并嵌套数组</span>  <span class="hljs-string">会浅拷贝嵌套数组</span><br>   <span class="hljs-string">let</span> <span class="hljs-string">d</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span> ]<span class="hljs-string">;</span><br>   <span class="hljs-string">let</span> <span class="hljs-string">f</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>]]<span class="hljs-string">;</span><br>   <span class="hljs-string">let</span> <span class="hljs-string">newVal4</span> <span class="hljs-string">=</span> <span class="hljs-string">d.concat(f);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>]]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p><strong>ES6扩展运算符<code>...</code>合并数组</strong>：</p><p>因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用<code>...</code>来处理，<code>...</code>运算符可以实现<code>cancat</code>的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [ <span class="hljs-number">4</span>,<span class="hljs-string">...a</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<br>    <span class="hljs-string">console.log(a,b);</span> <span class="hljs-string">//</span>  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>更多关于扩展符的详细内容移步阮一峰大神的<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">ECMAScript 6 入门</a></p><h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.index<span class="hljs-constructor">Of(<span class="hljs-params">searchElement</span>,<span class="hljs-params">fromIndex</span>)</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p><p>严格相等的搜索:</p><p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p><p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p><p>eg:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">    let <span class="hljs-keyword">a</span>=[<span class="hljs-string">&#x27;啦啦&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">24</span>,NaN]<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;啦&#x27;</span>)); <span class="hljs-comment"> // -1 </span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;NaN&#x27;</span>)); <span class="hljs-comment"> // -1 </span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;啦啦&#x27;</span>));<span class="hljs-comment"> // 0</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>使用场景：</p><ol><li><a href="https://juejin.cn/post/6844903577421365255#heading-10">数组去重</a></li><li>根据获取的数组下标执行操作，改变数组中的值等。</li><li>判断是否存在，执行操作。</li></ol><h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><p>定义:  方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    arr.last<span class="hljs-constructor">IndexOf(<span class="hljs-params">searchElement</span>,<span class="hljs-params">fromIndex</span>)</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>searchElement(必须): 被查找的元素</p><p>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</p><p>关于fromIndex有三个规则:</p><ol><li><p>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</p></li><li><p>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</p></li><li><p>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"> let a=[<span class="hljs-string">&#x27;OB&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>]; <span class="hljs-regexp">//</span> 数组长度为<span class="hljs-number">10</span><br> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 从下标<span class="hljs-number">4</span>开始往前找 返回下标<span class="hljs-number">2</span><br> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-regexp">//</span>  大于或数组的长度 查找整个数组 返回<span class="hljs-number">9</span><br> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">11</span>); <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span> 数组不会被查找<br> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">9</span>); <span class="hljs-regexp">//</span> 从第二个元素<span class="hljs-number">4</span>往前查找，没有找到 返回-<span class="hljs-number">1</span><br>复制代码<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h4><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p><p>语法：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-built_in">array</span>.includes(searchElement,fromIndex=<span class="hljs-number">0</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p><p><strong>includes方法是为了弥补indexOf方法的缺陷而出现的:</strong></p><ol><li>indexOf方法不能识别<code>NaN</code></li><li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于<code>-1</code>，表达不够直观</li></ol><p>eg:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a=[<span class="hljs-string">&#x27;OB&#x27;</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">1</span>,NaN];<br>    <span class="hljs-regexp">//</span> let b=a.includes(NaN); <span class="hljs-regexp">//</span> true 识别NaN<br>    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-regexp">//</span> false 超过数组长度 不搜索<br>    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">3</span>);  <span class="hljs-regexp">//</span> true 从倒数第三个元素开始搜索 <br>    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">100</span>);  <span class="hljs-regexp">//</span> true 负值绝对值超过数组长度，搜索整个数组<br>复制代码<br></code></pre></div></td></tr></table></figure><p>兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。</p><hr><h3 id="遍历方法-12个"><a href="#遍历方法-12个" class="headerlink" title="遍历方法(12个):"></a>遍历方法(12个):</h3><p>js中遍历数组并不会改变原始数组的方法总共有12个:</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">    ES5：<br>    forEach、every 、some、 <span class="hljs-built_in">filter</span>、<span class="hljs-keyword">map</span>、reduce、reduceRight、<br>    ES6：<br>    <span class="hljs-keyword">find</span>、findIndex、<span class="hljs-built_in">keys</span>、<span class="hljs-built_in">values</span>、entries<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="关于遍历："><a href="#关于遍历：" class="headerlink" title="关于遍历："></a>关于遍历：</h4><ul><li>关于遍历的效率，可以看一下这篇<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2015/12/18/traverse/%23%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87">详解JS遍历</a></li><li>尽量不要在遍历的时候，修改后面要遍历的值</li><li>尽量不要在遍历的时候修改数组的长度（删除/添加）</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>定义: 按升序为数组中含有效值的每一项执行一次回调函数。</p><p>语法：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">currentValue</span>, <span class="hljs-params">index</span>, <span class="hljs-params">arr</span>)</span>, thisValue)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p><strong>关于forEach()你要知道</strong>：</p><ul><li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 undefined值,即使你return了一个值。</li></ul><h4 id="下面类似语法同样适用这些规则"><a href="#下面类似语法同样适用这些规则" class="headerlink" title="下面类似语法同样适用这些规则"></a>下面类似语法同样适用这些规则</h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-number">1.</span> 对于空数组是不会执行回调函数的<br>    <span class="hljs-number">2.</span> 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数<br>    <span class="hljs-number">3.</span> 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。<br>    <span class="hljs-number">4.</span> 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。<br>复制代码<br></code></pre></div></td></tr></table></figure><p>eg:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ,<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 最后第二个元素是空的，不会遍历(undefined、null会遍历)<br>    let obj = &#123; name: <span class="hljs-string">&#x27;OBKoro1&#x27;</span> &#125;;<br>    let result = a.forEach(<span class="hljs-keyword">function</span> (value, index, array) &#123; <br>      a[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;改变元素&#x27;</span>;<br>      a.push(<span class="hljs-string">&#x27;添加到尾端，不会被遍历&#x27;</span>)<br>      console.log(value, <span class="hljs-string">&#x27;forEach传递的第一个参数&#x27;</span>); <span class="hljs-regexp">//</span> 分别打印 <span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,改变元素<br>      console.log(this.name); <span class="hljs-regexp">//</span> OBKoro1 打印三次 this绑定在obj对象上<br>      <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>会报错<br>      return value; <span class="hljs-regexp">//</span> return只能结束本次回调 会执行下次回调<br>      console.log(<span class="hljs-string">&#x27;不会执行，因为return 会执行下一次循环回调&#x27;</span>)<br>    &#125;, obj);<br>    console.log(result); <span class="hljs-regexp">//</span> 即使return了一个值,也还是返回undefined<br>    <span class="hljs-regexp">//</span> 回调函数也接受接头函数写法<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a>every 检测数组所有元素是否都符合判断条件</h4><p>定义: 方法用于检测数组所有元素是否都符合函数定义的条件</p><p>语法：</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.every(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>, <span class="hljs-title">thisValue</span>)</span><br><span class="hljs-function">复制代码</span><br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>方法返回值规则:</p><ol><li>如果数组中检测到<strong>有一个元素不满足，则整个表达式返回 false</strong>，且剩余的元素不会再进行检测。</li><li>如果所有元素<strong>都满足条件，则返回 true</strong>。=</li></ol><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">function</span> <span class="hljs-string">isBigEnough(element,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123; <br>      <span class="hljs-string">return</span> <span class="hljs-string">element</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">判断数组中的所有元素是否都大于10</span><br>    &#125;<br>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(isBigEnough);</span>   <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">接受箭头函数写法</span> <br>    [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(x</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br>    [<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(x</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a>some 数组中的是否有满足判断条件的元素</h4><p>定义：数组中的是否有满足判断条件的元素</p><p>语法：</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.some(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>, <span class="hljs-title">thisValue</span>)</span><br><span class="hljs-function">复制代码</span><br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>方法返回值规则：</p><ol><li><p>如果<strong>有一个元素满足条件，则表达式返回true</strong>, 剩余的元素不会再执行检测。</p></li><li><p>如果<strong>没有满足条件的元素，则返回false</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"> <span class="hljs-string">function</span> <span class="hljs-string">isBigEnough(element,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;<br>   <span class="hljs-string">return</span> <span class="hljs-string">(element</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//数组中是否有一个元素大于</span> <span class="hljs-number">10</span><br> &#125;<br> <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-string">.some(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br> <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-string">.some(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure></li></ol><h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><p>语法：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">     <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-string">a.filter(function</span> <span class="hljs-string">(value,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;<br>      <span class="hljs-string">return</span> <span class="hljs-string">value</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">18</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">返回a数组中所有大于18的元素</span><br>    &#125;<span class="hljs-string">);</span><br>    <span class="hljs-string">console.log(result,a);//</span> [<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">40</span>] [<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">16</span>,<span class="hljs-number">40</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><p>语法：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>eg:</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>];<br><span class="hljs-keyword">let</span> result = a.<span class="hljs-keyword">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-keyword">value</span>, index, <span class="hljs-keyword">array</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> + <span class="hljs-string">&#x27;新数组的新元素&#x27;</span><br>&#125;);<br>console.log(result, a); <br>// [<span class="hljs-string">&quot;1新数组的新元素&quot;</span>,<span class="hljs-string">&quot;2新数组的新元素&quot;</span>,<span class="hljs-string">&quot;3新数组的新元素&quot;</span>,<span class="hljs-string">&quot;4新数组的新元素&quot;</span>] [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><p>定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。</p><p>语法：</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(total, currentValue, currentIndex, arr)</span>, <span class="hljs-title">initialValue</span>)</span><br><span class="hljs-function">复制代码</span><br></code></pre></div></td></tr></table></figure><p>参数：</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> total(必须)，初始值, 或者上一次调用回调返回的值<br>    <span class="hljs-number">2.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">3.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">4.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>initialValue(可选): 指定第一次回调 的第一个参数。</p><p>回调第一次执行时:</p><ul><li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li><li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li><li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li></ul><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">//</span> <span class="hljs-string">数组求和</span> <br>    <span class="hljs-string">let</span> <span class="hljs-string">sum</span> <span class="hljs-string">=</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.reduce(function</span> <span class="hljs-string">(a,</span> <span class="hljs-string">b)</span> &#123;<br>      <span class="hljs-string">return</span> <span class="hljs-string">a</span> <span class="hljs-string">+</span> <span class="hljs-string">b;</span><br>    &#125;<span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">);</span><br>    <span class="hljs-string">//</span> <span class="hljs-number">6</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">将二维数组转化为一维</span> <span class="hljs-string">将数组元素展开</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">flattened</span> <span class="hljs-string">=</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-string">.reduce(</span><br>      <span class="hljs-string">(a,</span> <span class="hljs-string">b)</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">a.concat(b),</span><br>      []<br>    <span class="hljs-string">);</span><br>     <span class="hljs-string">//</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight  从右至左累加"></a>reduceRight  从右至左累加</h4><p>这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p><h4 id="ES6：find-amp-findIndex-根据条件找到数组成员"><a href="#ES6：find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6：find()&amp; findIndex() 根据条件找到数组成员"></a>ES6：find()&amp; findIndex() 根据条件找到数组成员</h4><p>find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。</p><p>findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><p>这两个方法</p><p>语法：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>     let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.findIndex(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>这两个方法都可以识别<code>NaN</code>,弥补了<code>indexOf</code>的不足.</p><p>eg:</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">        <span class="hljs-comment">// find</span><br>        let a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>].find((n) =&gt; n &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回元素-5</span><br>        let b = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>,NaN].find((n) =&gt; Object.<span class="hljs-keyword">is</span>(NaN, n));  <span class="hljs-comment">// 返回元素NaN</span><br>        <span class="hljs-comment">// findIndex</span><br>        let a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>].findIndex((n) =&gt; n &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回索引2</span><br>        let b = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>,NaN].findIndex((n) =&gt; Object.<span class="hljs-keyword">is</span>(NaN, n));  <span class="hljs-comment">// 返回索引4</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,</p><h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</h4><p>定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p><p>语法：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">    <span class="hljs-built_in">array</span>.keys()<br>    <span class="hljs-built_in">array</span>.<span class="hljs-built_in">values</span>()<br>    <span class="hljs-built_in">array</span>.entries()<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：无。</p><p>遍历栗子(摘自<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values">ECMAScript 6 入门</a>)：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-keyword">for</span> (let index of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].keys()) &#123;<br>      console.log(index);<br>    &#125;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> (let elem of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].values()) &#123;<br>      console.log(elem);<br>    &#125;<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;b&#x27;</span><br>    <br>    <span class="hljs-keyword">for</span> (let [index, elem] of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].entries()) &#123;<br>      console.log(index, elem);<br>    &#125;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span> <span class="hljs-string">&quot;a&quot;</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <span class="hljs-string">&quot;b&quot;</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</p><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的next方法，进行遍历:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let letter = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>    let entries = letter.entries();<br>    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br>    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br>    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><p>entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1</p><p>keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,</p><p><strong>注意</strong>:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组常用api✊&quot;&gt;&lt;a href=&quot;#数组常用api✊&quot; class=&quot;headerlink&quot; title=&quot;数组常用api✊&quot;&gt;&lt;/a&gt;数组常用api✊&lt;/h1&gt;&lt;h3 id=&quot;创建一个数组&quot;&gt;&lt;a href=&quot;#创建一个数组&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>let和const</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/07/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/07/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-07-15T00:08:08.868Z</published>
    <updated>2021-09-13T08:01:50.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章涉及3个知识点，var，let，const</p><h3 id="var-命令"><a href="#var-命令" class="headerlink" title="var 命令"></a>var 命令</h3><blockquote><p>​    JavaScript中，我们通常说的作用域是函数作用域，使用var声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p><p>也就是说，如果在函数内部声明的变量，都会被提升到该函数开头，而在全局声明的变量，就会提升到全局作用域的顶部。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>&#125;<br><br>test()<br></code></pre></div></td></tr></table></figure><blockquote><p>实际执行时，上面的代码中的变量a会提升到函数顶部声明，即使if语句的条件是false，也一样不影响a变量提升。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a<br>    <span class="hljs-comment">//a声明没有赋值</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      a = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">//a声明没有赋值</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>在函数嵌套函数的场景下，变量只会提升到最近的一个函数顶部，而不会提升到外部函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//b提升到函数a顶部，但不会提升到函数test。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>          &#125;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b: &#x27;</span>, b)<br>    &#125;<br>    <br>    test() <span class="hljs-comment">//b is not defined</span><br></code></pre></div></td></tr></table></figure><blockquote><p>如果a没有声明，那么就会报错，<strong>没有声明和声明后没有赋值是不一样的</strong>，这点一定要区分开，有助于我们找bug。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">//a没有声明的情况</span><br>   a <span class="hljs-keyword">is</span> not defined<br></code></pre></div></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p>let和const都能够声明块级作用域，用法和var是类似的，let的特点是不会变量提升，而是被锁在当前块中。</p><p>一个非常简单的例子：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//TDZ，俗称临时死区，用来描述变量不提升的现象</span><br>      <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br>test()  <span class="hljs-comment">// a is not defined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(a)<br>&#125;    <br>test() <span class="hljs-comment">// a is not defined</span><br></code></pre></div></td></tr></table></figure><blockquote><p>唯一正确的使用方法：<strong>先声明，再访问。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;<br>          <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>          <span class="hljs-built_in">console</span>.log(a)<br>        &#125;<br>    &#125;<br>    test() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><blockquote><p>声明常量，一旦声明，不可更改，而且常量必须初始化赋值。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">const<span class="hljs-built_in"> type </span>= <span class="hljs-string">&quot;ACTION&quot;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>我们试试重新声明type，看看会报什么错：</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">const <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;ACTION&quot;</span><br>    <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">type</span>) //<span class="hljs-string">&quot;type&quot;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span><br>    <br>    const <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;ACTION&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">type</span>) //Duplicate declaration <span class="hljs-string">&quot;type&quot;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>​    const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值包括新增删除键值对也是可以的。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">const <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= &#123;<br>      a: <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">type</span>.a = <span class="hljs-number">2</span> <span class="hljs-comment">//没有直接修改type的值，而是修改type.a的属性值，这是允许的。</span><br>    console.log(<span class="hljs-class"><span class="hljs-keyword">type</span>) <span class="hljs-comment">// &#123;a: 2&#125;</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    <span class="hljs-title">type</span>.<span class="hljs-title">b</span> </span>= <span class="hljs-number">3</span> <span class="hljs-comment">//拓展Object也是没有问题的</span><br>    console.log(<span class="hljs-class"><span class="hljs-keyword">type</span>) <span class="hljs-comment">// &#123;a: 2 , b: 3&#125;</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    <span class="hljs-title">delete</span> <span class="hljs-title">type</span>.<span class="hljs-title">b=3</span> <span class="hljs-comment">//删除整个键值对也OK的</span></span><br><span class="hljs-class">    <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-params">type</span>) <span class="hljs-comment">// &#123;a: 2&#125;</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    <span class="hljs-comment">//如果重新定义数据结构~常量的内存地址值发生改变,这个是不可行的。</span></span><br><span class="hljs-class">    <span class="hljs-title">type=</span></span>&#123;&#125;; <span class="hljs-comment">//Assignment to constant variable.</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span></span>=[]; <span class="hljs-comment">//Assignment to constant variable.</span><br></code></pre></div></td></tr></table></figure><h3 id="const和let的异同点"><a href="#const和let的异同点" class="headerlink" title="const和let的异同点"></a>const和let的异同点</h3><blockquote><p><strong>相同点：</strong>const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升，不能重复声明。</p><p><strong>不同点：</strong>const不能再赋值，let声明的变量可以重复赋值。</p></blockquote><h3 id="块级作用域的使用场景"><a href="#块级作用域的使用场景" class="headerlink" title="块级作用域的使用场景"></a>块级作用域的使用场景</h3><blockquote><p>​    除了上面提到的常用声明方式，我们还可以在循环中使用，最出名的一道面试题：循环中定时器闭包的考题</p><p>在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//5, 5, 5, 5, 5</span><br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//5 i跳出循环体污染外部函数</span><br>    <br>    <span class="hljs-comment">//将var改成let之后</span><br>    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 0,1,2,3,4</span><br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">//i is not defined i无法污染外部函数</span><br></code></pre></div></td></tr></table></figure><p><code>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;let和const&quot;&gt;&lt;a href=&quot;#let和const&quot; class=&quot;headerlink&quot; title=&quot;let和const&quot;&gt;&lt;/a&gt;let和const&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>节流防抖🗽</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/05/21/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/05/21/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</id>
    <published>2021-05-21T08:22:45.422Z</published>
    <updated>2021-08-11T06:07:22.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="节流防抖🗽"><a href="#节流防抖🗽" class="headerlink" title="节流防抖🗽"></a>节流防抖🗽</h3><ul><li><p>定义🎉🎉🎉：</p><ul><li><strong>防抖：</strong>在任务高频率触发时，只有触发间隔超过制定间隔的任务才会执行。即一个动作连续触发则只执行最后一次。防抖的原理则是不管你在一段时间内如何不停的触发事件，只要设置了防抖，则只在触发n秒后才执行。如果我们在一个事件触发的n秒内又触发了相同的事件，那我们便以新的事件时间为标准，n秒之后再执行。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code><figure class="highlight js"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = flase;<br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">// 清除未执行的定时器（如果之前已经触发过不到300毫秒又触发了一次则清除之前的）重置回初始化状态</span><br>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;函数防抖&quot;</span>)<br>  &#125;, <span class="hljs-number">300</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure></code></pre><ul><li><p><strong>节流：</strong>在制定间隔内任务只执行1次。节流的原理是不管你在一段时间内如何不停地触发事件，只要设置了节流，就会每隔一段时间执行一次。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>;<br>  canRun = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数节流&#x27;</span>)<br>    canRun = <span class="hljs-literal">true</span><br>  &#125;, <span class="hljs-number">300</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure></li></ul><div class="hljs code-wrapper"><pre><code>&lt;img src=&quot;C:\Users\l&#39;x\AppData\Roaming\Typora\typora-user-images\image-20210521162630790.png&quot; alt=&quot;image-20210521162630790&quot; style=&quot;zoom:50%;&quot; /&gt;</code></pre></div><h3 id="原理📣"><a href="#原理📣" class="headerlink" title="原理📣"></a>原理📣</h3><blockquote><p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p></blockquote><blockquote><p>如： 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p></blockquote><p>  <strong>手写简化版🚔</strong></p>  <figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><br><span class="hljs-comment">// wait是等待时间</span><br><span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 缓存一个定时器id</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 这里返回的函数是每次用户实际调用的防抖函数</span><br>  <span class="hljs-comment">// 如果已经设定过定时器了就清空上一次的定时器</span><br>  <span class="hljs-comment">// 开始一个新的定时器，延迟执行用户传入的方法</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.apply(<span class="hljs-built_in">this</span>, args)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p></blockquote><blockquote><p>例:（连续不断动都需要调用时用，设一时间间隔），像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多</p></blockquote><p>  <strong>手写简版🚔</strong></p>  <figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><br><span class="hljs-comment">// wait是等待时间</span><br><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 上一次执行该函数的时间</span><br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-comment">// 当前时间</span><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    <span class="hljs-comment">// 将当前时间和上一次执行函数时间对比</span><br>    <span class="hljs-comment">// 如果差值大于设置的等待时间就执行函数</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt; wait) &#123;<br>      lastTime = now<br>      func.apply(<span class="hljs-built_in">this</span>, args)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(<br>  throttle(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">500</span>),<br>  <span class="hljs-number">1</span><br>)<br></code></pre></div></td></tr></table></figure><h3 id="函数防抖的应用场景🎟️"><a href="#函数防抖的应用场景🎟️" class="headerlink" title="函数防抖的应用场景🎟️"></a>函数防抖的应用场景🎟️</h3><p>  连续的事件，只需触发一次回调的场景有：</p><ul><li><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求</p></li><li><p>手机号、邮箱验证输入检测</p></li><li><p>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p><h3 id="函数节流的应用场景🎟️"><a href="#函数节流的应用场景🎟️" class="headerlink" title="函数节流的应用场景🎟️"></a>函数节流的应用场景🎟️</h3><p>间隔一段时间执行一次回调的场景有：</p></li><li><p>滚动加载，加载更多或滚到底部监听</p></li><li><p>谷歌搜索框，搜索联想功能</p></li><li><p>高频点击提交，表单重复提交</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;节流防抖🗽&quot;&gt;&lt;a href=&quot;#节流防抖🗽&quot; class=&quot;headerlink&quot; title=&quot;节流防抖🗽&quot;&gt;&lt;/a&gt;节流防抖🗽&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义🎉🎉🎉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;防抖：&lt;/strong&gt;在任</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>get和post请求🍺</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/05/11/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/05/11/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</id>
    <published>2021-05-11T00:08:08.868Z</published>
    <updated>2021-09-25T04:45:25.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>变量声明</p><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><blockquote><p>用法类似var，但是let只在<code>let</code>命令所在的代码块内有效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><br>a <span class="hljs-comment">// ReferenceError: a is not defined.</span><br>b <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><blockquote><p>可用于for内部变量循环，var变量在预编译的时候会发生变量提升，而块级作用域的let只在循环内部有效</p><p><code>每一次循环的</code>i<code>其实都是一个新的变量，所以最后输出的是</code>6<code>。你可能会问，如果每一轮循环的变量</code>i<code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量</code>i<code>时，就在上一轮循环的基础上进行计算。</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;;<br>&#125;<br>a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span><br></code></pre></div></td></tr></table></figure><blockquote><p><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><p><code>函数内部的变量</code>i<code>与循环变量</code>i<code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 </code>let<code> 重复声明同一个变量）。</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br></code></pre></div></td></tr></table></figure><blockquote><p>​    暂时性死区</p><p>​    ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>下面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// TDZ开始</span><br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// ReferenceError</span><br><br>  <span class="hljs-keyword">let</span> tmp; <span class="hljs-comment">// TDZ结束</span><br>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// undefined</span><br><br>  tmp = <span class="hljs-number">123</span>;<br>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// 123</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><blockquote><p>​    <code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p><code>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;let和const&quot;&gt;&lt;a href=&quot;#let和const&quot; class=&quot;headerlink&quot; title=&quot;let和const&quot;&gt;&lt;/a&gt;let和const&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>github使用总结🎟️</title>
    <link href="https://zhouhang-hello.gitee.io/hexo_blog/2021/05/11/evenloop/"/>
    <id>https://zhouhang-hello.gitee.io/hexo_blog/2021/05/11/evenloop/</id>
    <published>2021-05-11T00:08:08.868Z</published>
    <updated>2021-09-24T08:01:54.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Evenloop事件循环"><a href="#Evenloop事件循环" class="headerlink" title="Evenloop事件循环"></a>Evenloop事件循环</h1><p>JavaScript是一个单线程的脚本语言。</p><p>所以就是说在一行代码执行的过程中，必然不会存在同时执行的另一行代码，就像使用<code>alert()</code>以后进行疯狂<code>console.log</code>，如果没有关闭弹框，控制台是不会显示出一条<code>log</code>信息的。</p><p>亦或者有些代码执行了大量计算，比方说在前端暴力破解密码之类的鬼操作，这就会导致后续代码一直在等待，页面处于假死状态，因为前边的代码并没有执行完。</p><p>所以如果全部代码都是同步执行的，这会引发很严重的问题，比方说我们要从远端获取一些数据，难道要一直循环代码去判断是否拿到了返回结果么？</p><p>于是就有了异步事件的概念，注册一个回调函数，比如说发一个网络请求，我们告诉主程序等到接收到数据后通知我，然后我们就可以去做其他的事情了。</p><p>然后在异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁等待，等到程序空闲下来才有时间去看哪些异步已经完成了，可以去执行。<br> <strong>任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中</strong></p><p>而且一个宏任务在执行的过程中，是可以添加一些微任务的<br> <strong>在当前的微任务没有执行完成时，是不会执行下一个宏任务的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p><code>setTimeout</code>就是作为宏任务来存在的，而<code>Promise.then</code>则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。</p><p><code>所有会进入的异步都是指的事件回调中的那部分代码</code></p><p> 也就是说<code>new Promise</code>在实例化的过程中所执行的代码都是同步进行的，而<code>then</code>中注册的回调才是异步执行的。<br> 在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。<br> 所以就得到了上述的输出结论<code>1、2、3、4</code>。</p><p><em>+部分表示同步执行的代码</em></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">+<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>-  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<br>+&#125;)<br><br>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>+  resolve()<br>+  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>+&#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>-  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>+&#125;)<br><br>+<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>本来<code>setTimeout</code>已经先设置了定时器，然后在当前进程中又添加了一些<code>Promise</code>的处理</p><p>所以进阶的，即便我们继续在<code>Promise</code>中实例化<code>Promise</code>，其输出依然会早于<code>setTimeout</code>的宏任务：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before timeout&#x27;</span>)<br>  &#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;also before timeout&#x27;</span>)<br>    &#125;)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>当然了，实际情况下很少会有简单的这么调用<code>Promise</code>的，一般都会在里边有其他的异步操作，比如<code>fetch</code>、<code>fs.readFile</code>之类的操作。<br> 而这些其实就相当于注册了一个宏任务，而非是微任务。</p><p><em>P.S. 在<a href="https://link.juejin.cn/?target=https://promisesaplus.com/%23notes">Promise/A+的规范</a>中，<code>Promise</code>的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少<code>Chrome</code>是这么做的)，<code>Promise</code>应该是属于微任务阵营的</em></p><p>所以，明白哪些操作是宏任务、哪些是微任务就变得很关键，这是目前业界比较流行的说法：</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><table><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td><code>I/O</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setTimeout</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setInterval</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setImmediate</code></td><td>❌</td><td>✅</td></tr><tr><td><code>requestAnimationFrame</code></td><td>✅</td><td>❌</td></tr></tbody></table><p><em>有些地方会列出来<code>UI Rendering</code>，说这个也是宏任务，可是在读了<a href="https://link.juejin.cn/?target=https://html.spec.whatwg.org/multipage/webappapis.html%23event-loop-processing-model">HTML规范文档</a>以后，发现这很显然是和微任务平行的一个操作步骤</em><br> <em><code>requestAnimationFrame</code>姑且也算是宏任务吧，<code>requestAnimationFrame</code>在<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">MDN的定义</a>为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行</em></p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><table><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td><code>process.nextTick</code></td><td>❌</td><td>✅</td></tr><tr><td><code>MutationObserver</code></td><td>✅</td><td>❌</td></tr><tr><td><code>Promise.then catch finally</code></td><td>✅</td><td>✅</td></tr></tbody></table><h2 id="Event-Loop是个啥"><a href="#Event-Loop是个啥" class="headerlink" title="Event-Loop是个啥"></a>Event-Loop是个啥</h2><p>上边一直在讨论 宏任务、微任务，各种任务的执行。<br> 但是回到现实，<code>JavaScript</code>是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。</p><p>每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。*<strong>（检查还有没有微任务需要处理）***<br> 而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。*</strong>（结束本次宏任务、检查还有没有宏任务需要处理）***<br> 这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为<code>Event Loop</code>。*(这是个非常简易的描述了，实际上会复杂很多)*</p><p>而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">const macroTaskList = [<br>  [<span class="hljs-string">&#x27;task1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;task2&#x27;</span>, <span class="hljs-string">&#x27;task3&#x27;</span>],<br>  [<span class="hljs-string">&#x27;task4&#x27;</span>],<br>]<br><br><span class="hljs-keyword">for</span> (let macroIndex = <span class="hljs-number">0</span>; macroIndex &lt; macroTaskList.length; macroIndex++) &#123;<br>  const microTaskList = macroTaskList[macroIndex]<br>  <br>  <span class="hljs-keyword">for</span> (let microIndex = <span class="hljs-number">0</span>; microIndex &lt; microTaskList.length; microIndex++) &#123;<br>    const microTask = microTaskList[microIndex]<br><br>    <span class="hljs-regexp">//</span> 添加一个微任务<br>    <span class="hljs-keyword">if</span> (microIndex === <span class="hljs-number">1</span>) microTaskList.push(<span class="hljs-string">&#x27;special micro task&#x27;</span>)<br>    <br>    <span class="hljs-regexp">//</span> 执行任务<br>    console.log(microTask)<br>  &#125;<br><br>  <span class="hljs-regexp">//</span> 添加一个宏任务<br>  <span class="hljs-keyword">if</span> (macroIndex === <span class="hljs-number">2</span>) macroTaskList.push([<span class="hljs-string">&#x27;special macro task&#x27;</span>])<br>&#125;<br><br><span class="hljs-regexp">//</span> &gt; task1<br><span class="hljs-regexp">//</span> &gt; task2<br><span class="hljs-regexp">//</span> &gt; task3<br><span class="hljs-regexp">//</span> &gt; special micro task<br><span class="hljs-regexp">//</span> &gt; task4<br><span class="hljs-regexp">//</span> &gt; special macro task<br>复制代码<br></code></pre></div></td></tr></table></figure><p><em>之所以使用两个<code>for</code>循环来表示，是因为在循环内部可以很方便的进行<code>push</code>之类的操作（添加一些任务），从而使迭代的次数动态的增加。</em></p><p>以及还要明确的是，<code>Event Loop</code>只是负责告诉你该执行那些任务，或者说哪些回调被触发了，真正的逻辑还是在进程中执行的。</p><h2 id="在浏览器中的表现"><a href="#在浏览器中的表现" class="headerlink" title="在浏览器中的表现"></a>在浏览器中的表现</h2><p>在上边简单的说明了两种任务的差别，以及<code>Event Loop</code>的作用，那么在真实的浏览器中是什么表现呢？<br> 首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）</p><p><code>I/O</code>这一项感觉有点儿笼统，有太多的东西都可以称之为<code>I/O</code>，点击一次<code>button</code>，上传一个文件，与程序产生交互的这些都可以称之为<code>I/O</code>。</p><p>假设有这样的一些<code>DOM</code>结构：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;style&gt;<br>  <span class="hljs-comment">#outer &#123;</span><br>    padding: <span class="hljs-number">20</span>px;<br>    background: <span class="hljs-comment">#616161;</span><br>  &#125;<br><br>  <span class="hljs-comment">#inner &#123;</span><br>    width: <span class="hljs-number">100</span>px;<br>    height: <span class="hljs-number">100</span>px;<br>    background: <span class="hljs-comment">#757575;</span><br>  &#125;<br>&lt;/style&gt;<br>&lt;div id=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>  &lt;div id=<span class="hljs-string">&quot;inner&quot;</span>&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>复制代码<br><span class="hljs-keyword">const</span> $inner = document.querySelector(<span class="hljs-string">&#x27;#inner&#x27;</span>)<br><span class="hljs-keyword">const</span> $outer = document.querySelector(<span class="hljs-string">&#x27;#outer&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span> (<span class="hljs-params"></span>) </span>&#123;<br>  console.log(<span class="hljs-string">&#x27;click&#x27;</span>) <span class="hljs-comment">// 直接输出</span><br><br>  Promise.resolve().then(_ =&gt; console.log(<span class="hljs-string">&#x27;promise&#x27;</span>)) <span class="hljs-comment">// 注册微任务</span><br><br>  setTimeout(_ =&gt; console.log(<span class="hljs-string">&#x27;timeout&#x27;</span>)) <span class="hljs-comment">// 注册宏任务</span><br><br>  requestAnimationFrame(_ =&gt; console.log(<span class="hljs-string">&#x27;animationFrame&#x27;</span>)) <span class="hljs-comment">// 注册宏任务</span><br><br>  $outer.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, Math.random()) <span class="hljs-comment">// DOM属性修改，触发微任务</span><br>&#125;<br><br><span class="hljs-keyword">new</span> MutationObserver(_ =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;observer&#x27;</span>)<br>&#125;).observe($outer, &#123;<br>  attributes: <span class="hljs-literal">true</span><br>&#125;)<br><br>$inner.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br>$outer.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>如果点击<code>#inner</code>，其执行顺序一定是：<code>click</code> -&gt; <code>promise</code> -&gt; <code>observer</code> -&gt; <code>click</code> -&gt; <code>promise</code> -&gt; <code>observer</code> -&gt; <code>animationFrame</code> -&gt; <code>animationFrame</code> -&gt; <code>timeout</code> -&gt; <code>timeout</code>。</p><p>因为一次<code>I/O</code>创建了一个宏任务，也就是说在这次任务中会去触发<code>handler</code>。<br> 按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了<code>Promise</code>和<code>MutationObserver</code>两个微任务，遂执行之。<br> 因为<code>click</code>事件会冒泡，所以对应的这次<code>I/O</code>会触发两次<code>handler</code>函数(<em>一次在<code>inner</code>、一次在<code>outer</code></em>)，所以会优先执行冒泡的事件(<em>早于其他的宏任务</em>)，也就是说会重复上述的逻辑。<br> 在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。<br> 需要注意的一点是，因为我们触发了<code>setAttribute</code>，实际上修改了<code>DOM</code>的属性，这会导致页面的重绘，而这个<code>set</code>的操作是同步执行的，也就是说<code>requestAnimationFrame</code>的回调会早于<code>setTimeout</code>所执行。</p><h3 id="一些小惊喜"><a href="#一些小惊喜" class="headerlink" title="一些小惊喜"></a>一些小惊喜</h3><p>使用上述的示例代码，如果将手动点击<code>DOM</code>元素的触发方式变为<code>$inner.click()</code>，那么会得到不一样的结果。<br> 在<code>Chrome</code>下的输出顺序大致是这样的：<br> <code>click</code> -&gt; <code>click</code> -&gt; <code>promise</code> -&gt; <code>observer</code> -&gt; <code>promise</code> -&gt;  <code>animationFrame</code> -&gt; <code>animationFrame</code> -&gt; <code>timeout</code> -&gt; <code>timeout</code>。</p><p>与我们手动触发<code>click</code>的执行顺序不一样的原因是这样的，因为并不是用户通过点击元素实现的触发事件，而是类似<code>dispatchEvent</code>这样的方式，我个人觉得并不能算是一个有效的<code>I/O</code>，在执行了一次<code>handler</code>回调注册了微任务、注册了宏任务以后，实际上外边的<code>$inner.click()</code>并没有执行完。<br> 所以在微任务执行之前，还要继续冒泡执行下一次事件，也就是说触发了第二次的<code>handler</code>。<br> 所以输出了第二次<code>click</code>，等到这两次<code>handler</code>都执行完毕后才会去检查有没有微任务、有没有宏任务。</p><p>两点需要注意的：</p><ol><li><code>.click()</code>的这种触发事件的方式个人认为是类似<code>dispatchEvent</code>，可以理解为同步执行的代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>))<br><br><span class="hljs-built_in">document</span>.body.click()<br><span class="hljs-built_in">document</span>.body.dispatchEvent(<span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;click&#x27;</span>))<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;done&#x27;</span>)<br><br><span class="hljs-comment">// &gt; click</span><br><span class="hljs-comment">// &gt; click</span><br><span class="hljs-comment">// &gt; done</span><br>复制代码<br></code></pre></div></td></tr></table></figure><ol><li><code>MutationObserver</code>的监听不会说同时触发多次，多次修改只会有一次回调被触发。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observer&#x27;</span>)<br>  <span class="hljs-comment">// 如果在这输出DOM的data-random属性，必然是最后一次的值，不解释了</span><br>&#125;).observe(<span class="hljs-built_in">document</span>.body, &#123;<br>  attributes: <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random())<br><span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random())<br><span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random())<br><br><span class="hljs-comment">// 只会输出一次 ovserver</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p><em>这就像去饭店点餐，服务员喊了三次，XX号的牛肉面，不代表她会给你三碗牛肉面。</em><br> <em>上述观点参阅自<a href="https://link.juejin.cn/?target=https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/%23level-1-bossfight">Tasks, microtasks, queues and schedules</a>，文中有动画版的讲解</em></p><h2 id="在Node中的表现"><a href="#在Node中的表现" class="headerlink" title="在Node中的表现"></a>在Node中的表现</h2><p>Node也是单线程，但是在处理<code>Event Loop</code>上与浏览器稍微有些不同，这里是<a href="https://link.juejin.cn/?target=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/%23event-loop-explained">Node官方文档</a>的地址。</p><p>就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的<code>process.nextTick</code>以及宏任务的<code>setImmediate</code>。</p><h3 id="setImmediate与setTimeout的区别"><a href="#setImmediate与setTimeout的区别" class="headerlink" title="setImmediate与setTimeout的区别"></a>setImmediate与setTimeout的区别</h3><p>在官方文档中的定义，<code>setImmediate</code>为一次<code>Event Loop</code>执行完毕后调用。<br> <code>setTimeout</code>则是通过计算一个延迟时间后进行执行。</p><p>但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。<br> 因为如果主进程中先注册了两个任务，然后执行的代码耗时超过<code>XXs</code>，而这时定时器已经处于可执行回调的状态了。<br> 所以会先执行定时器，而执行完定时器以后才是结束了一次<code>Event Loop</code>，这时才会执行<code>setImmediate</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">set<span class="hljs-constructor">Timeout(<span class="hljs-params">_</span> =&gt; <span class="hljs-params">console</span>.<span class="hljs-params">log</span>(&#x27;<span class="hljs-params">setTimeout</span>&#x27;)</span>)<br>set<span class="hljs-constructor">Immediate(<span class="hljs-params">_</span> =&gt; <span class="hljs-params">console</span>.<span class="hljs-params">log</span>(&#x27;<span class="hljs-params">setImmediate</span>&#x27;)</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>有兴趣的可以自己试验一下，执行多次真的会得到不同的结果。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/15/1653c82abfac7543~tplv-t2oaga2asx-zoom-in-crop-mark:652:0:0:0.awebp" alt="img"></p><p>但是如果后续添加一些代码以后，就可以保证<code>setTimeout</code>一定会在<code>setImmediate</code>之前触发了：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>))<br>setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>))<br><br><span class="hljs-keyword">let</span> countdown = <span class="hljs-number">1e9</span><br><br><span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">countdown--</span>)</span> &#123; &#125; <span class="hljs-comment">// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>如果在另一个宏任务中，必然是<code>setImmediate</code>先执行：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).readFile(__dirname, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>))<br>  setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p>就像上边说的，这个可以认为是一个类似于<code>Promise</code>和<code>MutationObserver</code>的微任务实现，在代码执行的过程中可以随时插入<code>nextTick</code>，并且会保证在下一个宏任务开始之前所执行。</p><p>在使用方面的一个最常见的例子就是一些事件绑定类的操作：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lib</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">require</span>(<span class="hljs-params">&#x27;events&#x27;</span>).<span class="hljs-title">EventEmitter</span> </span>&#123;<br>  constructor () &#123;<br>    <span class="hljs-keyword">super</span>()<br><br>    <span class="hljs-keyword">this</span>.emit(<span class="hljs-symbol">&#x27;ini</span>t&#x27;)<br>  &#125;<br>&#125;<br><br>const lib = <span class="hljs-keyword">new</span> <span class="hljs-type">Lib</span>()<br><br>lib.on(<span class="hljs-symbol">&#x27;ini</span>t&#x27;, _ =&gt; &#123;<br>  <span class="hljs-comment">// 这里将永远不会执行</span><br>  console.log(<span class="hljs-symbol">&#x27;init</span>!&#x27;)<br>&#125;)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>因为上述的代码在实例化<code>Lib</code>对象时是同步执行的，在实例化完成以后就立马发送了<code>init</code>事件。<br> 而这时在外层的主程序还没有开始执行到<code>lib.on(&#39;init&#39;)</code>监听事件的这一步。<br> 所以会导致发送事件时没有回调，回调注册后事件不会再次发送。</p><p>我们可以很轻松的使用<code>process.nextTick</code>来解决这个问题：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lib</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">require</span>(<span class="hljs-params">&#x27;events&#x27;</span>).<span class="hljs-title">EventEmitter</span> </span>&#123;<br>  constructor () &#123;<br>    <span class="hljs-keyword">super</span>()<br><br>    process.nextTick(_ =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.emit(<span class="hljs-symbol">&#x27;ini</span>t&#x27;)<br>    &#125;)<br><br>    <span class="hljs-comment">// 同理使用其他的微任务</span><br>    <span class="hljs-comment">// 比如Promise.resolve().then(_ =&gt; this.emit(&#x27;init&#x27;))</span><br>    <span class="hljs-comment">// 也可以实现相同的效果</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></div></td></tr></table></figure><p>这样会在主进程的代码执行完毕后，程序空闲时触发<code>Event Loop</code>流程查找有没有微任务，然后再发送<code>init</code>事件。</p><p><em>关于有些文章中提到的，循环调用<code>process.nextTick</code>会导致报警，后续的代码永远不会被执行，这是对的，参见上边使用的双重循环实现的<code>loop</code>即可，相当于在每次<code>for</code>循环执行中都对数组进行了<code>push</code>操作，这样循环永远也不会结束</em></p><h2 id="多提一嘴async-await函数"><a href="#多提一嘴async-await函数" class="headerlink" title="多提一嘴async/await函数"></a>多提一嘴async/await函数</h2><p>因为，<code>async/await</code>本质上还是基于<code>Promise</code>的一些封装，而<code>Promise</code>是属于微任务的一种。所以在使用<code>await</code>关键字与<code>Promise.then</code>效果类似：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;<br><br>main()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p><strong>async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于<code>new Promise</code>时传入的代码，await之后的所有代码都是在<code>Promise.then</code>中的回调</strong></p><p>原文链接：<a href="https://juejin.cn/post/6844903657264136200">https://juejin.cn/post/6844903657264136200</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Evenloop事件循环&quot;&gt;&lt;a href=&quot;#Evenloop事件循环&quot; class=&quot;headerlink&quot; title=&quot;Evenloop事件循环&quot;&gt;&lt;/a&gt;Evenloop事件循环&lt;/h1&gt;&lt;p&gt;JavaScript是一个单线程的脚本语言。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/categories/js/"/>
    
    
    <category term="js" scheme="https://zhouhang-hello.gitee.io/hexo_blog/tags/js/"/>
    
  </entry>
  
</feed>
