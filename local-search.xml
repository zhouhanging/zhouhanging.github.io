<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vuex使用</title>
    <link href="/hexo_blog/2021/09/23/vuex%E4%BD%BF%E7%94%A8/"/>
    <url>/hexo_blog/2021/09/23/vuex%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/hexo_blog/2021/09/18/vuex%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/hexo_blog/2021/09/18/vuex%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/hexo_blog/2021/09/17/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/hexo_blog/2021/09/17/axios%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="axios拦截器接口配置与使用"><a href="#axios拦截器接口配置与使用" class="headerlink" title="axios拦截器接口配置与使用"></a>axios拦截器接口配置与使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习期间遇到了一个axios拦截器接口配置的问题，这里总结一下相关使用</p><p>附上官方文档(<a href="http://axios-js.com/zh-cn/docs/index.html">http://axios-js.com/zh-cn/docs/index.html</a>)</p><p> ▉ 什么是axios拦截器、为什么要使用axios拦截器？</p><blockquote><ul><li><p> Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p></li><li><p>页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；如果请求数非常多，单独对每一个请求进行处理会变得非常麻烦，程序的优雅性也会大打折扣。好在强大的axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</p></li><li><p>它有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等</p></li></ul></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210917154842286.png" alt="image-20210917154842286" style="zoom:50%;" /><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//   在http.js中引入axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>   <span class="hljs-comment">//引入 axios</span><br><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>; <span class="hljs-comment">// 引入qs模块，用来序列化post类型的数据，某些请求会用得到</span><br><span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>    <span class="hljs-comment">//引入 element-ui 的 Message 模块，用于信息提示</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span>     <span class="hljs-comment">//引入 vuex 中的数据</span><br><span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span>   <span class="hljs-comment">//引入拿到的权限tocken</span><br><br><span class="hljs-comment">// create an axios instance   创建axios实例</span><br><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>配置信息...<br>&#125;)<br><br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">`配置引入`<br>import Qs from <span class="hljs-string">&#x27;qs&#x27;</span>;<br>export default&#123;<br>  <span class="hljs-regexp">//</span> 请求的接口，在请求的时候，如axios.get(url,config);这里的url会覆盖掉config中的url<br>  url: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-regexp">//</span> 请求的接口<br>  baseURL: <br>  <span class="hljs-regexp">//</span> 默认请求方法<br>  title: <span class="hljs-string">&#x27;&#x27;</span>,<br>  method: <span class="hljs-string">&#x27;post&#x27;</span>,<br>  <span class="hljs-regexp">//</span> 在发送请求之前对请求数据做处理<br>  transformRequest: [<br>    <span class="hljs-keyword">function</span>(data) &#123;<br>      <span class="hljs-regexp">//</span> 为了避免qs格式化时对内层对象的格式化先把内层的对象转为<br>      <span class="hljs-regexp">//</span> data.strSQL = base64encode(data.strSQL)<br>      <span class="hljs-regexp">//</span> 由于使用的form-data传数据所以要格式化<br>      data = Qs.stringify(data);<br>      return data;<br>    &#125;,<br>  ],<br><br>  <span class="hljs-regexp">//</span> 提前处理返回的数据=<br>  transformResponse: [<br>    <span class="hljs-keyword">function</span>(data) &#123;<br>      return data;<br>    &#125;,<br>  ],<br>  <span class="hljs-regexp">//</span> 请求头信息<br>  headers: &#123;<br>    <br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 默认parameter参数<br>  params: &#123;<br><br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 序列化param<br>  paramsSerializer: <span class="hljs-keyword">function</span>(params) &#123;<br>    return Qs.stringify(params);<br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 默认post参数，使用axios.post(url,&#123;&#125;,config);如果没有额外的也必须要用一个空对象，否则会报错<br>  data: &#123;<br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 设置超时时间<br>  timeout: <span class="hljs-number">500000000</span>,<br><br>  <span class="hljs-regexp">//</span> 是否跨站点访问控制请求<br>  <span class="hljs-regexp">//</span> withCredentials: false, <span class="hljs-regexp">//</span> default<br>  withCredentials: true, <span class="hljs-regexp">//</span> 自动携带cookie<br><br>  <span class="hljs-regexp">//</span> 返回数据类型<br>  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-regexp">//</span> default<br><br>  <span class="hljs-regexp">//</span> 将upload事件注释掉，防止跨域状态下发起option请求<br><br>  <span class="hljs-regexp">//</span> onUploadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;<br>  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event<br>  <span class="hljs-regexp">//</span> &#125;,<br>  <span class="hljs-regexp">//</span> onDownloadProgress: <span class="hljs-keyword">function</span>(progressEvent) &#123;<br>  <span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> Do whatever you want with the native progress event<br>  <span class="hljs-regexp">//</span> &#125;,<br>  maxContentLength: <span class="hljs-number">2000</span>,<br>  validateStatus: <span class="hljs-keyword">function</span>(status) &#123;<br>    return status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-regexp">//</span> default<br>  &#125;,<br>  <span class="hljs-regexp">//</span> `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目<br>  <span class="hljs-regexp">//</span> 如果设置为<span class="hljs-number">0</span>，将不会 follow 任何重定向<br>  maxRedirects: <span class="hljs-number">5</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p> ▉ 请求拦截器</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.request.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(config) &#123;<br>    // 在发起请求请做一些业务处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">config</span>;<br>  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;<br>    // 对请求失败做处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;<br>  &#125;);<br></code></pre></div></td></tr></table></figure></blockquote><p> ▉ 响应拦截器</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">axios.interceptors.response.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(response) &#123;<br>    // 对响应数据做处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">response</span>;<br>  &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(error) &#123;<br>    // 对响应错误做处理<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.reject(error)</span>;<br>  &#125;);<br></code></pre></div></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/hexo_blog/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/hexo_blog/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是用来模拟具有树状结构性质的数据集合,顾名思义，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”</p><h3 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h3><blockquote><p>1.第n层的节点数最多为2n个节点</p><p>2.n层二叉树最多有20+…+2n=2n+1-1个节点</p><p>3.第一个非叶子节点：length/2</p><p>4.一个节点的孩子节点：2n、2n+1</p></blockquote><h3 id="基础遍历"><a href="#基础遍历" class="headerlink" title="基础遍历"></a>基础遍历</h3><h5 id="▉前序遍历"><a href="#▉前序遍历" class="headerlink" title="▉前序遍历"></a>▉前序遍历</h5><blockquote><p>​    若二叉树为空,则空操作返回,否则</p><ol><li><strong>先</strong>访问<strong>根</strong>结点</li><li>前序遍历<strong>左</strong>子树,</li><li>前序遍历<strong>右</strong>子树.</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092241832.png" alt="image-20210923092241832" style="zoom:50%;" /></p><ul><li><p>递归遍历</p><blockquote><p>先序递归遍历的思路是先遍历根结点，将值存入数组，然后递归遍历：先左结点，将值存入数组，继续向下遍历，然后再回溯遍历右结点，将值存入数组，这样递归循环。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组<br>var preOrderRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        preListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中<br>        preOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树<br>        preOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树<br>    &#125;<br>&#125;<br>preOrderRec(tree);<br>console.log(preListRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]<br><br></code></pre></div></td></tr></table></figure></li><li><p>非递归遍历</p><blockquote><p>先序非递归遍历是利用了栈，将根结点放入栈中，然后再取出来，将值放入结果数组，然后如果存在右子树，将右子树压入栈，如果存在左子树，将左子树压入栈，然后循环判断栈是否为空，重复上述步骤。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var preListUnRec = []; <span class="hljs-regexp">//</span>定义保存先序遍历结果的数组<br>var preOrderUnRecursion = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈<br>        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历<br>            node = stack.pop(); <span class="hljs-regexp">//</span>从栈中取出一个结点<br>            preListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中<br>            <span class="hljs-keyword">if</span> (node.right) stack.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树压入栈<br>            <span class="hljs-keyword">if</span> (node.left) stack.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树压入栈<br>        &#125;<br>    &#125;<br>&#125;<br>preOrderUnRecursion(tree);<br>console.log(preListUnRec);<br><br></code></pre></div></td></tr></table></figure></li></ul><h5 id="▉中序遍历"><a href="#▉中序遍历" class="headerlink" title="▉中序遍历"></a>▉中序遍历</h5><blockquote><p>​    若树为空,则空操作返回,否则</p><ol><li>从根结点开始(注意不是先访问根结点)</li><li>中序遍历根结点的左子树,然后是访问根结点</li><li>中序遍历右子树</li></ol></blockquote><p>​    <img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092324252.png" alt="image-20210923092324252" style="zoom:50%;" /></p><p>递归遍历</p><blockquote><p>中序递归遍历的思路是先递归遍历左子树，从最后一个左子树开始存入数组，然后回溯遍历双亲结点，再是右子树，这样递归循环</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组<br>var inOrderRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        inOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树<br>        inListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中<br>        inOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树<br>    &#125;<br>&#125;<br>inOrderRec(tree);<br>console.log(inListRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]<br><br></code></pre></div></td></tr></table></figure><p>非递归遍历</p><blockquote><p>非递归遍历的思路是将当前结点压入栈，然后将左子树当做当前结点，如果当前结点为空，将双亲结点取出来，将值保存进数组，然后将右子树当做当前结点，进行循环。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var inListUnRec = []; <span class="hljs-regexp">//</span>定义保存中序遍历结果的数组<br>var inOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var stack = []; <span class="hljs-regexp">//</span>建立一个栈<br>        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span> || node) &#123; <span class="hljs-regexp">//</span>如果栈不为空或结点不为空，则循环遍历<br>            <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>如果结点不为空<br>                stack.push(node); <span class="hljs-regexp">//</span>将结点压入栈<br>                node = node.left; <span class="hljs-regexp">//</span>将左子树作为当前结点<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span>左子树为空，即没有左子树的情况<br>                node = stack.pop(); <span class="hljs-regexp">//</span>将结点取出来<br>                inListUnRec.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值存入数组中<br>                node = node.right; <span class="hljs-regexp">//</span>将右结点作为当前结点<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>inOrderUnRec(tree);<br>console.log(inListUnRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><h5 id="▉后序遍历"><a href="#▉后序遍历" class="headerlink" title="▉后序遍历"></a>▉后序遍历</h5><blockquote><p>​    若树为空,则空操作返回，否则</p><ol><li>从左到右先叶子后结点的方式遍历访问左右子树</li><li>最后是访问根结点.</li></ol></blockquote><img src="C:/Users/l%27x/AppData/Roaming/Typora/typora-user-images/image-20210923092350092.png" alt="image-20210923092350092" style="zoom:50%;" /><p>递归</p><blockquote><p>递归遍历也是和上面的差不多，先走左子树，当左子树没有孩子结点时，将此结点的值放入数组中，然后回溯遍历双亲结点的右结点，递归遍历。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组<br>var postOrderRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        postOrderRec(node.left); <span class="hljs-regexp">//</span>递归遍历左子树<br>        postOrderRec(node.right); <span class="hljs-regexp">//</span>递归遍历右子树<br>        postListRec.push(node.value); <span class="hljs-regexp">//</span>将结点的值存入数组中<br>    &#125;<br>&#125;<br>postOrderRec(tree);<br>console.log(postListRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><p>非递归</p><blockquote><p>这里使用了一个tmp变量来记录上一次出栈、入栈的结点。思路是先把根结点和左树推入栈，然后取出左树，再推入右树，取出，最后取根结点</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var postListUnRec = []; <span class="hljs-regexp">//</span>定义保存后序遍历结果的数组<br>var postOrderUnRec = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var stack = [node]; <span class="hljs-regexp">//</span>将二叉树压入栈<br>        var tmp = null; <span class="hljs-regexp">//</span>定义缓存变量<br>        <span class="hljs-keyword">while</span> (stack.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>如果栈不为空，则循环遍历<br>            tmp = stack[stack.length - <span class="hljs-number">1</span>]; <span class="hljs-regexp">//</span>将栈顶的值保存在tmp中<br>            <span class="hljs-keyword">if</span> (tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果存在左子树<br>                stack.push(tmp.left); <span class="hljs-regexp">//</span>将左子树结点压入栈<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp.right &amp;&amp; node !== tmp.right) &#123; <span class="hljs-regexp">//</span>如果结点存在右子树<br>                stack.push(tmp.right); <span class="hljs-regexp">//</span>将右子树压入栈中<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                postListUnRec.push(stack.pop().value);<br>                node = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>postOrderUnRec(tree);<br>console.log(postListUnRec);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><p>▉广度遍历</p><blockquote><p>广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。<br>实现原理：使用数组模拟队列，首先将根结点归入队列。当队列不为空时，执行循环：取出队列的一个结点，如果该节点有左子树，则将该节点的左子树存入队列；如果该节点有右子树，则将该节点的右子树存入队列。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var breadthList = []; <span class="hljs-regexp">//</span>定义保存广度遍历结果的数组<br>var breadthTraversal = <span class="hljs-keyword">function</span>(node) &#123;<br>    <span class="hljs-keyword">if</span> (node) &#123; <span class="hljs-regexp">//</span>判断二叉树是否为空<br>        var que = [node]; <span class="hljs-regexp">//</span>将二叉树放入队列<br>        <span class="hljs-keyword">while</span> (que.length !== <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span>判断队列是否为空<br>            node = que.shift(); <span class="hljs-regexp">//</span>从队列中取出一个结点<br>            breadthList.push(node.value); <span class="hljs-regexp">//</span>将取出结点的值保存到数组<br>            <span class="hljs-keyword">if</span> (node.left) que.push(node.left); <span class="hljs-regexp">//</span>如果存在左子树，将左子树放入队列<br>            <span class="hljs-keyword">if</span> (node.right) que.push(node.right); <span class="hljs-regexp">//</span>如果存在右子树，将右子树放入队列<br>        &#125;<br>    &#125;<br>&#125;<br>breadthTraversal(tree);<br>console.log(breadthList);<br><span class="hljs-regexp">//</span>[ <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ]<br></code></pre></div></td></tr></table></figure><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><blockquote><p>第一步：先考虑用递归的方式解决问题，注意递归的终止条件。有的递归需要用到回溯法和全局变量</p><p>第二步：如果递归无法解决问题，考虑迭代法，具体的迭代方式参考层序遍历和非递归遍历</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，用的是一般为后序，例如单纯求深度就用前序，二叉树找所有路径也用了前序，这是为了方便让父节点指向子节点。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MOGu面经</title>
    <link href="/hexo_blog/2021/09/13/MOGU/"/>
    <url>/hexo_blog/2021/09/13/MOGU/</url>
    
    <content type="html"><![CDATA[<h1 id="MOGU面经收集"><a href="#MOGU面经收集" class="headerlink" title="MOGU面经收集"></a>MOGU面经收集</h1><p>2019-08-14</p><blockquote><ol><li>说一些 ES6 你擅长的东西（说了let、const、proxy、promise，面：说有深度的，我：。。。）</li><li>b === b + 1?如何实现</li><li>JS 可以实现多线程吗？</li><li>setTimeout 和 promise 谁先执行的题</li><li>点一个链接直接实现点赞功能，原理？</li><li>短连接变成长连接使用了哪些知识点。</li><li>节流防抖实现</li><li>首屏加载问题</li><li>性能优化</li><li>项目</li></ol></blockquote><p> 2019-08-30 </p><blockquote><p>vue<br>1.对整个vue的了解程度<br>2.vue生命周期<br>3.如何用函数的方式调用组件</p><p>css<br>4.em和rem区别</p><p>js<br>5.let const var 区别<br>6.const一个对象，它的值可以变吗，为什么<br>优化<br>7.图片很多怎么减少http请求<br>8.跨域的方式<br>9 .印象深刻的项目经验</p></blockquote><p>2019-08-19(一面)</p><blockquote><p>自我介绍</p><p>实习做的事，遇到了哪些困难，做了什么优化</p><p>画一个三角形</p><p>排序算法（手写快排）</p><p>js继承（手写两个）</p><p>new的过程</p><p>虚拟dom（解决了什么困难）</p><p>ajax过程</p><p>apply 、 call 、bind异同</p><p>闭包</p><p>深浅拷贝</p><p>瀑布流实现</p><p>重排重绘</p><p>使用vue中遇到哪些问题</p><p>为什么Object.defineProperty监听不到数组长度等变化</p><p>输入url到页面展示过程</p></blockquote><p> 2019-08-13 </p><blockquote><p>1.自我介绍<br>2.讲一下项目做了些什么（原型用的什么工具）<br>3.项目工程化思维<br>4.标准盒模型，ie盒模型<br>5.水平垂直居中<br>6.响应式<br>7.rem<br>8.ui框架改变样式不影响其他人<br>9.子代选择器和后代选择器的权重<br>10.实现一个动画<br>11.重排重绘<br>12.怎么让动画更加流畅<br>13.前端搜索，不同条件下可能有相同的结果（结果会很多，1000条数据），你怎么去优化（缓存？？分页？？）<br>14.浏览器的存储<br>15.图片预加载和懒加载<br>16.防抖节流（口述节流算法）<br>17.闭包，内存泄漏（怎么解决内存泄漏）<br>18.永久绑定作用域，构建一个公共函数，但是不传对象参数，怎么绑定（？？）<br>19.让a === a + e(常量) 可以实现吗<br>20.js线程<br>21.setTimeout是一个线程吗<br>21.事件委托<br>22.实现长url转换为一个短的url<br>23.302（可以实现刚才的url转换吗）<br>24.vue生命周期<br>25.vue兄弟组件通信<br>26.diff算法<br>27.template渲染过程<br>28.jsonp<br>29.场景题：你老板的手机，看你们开发的微信小程序，遇到了白屏的情况，问你怎么排查问题（问题可能不会复现，你怎么保证添加数据去复现这个场景）<br>30.场景题：直播行业发达，怎么给每个人的发送的消息加一个唯一的标识，相当于id的样子，如何实现<br>31.平时除了做项目还会做些什么<br>(体会就是项目上最好就是讲项目难点，为什么会出现，怎么一步步去解决的<br>项目上做了什么功能，你怎么实现的，你怎么去做项目的)</p></blockquote><p>2017-08-31 </p><blockquote><p>​    一面（2017.08.17，50min） </p><p> 头天晚上投了简历，第二天HR就打电话约面试了，效率很高。 </p><ol><li><p> 自我介绍 </p></li><li><p> 对<a href="">前端</a>这个行业怎么看，为什么要做<a href="">前端</a>？ </p></li><li><p> 对自己未来的规划？ </p></li><li><p> 说一下你理解的<a href="">前端</a>开发流程？ </p></li><li><p> 如何理解 <a href="">JavaScript</a> 闭包？ </p></li><li><p> 如何理解 <a href="">JavaScript</a> this 关键字？ </p></li><li><p> <a href="">JavaScript</a> 基本数据类型？ </p></li><li><p> Undifined 和 Null 的区别？ </p></li><li><p> 了解的 <a href="">JavaScript</a> 数组方法？ </p></li><li><p> CSS单位 rem 和 em 的区别？ </p></li><li><p> 了解的原生 <a href="">JavaScript</a> 方法？ </p></li><li><p> CSS 选择器优先级？ </p></li><li><p> 如何理解 HTML 语义化？ </p></li><li><p> 如何取消一个事件监听？ </p></li><li><p> ‘==’ 和 ‘===’ 的区别？ </p></li><li><p> 如何选择<a href="">前端</a>框架？ </p></li><li><p> 你的优点和缺点是什么？ </p></li><li><p> 当你在一个团队的时候，你的憧憬是什么？ </p></li><li><p>还有什么想问我的？ </p><p>基础问了一点，问了很多关于<a href="">职业规划</a>的问题。中规中矩。</p></li></ol><p>作者：梦游计<br>链接：<a href="https://www.nowcoder.com/discuss/33673?type=2&amp;order=3&amp;pos=22&amp;page=1">https://www.nowcoder.com/discuss/33673?type=2&amp;order=3&amp;pos=22&amp;page=1</a><br>来源：牛客网</p><h3 id="二面（2017-8-21，30min）"><a href="#二面（2017-8-21，30min）" class="headerlink" title="二面（2017.8.21，30min）"></a>二面（2017.8.21，30min）</h3><ol><li> 聊<a href="">项目</a> </li><li> 从什么时候接触<a href="">前端</a>的？ </li><li> 你专业方向是J2EE，当时为什么不选择J2EE？ </li><li> <a href="">JavaScript</a> 和其他语言的面向对象的区别？ </li><li> 继续聊<a href="">项目</a> </li><li> 兼职实习在做什么？ </li><li> 上一次面试官问的什么问题，哪些答的好，哪些答的不好，之后有查过嘛？ </li><li> 还有什么要问我的？</li></ol></blockquote><p>面试准备</p><blockquote><p>1.const<br>2.let var 之间的区别<br>4、es6中的const解释解释<br>9.em和rem区别<br>3.js部分，const，let和 var 的区别。<br>4.js部分，数组遍历map和forEach的区别。</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">能用forEach<span class="hljs-comment">()</span>做到的，map<span class="hljs-comment">()</span>同样可以。反过来也是如此。<br>map<span class="hljs-comment">()</span>会分配内存空间存储新数组并返回，forEach<span class="hljs-comment">()</span>不会返回数据。<br>forEach<span class="hljs-comment">()</span>允许callback更改原始数组的元素。map<span class="hljs-comment">()</span>返回新的数组。<br></code></pre></div></td></tr></table></figure><p>5.css部分，em和rem怎么做自适应。<br>8.函数提升和变量提升优先级</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">函数提升 优于变量<br>解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第<span class="hljs-number">40</span>页提到函数声明是优于变量提升的。可见代码<br><span class="hljs-built_in">console</span>.log(getName)<br><span class="hljs-keyword">var</span> getName = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-comment">// 输出为函数getName</span><br>注意:不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了)<br></code></pre></div></td></tr></table></figure><p>JS深拷贝的用处，哪里会用到？</p><blockquote><p>浅拷贝<br>深拷贝</p></blockquote><p>7、闭包以及带来问题<br>闭包知道吗？它可能出现的问题呢<br>10、css有哪些布局（一开始理解错了说了一大堆，后来面试官带回来了，是关于position、float）<br>11、flex实现水平垂直居中<br>12、align-items:center是不是只针对垂直<br>css布局都用过啥，flex布局，想让我说flex布局的原理的。。。想想还是算了，感觉面试官对原理情有独钟<br>CSS布局技巧<br>跨域的几种方式，有答jsonp，然后又问了 jsonp 的原理是啥？<br>6.跨域问题<br>6.常用的跨域方式。<br>项目有没跨域问题<br>5.作用域链<br><a href="https://juejin.im/post/58ed9c0ea0bb9f006a4c28cd">JavaScript深入之作用域链</a><br><a href="https://juejin.im/post/5c8290455188257e5d0ec64f">深入理解JavaScript作用域和作用域链</a></p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">作用域链，是由当前环境与上层环境的一系列变量对象组成，<br>它保证了当前执行环境对符合访问权限的变量和函数的有序访问。<br><br>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，<br>就会从父级<span class="hljs-comment">(词法层面上的父级)</span>执行上下文的变量对象中查找，一直找到<br>全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对<br>象构成的链表就叫做作用域链。<br></code></pre></div></td></tr></table></figure><p>第一个问题是讲一下原型链，这个我先推了一下，讲了个小插曲，promise的状态和蘑菇街面试的状态吻合，只有pending、resolved、rejected三种状态，算是个破冰吧，今天看promise想到的。<br>然后继续回答原型链。</p><p>2、Promise了解多少</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span> 是异步编程的一种解决方案：<br>从语法上讲，promise是一个对象，从它可以获取异步操作的消息；<br>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。<br>promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；<br>状态一旦改变，就不会再变。创造promise实例后，它会立即执行。<br><br>pending，异步任务正在进行。<br>resolved (也可以叫fulfilled)，异步任务执行成功。<br>rejected，异步任务执行失败。<br><br>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise可以支持多个并发的请求，获取并发请求中的数据<br>这个promise可以解决异步的问题，本身不能说promise是异步的<br><br><span class="hljs-built_in">Promise</span>.resolve(value)<br>类方法，该方法返回一个以 value 值解析后的 <span class="hljs-built_in">Promise</span> 对象<br><span class="hljs-number">1</span>、如果这个值是个 thenable（即带有 then 方法），返回的 <span class="hljs-built_in">Promise</span> <br>对象会“跟随”这个 thenable 的对象，采用它的最终状态<br>（指 resolved/rejected/pending/settled）<br><span class="hljs-number">2</span>、如果传入的 value 本身就是 <span class="hljs-built_in">Promise</span> 对象，<br>  则该对象作为 <span class="hljs-built_in">Promise</span>.resolve 方法的返回值返回。<br><span class="hljs-number">3</span>、其他情况以该值为成功状态返回一个 <span class="hljs-built_in">Promise</span> 对象。<br><br><span class="hljs-built_in">Promise</span>.all的用法：谁跑的慢，以谁为准执行回调。<br>  all接收一个数组参数，里面的值最终都算返回<span class="hljs-built_in">Promise</span>对象<br>  all方法可以说是<span class="hljs-built_in">Promise</span>中很常用的方法了，它的作用就是将一个数组的<span class="hljs-built_in">Promise</span>对象放在其中，当全部resolve的时候就会执行then方法，当有一个reject的时候就会执行<span class="hljs-keyword">catch</span>，并且他们的结果也是按着数组中的顺序来排放的，那么我们来实现一下。<br><span class="hljs-built_in">Promise</span>.race的用法：谁跑的快，以谁为准执行回调<br>它的作用是将一个<span class="hljs-built_in">Promise</span>数组放入race中，哪个先执行完，race就直接执行完，并从then中取值。<br><span class="hljs-built_in">Promise</span>.prototype.catch<br>  实例方法，捕获异常，函数形式：<span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params">err</span>)</span>&#123;&#125;, err 是 <span class="hljs-keyword">catch</span> 注册 之前的回调抛出的异常信息。<br><span class="hljs-built_in">Promise</span>.prototype.then<br>  实例方法，为 <span class="hljs-built_in">Promise</span> 注册回调函数，函数形式：<span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params">vlaue</span>)</span>&#123;&#125;，value 是上一个任务的返回结果，then 中的函数一定要 <span class="hljs-keyword">return</span> 一个结果或者一个新的 <span class="hljs-built_in">Promise</span> 对象，才可以让之后的then 回调接收。<br><span class="hljs-built_in">Promise</span>.reject<br>类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。<br><br><span class="hljs-built_in">Promise</span>的立即执行性<br><span class="hljs-built_in">Promise</span> 三种状态<br><span class="hljs-built_in">Promise</span> 状态的不可逆性<br>then方法链式调用<br><br><span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span><br></code></pre></div></td></tr></table></figure><p>promise有了解吗<br>Promise.all promise.race 有了解吗（当时一直听成Promise.out ，我就纳闷了说哪儿来的这个方法。。）</p><p>3.React 生命周期，如果要合并 props 和 state 在哪进行<br>4.React 组件想用函数调用的方式使用，怎么设计<br>react如果更新了父组件，子组件没有更新，会都重新渲染吗？<br>react的原理，他的内部是怎么构建DOM的，比如p标签的子元素放在哪个属性里。。。没看过源码着实不知道<br>react相关的redux的原理？<br>7.你印象比较深的项目或者代码<br>我觉得是像 antd 里面的 message 模块，使用 ReactDOM.render<br>挂载组件到指定节点，然后通过更新 props 使用<br>html css js擅长哪部分？<br>我回答擅长js，但他居然没有继续问下去了</p><p>3、es5和es6了解多少<br>es5,es6哪个用的多点？<br>3、es5和es6了解多少</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">变量声明：<span class="hljs-keyword">let</span> <span class="hljs-keyword">const</span><br>字符串模板<br>解构赋值 对象对对象 数组对数组<br>扩展运算符<br>箭头函数<br>  不需要 <span class="hljs-keyword">function</span> 关键字来创建函数<br>  省略 <span class="hljs-keyword">return</span> 关键字<br>  继承当前上下文的 <span class="hljs-built_in">this</span> 关键字<br><span class="hljs-keyword">import</span>导入模块、<span class="hljs-keyword">export</span>导出模块<br><span class="hljs-built_in">Promise</span><br>数组常用方法：<br><span class="hljs-built_in">Array</span>.isArray<br><span class="hljs-keyword">map</span><br>filter<br>forEach<br>every<br>reduce<br>splice<br>indexOf<br>slice<br>concat<br>reverse()<br>join()<br><br><span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>()<br><span class="hljs-built_in">Array</span>.<span class="hljs-keyword">of</span>()<br>copyWitch<br>find<br>findIndex<br>keys()<br>values()<br><span class="hljs-class"><span class="hljs-keyword">class</span> 静态、私有、共有</span><br><br>生成器（ generator）是能返回一个迭代器的函数。<br>生成器函数也是一种函数，最直观的表现就是比普通的<span class="hljs-keyword">function</span>多了个星号*，<br>在其函数体内可以使用<span class="hljs-keyword">yield</span>关键字,有意思的是函数会在每个<span class="hljs-keyword">yield</span>后暂停。<br><br>可以暂停并重新开始执行的函数<br><br>generators 可以扮演三种角色<br>  迭代器(数据生产者)<br>  观察者(数据消费者)<br>  协作程序(数据生产者和消费者)<br></code></pre></div></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000012358863">es6 Generators详解</a></p><p>2.CSS sprite(雪碧图或者精灵图)<br><a href="https://www.cnblogs.com/evenyao/p/9262371.html">CSS Sprite “精灵图”</a><br><a href="https://blog.csdn.net/CamilleZJ/article/details/80406645">CSS Sprite雪碧图</a></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">用CSS的<span class="hljs-string">&quot;background-image&quot;</span>，<span class="hljs-string">&quot;background-repeat&quot;</span>，<span class="hljs-string">&quot;background-position&quot;</span><br>的组合进行背景定位，<span class="hljs-built_in">background</span>-<span class="hljs-built_in">position</span>可以用数字精确的定位出背景图片的位置。<br>CSS Sprites 的优点：<br>减少图片字节<br>减少网页HTTP请求，提高网页性能<br>减少命名难的问题<br>缺点<br>图片合并的时候要把图片合理的合并成一张图片，防止板块内出现不必要的背景<br>在高分辨率下的自适应如果图片宽度不够，容易造成背景断裂<br>维护的时候比较困难，如果背景图有少许改动，需要改动合并图片。<br></code></pre></div></td></tr></table></figure><p>事件节流？刚看过，没印象了，哭。<br>情景题，往下滚动，加载更多，有什么优化方案，图片懒加载？提示了可以滚轮事件是个比较频繁的操作，但是还是没想出来。防抖</p><p>vue和react差别，<br>8、问了vue有没有做过项目，然后就没有了<br>1.vue生命周期，没有问详细的，就是顺着生命周期说了一遍。英文捉急。<br>2.vue源码部分，几个重要的部分，compile，数据劫持，依赖收集，虚拟DOM。<br>问了一个异步加载组件，不用标签引入的方法。<br>让你实现vue你怎么实现……<br>说说vue的双向绑定（顺带把响应式说了）<br>说说Vue的diff过程</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">如果不了解virtual dom，要理解<span class="hljs-built_in">diff</span>的过程是比较困难的。虚拟dom对应的是真实dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。<br><br>我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。<br><span class="hljs-built_in">diff</span>的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。<br><br>在采取<span class="hljs-built_in">diff</span>算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。<br><span class="hljs-built_in">diff</span>流程图<br>当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，<br>订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。<br><br>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点<br>判断两节点是否值得比较，值得比较则执行patchVnode<br>不值得比较则用Vnode替换oldVnode<br>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。<br><br>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法<br>这个函数做了以下事情：<br>  找到对应的真实dom，称为el<br>  判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接<span class="hljs-built_in">return</span><br>  如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。<br>  如果oldVnode有子节点而Vnode没有，则删除el的子节点<br>  如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el<br>  如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要<br>updateChildren<br>先说一下这个函数做了什么<br>  将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来<br>  oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的<span class="hljs-number">2</span>个变量相互比较，一共有<span class="hljs-number">4</span>种比较方式。如果<span class="hljs-number">4</span>种比较都没匹配，如果设置了<span class="hljs-built_in">key</span>，就会用<span class="hljs-built_in">key</span>进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。<br></code></pre></div></td></tr></table></figure><p>v-model，v-bind 和v-click</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">v-bind  动态地绑定一个或多个特性、或一个组件 prop 到表达式。<br><span class="hljs-number">1</span>:v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，<br>在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=<span class="hljs-string">&quot;表达式&quot;</span><br><br>v-model 在表单控件或者组件上创建双向绑定。<br>v-<span class="hljs-keyword">on</span> 指令用于监听DOM事件 形式如：v-<span class="hljs-keyword">on</span>:click  缩写为 <span class="hljs-meta">@click</span>;<br><br><br>[VUE中的v-<span class="hljs-keyword">if</span>与v-<span class="hljs-keyword">show</span>](http:<span class="hljs-comment">//www.cnblogs.com/wmhuang/p/5420344.html)</span><br>手段：v-<span class="hljs-keyword">if</span>是动态的向DOM树内添加或者删除DOM元素；<br>v-<span class="hljs-keyword">show</span>是通过设置DOM元素的display样式属性控制显隐；<br>编译过程<br>：v-<span class="hljs-keyword">if</span>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<br>v-<span class="hljs-keyword">show</span>只是简单的基于css切换；<br>编译条件：<br>v-<span class="hljs-keyword">if</span>是惰性的，如果初始条件为假，则什么也不做；<br>只有在条件第一次变为真时才开始局部编译(编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载)<br>v-<span class="hljs-keyword">if</span>是动态的向DOM树内添加或者删除DOM元素；<br>v-<span class="hljs-keyword">show</span>是通过设置DOM元素的display样式属性控制显隐；<br>v-<span class="hljs-keyword">show</span>是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；<br>性能消耗：<br>v-<span class="hljs-keyword">if</span>有更高的切换消耗；v-<span class="hljs-keyword">show</span>有更高的初始渲染消耗；<br>使用场景：<br>v-<span class="hljs-keyword">if</span>适合运营条件不大可能改变；v-<span class="hljs-keyword">show</span>适合频繁切换。<br><br><br>v-<span class="hljs-keyword">if</span> 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-<span class="hljs-keyword">if</span> 也是惰性的：<br>如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-<span class="hljs-keyword">show</span> 就简单得多——不管初始条件是什么，<br>元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说， v-<span class="hljs-keyword">if</span> 有更高的切换开销，而 v-<span class="hljs-keyword">show</span> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-<span class="hljs-keyword">show</span> 较好；<br>如果在运行时条件不太可能改变，则使用 v-<span class="hljs-keyword">if</span> 较好。<br></code></pre></div></td></tr></table></figure><p>function a(){}，a的<strong>proto</strong> 指向哪，Function呢？Object呢？<br>js异步都有哪些？答了onclick之类的、setTimeout/setInterval/requestAnimation、Generator、promise、async/await，讲了promise和async/await的优缺点。</p><p>1.就我这次面试表现而言，有哪方面需要提升或者欠缺的<br>3.团队技术栈？<br>然后项目……照着你简历上的问，<br>技术选型，遇到的困难，解决思路，</p><p>面试中印象最深的问题<br>场面试官自己先介绍了三分钟..然后让我也介绍一下基本情况，项目经历难点之类的。<br>然后开始面试，很少技术问题<br>项目难点，如何解决的<br>有没有想过进入一个团队实习之后会有哪些压力大的事情？<br>有没有了解前端的新技术<br>有没有参加线下前端活动<br>会去看哪些博客或者社区<br>CSS动画和JS动画。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"> (<span class="hljs-number">1</span>)浏览器可以对动画进行优化。<br>  <span class="hljs-number">1</span>、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:<span class="hljs-number">1</span>)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒<span class="hljs-number">60</span>帧。<span class="hljs-number">2</span>)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。<br>  <span class="hljs-number">2</span>、强制使用硬件加速 （通过 GPU 来提高动画性能）<br>  (<span class="hljs-number">2</span>)代码相对简单,性能调优方向固定<br>  (<span class="hljs-number">3</span>)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码<br>缺点：<br>　　<span class="hljs-number">1</span>、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告<br> 　  <span class="hljs-number">2</span>、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。<br><br>JavaScript<br>  (<span class="hljs-number">1</span>)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。<br>  (<span class="hljs-number">2</span>)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成<br>  (<span class="hljs-number">3</span>)CSS3有兼容性问题，而JS大多时候没有兼容性问题<br>缺点：<br>　　　(<span class="hljs-number">1</span>)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。<br>  (<span class="hljs-number">2</span>)代码的复杂度高于CSS动画<br></code></pre></div></td></tr></table></figure><p>后来说问点有难度的问题的吧。直接怼了好多原理。。。卡了好几下<br>webpack的打包目录为啥是这样的，知道原理吗？<br>大概目前只能想到这些了，最后问了面试官几个问题，面试官说有结果，顿了一下，通过或者不通过hr都会通知你的emmm，感觉有点凉，主要是原理着实卡了好几个地方，不过自我感觉面试官人还是很nice的，没有太难为我，看面相是个忠厚老实的小哥哥emmm，求offer啊啊啊啊啊啊啊啊啊啊啊啊<br>7.项目印象深刻的部分和难点。<br>二面我就不写面经了，就是问了些项目上的问题，解决问题的思路，技术栈，基本情况<br>自我介绍<br>项目介绍<br>你说的你的项目里有个首屏加载特别慢的问题对吧？能说说怎么优化的吗？<br>一个骰子，5个面，你怎么实现它（一个面你怎么布局）<br>说说事件循环<br>假如有个项目加载最开始特别快，后面越来越慢你知道是为什么吗？以及如何第一时间定位（内存泄漏）<br>1、自我介绍 + 项目介绍（难点）<br>5、事件委托<br>6、任务队列<br>9、一个场景题（关于使用调试工具的）<br>13、bootstrap中的栅格式<br>一面我上来就说的微信小程序，然后后边面试官几乎都没问别的（倒是考我几个问题啊，js css啥都不问，得嘞，白准备了），然后说到Vue，说了个v-model感觉不是很满意，自己也觉得虽然自己懂原理，但是没讲清楚。。。整个流程10来分钟，估计gg了</p><p>重绘&amp;&amp;回流<br>vue differ<br>vue 生命周期<br>跨域<br>自我介绍</p><p>JavaScript 怎么实现 OOP<br>原型继承与类继承的区别<br>闭包的应用场景<br>关系完整性约束</p><p>Cookie &amp; Session 的区别<br>Session 的实现原理<br>HTTP 请求方法中哪些是幂等性的<br>跨域处理方案<br>JSONP 的缺点以及安全隐患<br>为什么要做单元测试<br>黑盒测试与白盒测试的区别<br>怎样实现测试覆盖率<br>Async &amp; Await 的使用</p><p>块级元素、行内元素、inline-block 的区别<br>水平居中的方法<br>String、Array 常用的方法<br>输入一个 URL 到呈现页面的过程<br>Vue.js 组件的生命周期<br>Git 怎么合并提交记录<br>Linux 常用的命令<br>HTTP2 新特性</p><p>常见的 Web 攻击手段以及防范措施<br>对 Ajax 的理解<br>对闭包的理解<br>对事件机制的理解<br>对 HTTP 的理解<br>GET &amp; POST 的区别<br>HTTP2 和 HTTP1 有什么不同<br>对 JavaScript 各大框架的理解<br>对 jQuery 的理解<br>页面性能优化<br>计算机网络分层<br>输入 <a href="http://www.qq.com/">www.qq.com</a> 到呈现页面的过程<br>事件机制（W3C 标准）<br>事件代理<br>XSS、CSRF 的防范<br>token 的实现原理<br>熟练使用JS实现Json、XML格式的数据发送与数据解析；<br>3、熟悉各种web标准，了解各主流浏览器特性，使页面兼容主浏览器；</p><p>自我介绍<br>事件流<br>vue nextTick原理<br>vue react区别<br>web优化<br>移动端的优化有特别了解过吗<br>css flex了解过吗<br>如何前端监控错误，<br>koa有学过吗<br>事件循环说一说<br>web新技术了解过哪些，最近有去学习哪些东西<br>PWA你能详细说说吗<br>service worker<br>h5 worker<br>非受控组件 与受控组件<br>const let var区别<br>三道题<br>有自己写过webpack插件吗<br>webpack loader 和plugin区别<br>实现promise<br>大数相加<br>纯js写一个动画，5s由快到慢，速度自定义<br>（这里特别感谢以前发过面筋的同学，前两道题因为碰到过，自己下去做了一下 10多分钟给做完了 然后又让我补了一道= =）<br>自我介绍，说一下怎么学习前端的，以及做的项目的亮点<br>web优化<br>缓存（协商，强制说一说）<br>CDN</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">CDN的全称是<span class="hljs-attribute">Content</span> Delivery Network，即内容分发网络。<br>其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，<br>使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联<br>网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、<br>负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近<br>的服务节点上。<br><br>其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，<br>提高用户访问网站的响应速度。<br>降低核心系统负载 加速用户访问<br>CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源<br></code></pre></div></td></tr></table></figure><p>DNS如何查询域名的<br>node中间件原理<br>跨域<br>作用域<br>一个页面白屏，分析原因<br>数据结构链表<br>怎么判断链表有环（当时还问我是不是刷了很多题，我们都笑了笑）<br>cookie了解吗<br>cookie的属性，怎么存储<br>web安全，xss csrf<br>css响应式布局<br>token生成过程<br>前端新技术<br>PWA讲一讲<br>serviceworker<br>h5 worker<br>智商题<br>3.45分夹角<br>两个火车相对而行，知道彼此的速度，中间有一个小鸟来回飞 知道小鸟的速度 求相撞的时候的 小鸟飞行的距离<br>10瓶药，每瓶药有10颗药片，每片10克，其中一瓶药里的所有药片是坏的 每片重量为11克，现在给你一个秤，如何一次性称出来</p><p>三面<br>自我介绍<br>web优化<br>css动画<br>csrf如何防御<br>如何生成token<br>Vue的diff能详细说一说吗<br>Vue子组件你的子组件方法是放在哪里的<br>Vue自定义指令<br>微信小程序接触过吗<br>微信小程序原理<br>TCP三次握手第三次失败了 客户端和服务端是如何处理的<br>301，302状态码区别，以及什么时候会返回这些状态。<br>node如何升级到webSoket<br>如何添加header头<br>DNS迭代和递归区别<br>前端怎么设置cookie过期<br>有看过源码吗<br>看过哪些书<br>能来实习的时间<br>智商题<br>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球 求同时喜欢足球和篮球的<br>算法 最大的回文字符<br>北森<br>一面<br>面试官非常nice，善于引导<br>自我介绍<br>你的项目<br>能说下vue如何收集依赖双向绑定的吗<br>能说下vue如何更新节点的吗<br>node如何打印时间与错误<br>webpack构建流程<br>webpack如何找到依赖关系的<br>webpack如何配置<br>vue和react区别<br>react生命周期<br>函数式组件，如何给状态（hook）<br>原型链，原型知道多少<br>es6了解哪些<br>promise.resolve()<br>http状态码<br>post请求之前先发送Option条件<br>get,post,put,delete区别（冥等）<br>二面<br>面试官是个女架构师，感觉非常好，还因为迟到了几分钟说道歉之类的<br>vue,react，你更倾向于哪一个，为什么<br>es6模块cmd amd 区别<br>跨域<br>深拷贝，浅拷贝<br>post发送Option的条件<br>输入URL到浏览器会发生什么<br>TCP为什么三次握手<br>TCP为什么四次挥手<br>HTTP为什么基于TCP协议<br>vue diff过程<br>vue如果同一个数据，很短的时间内连续更新 会怎么样。<br>算法题<br>[0,0,1,1,1,2,3,4,5]，不借用辅助空间找到不重复项[2，3，4，5]</p><p>三面<br>面试官是技术总监，问的问题都是基于场景来说的，面试体验还可以<br>有这样一个数组，你如何扁平化<br>如果用字符串形式会出现什么问题<br>跨域你如何处理的<br>能说说同源策略吗，那如果是直接请求ip会有同源策略吗，如果一个域名对应多个ip的情况呢。<br>你以前做的项目，如果让你去完善你能说一说完善的细节吗，说三点 （我提到模块化，规范化，可扩展性）<br>能具体一点说说吗，说一点就可以<br>你觉得你相比其他实习生的优点和缺点在哪里</p><p>前天过了一面。问的有基础的知识和CSS、JS应用的知识，还问了OSI七层网络。其实自我感觉回答的不太好，面试官也说框架知识和项目经验不太足够，没想到过了。<br>了项目难点，然后还考了osi网络层级，怎么用css实现表格奇偶行不同颜色，怎么根据表格行的颜色拿到行数，还问了vue的生命周期钩子函数，vue-cli不过我没答上来</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H5新特性 🕸️</title>
    <link href="/hexo_blog/2021/09/10/H5%E6%98%9F%E7%89%B9%E6%80%A7/"/>
    <url>/hexo_blog/2021/09/10/H5%E6%98%9F%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="H5新特性"><a href="#H5新特性" class="headerlink" title="H5新特性"></a>H5新特性</h1><h3 id="HTML5-现在已经不是-SGML-的子集，主要是关于图像，位置，存储，多任务等功能的增加"><a href="#HTML5-现在已经不是-SGML-的子集，主要是关于图像，位置，存储，多任务等功能的增加" class="headerlink" title="HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加"></a>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</h3><blockquote><p>新增选择器 document.querySelector、document.querySelectorAll<br>拖拽释放(Drag and drop) API<br>媒体播放的 video 和 audio<br>本地存储 localStorage 和 sessionStorage<br>离线应用 manifest<br>桌面通知 Notifications<br>语意化标签 article、footer、header、nav、section<br>增强表单控件 calendar、date、time、email、url、search<br>地理位置 Geolocation<br>多任务 webworker<br>全双工通信协议 websocket<br>历史管理 history<br>跨域资源共享(CORS) Access-Control-Allow-Origin<br>页面可见性改变事件 visibilitychange<br>跨窗口通信 PostMessage<br>Form Data 对象<br>绘画 canvas</p></blockquote><h3 id="移除的元素"><a href="#移除的元素" class="headerlink" title="移除的元素"></a>移除的元素</h3><blockquote><p>纯表现的元素：basefont、big、center、font、 s、strike、tt、u<br>对可用性产生负面影响的元素：frame、frameset、noframes</p></blockquote><h3 id="支持HTML5新标签"><a href="#支持HTML5新标签" class="headerlink" title="支持HTML5新标签"></a>支持HTML5新标签</h3><blockquote><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签<br>  可以利用这一特性让这些浏览器支持HTML5新标签<br>  浏览器支持新标签后，还需要添加标签默认的样式</p></blockquote><h3 id="如何区分-HTML-和-HTML5"><a href="#如何区分-HTML-和-HTML5" class="headerlink" title="如何区分 HTML 和 HTML5"></a>如何区分 HTML 和 HTML5</h3><blockquote><p>DOCTYPE声明、新增的结构元素、功能元素</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/hexo_blog/2021/09/10/%E9%97%AD%E5%8C%85/"/>
    <url>/hexo_blog/2021/09/10/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>闭包相关的知识点总结</p><h3 id="闭包形成的原因"><a href="#闭包形成的原因" class="headerlink" title="闭包形成的原因"></a>闭包形成的原因</h3><blockquote><p>​     了解闭包前先来了解一下上级作用域和堆栈内存释放问题。</p><ul><li>没个javascript函数都是对象，对象中有些数据我们可以访问，但是有是提供给javascript引擎存取，</li><li></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue源码解读🍺</title>
    <link href="/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/hexo_blog/2021/09/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="vue源码解读"><a href="#vue源码解读" class="headerlink" title="vue源码解读"></a>vue源码解读</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在深入学习vue，打算对源码做一些了解</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">├── benchmarks                  性能、基准测试<br>├── dist                        构建打包的输出目录<br>├── examples                    案例目录<br>├── flow                        flow 语法的类型声明<br>├── packages                    一些额外的包，比如：负责服务端渲染的包 vue-server-renderer、配合 vue-loader 使用的的 vue-template-compiler，还有 weex 相关的<br>│   ├── vue-server-renderer<br>│   ├── vue-template-compiler<br>│   ├── weex-template-compiler<br>│   └── weex-vue-framework<br>├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件<br>├── src                         vue 源码目录<br>│   ├── compiler                编译器<br>│   ├── core                    运行时的核心包<br>│   │   ├── components          全局组件，比如 keep-alive<br>│   │   ├── config.js           一些默认配置项<br>│   │   ├── global-api          全局 API，比如熟悉的：Vue.use()、Vue.component() 等<br>│   │   ├──<span class="hljs-built_in"> instance </span>           Vue 实例相关的，比如 Vue 构造函数就在这个目录下<br>│   │   ├── observer            响应式原理<br>│   │   ├── util                工具方法<br>│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿<br>│   ├── platforms               平台相关的编译器代码<br>│   │   ├── web<br>│   │   └── weex<br>│   ├──<span class="hljs-built_in"> server </span>                 服务端渲染相关<br>├── test                        测试目录<br>├── types                       TS 类型声明<br><br></code></pre></div></td></tr></table></figure><h3 id="源码学习方法"><a href="#源码学习方法" class="headerlink" title="源码学习方法"></a>源码学习方法</h3><h3 id="flow-类型检测"><a href="#flow-类型检测" class="headerlink" title="flow 类型检测"></a>flow 类型检测</h3><blockquote><p>​    Flow就是JavaScript的静态类型检查工具，由Facebook团队于2014年的Scale Conference上首次提出。该库的目标在于检查JavaScript中的类型错误，开发者通常不需要修改代码即可使用，故使用成本很低。同时，它也提供额外语法支持，使得开发者能更大程度地发挥Flow的作用。总结一句话：将javascript从弱类型语言变成了强类型语言。</p><p>Flow支持原始数据类型，其中void对应js中的undefined</p><p>基本内型  boolean / number/  string  /null  /void</p><p>引用内型   Object / Array  /Function  /自定义Class</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/hexo_blog/2021/08/26/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/hexo_blog/2021/08/26/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>html面试题🦗</title>
    <link href="/hexo_blog/2021/08/26/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/hexo_blog/2021/08/26/html%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="html面试题"><a href="#html面试题" class="headerlink" title="html面试题"></a>html面试题</h1><h2 id="html知识点总结"><a href="#html知识点总结" class="headerlink" title="html知识点总结"></a>html知识点总结</h2><p>平时遇到的面试题的一些总结</p><ol><li><p>对WEB标准以及W3C的理解与认识？</p><blockquote><p>​    </p></blockquote></li><li><p>Doctype作用，HTML5 为什么只需要写 <!DOCTYPE HTML></p><blockquote><div class="hljs code-wrapper"><pre><code>`doctype` 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义`DTD`来解析文档.`&lt;!DOCTYPE&gt;`声明必须是HTML文档的第一行，位于html标签之前`HTML5` 不基于 `SGML`，所以不需要引用 `DTD`。在 `HTML5` 中 `&lt;!DOCTYPE&gt;` 只有一种</code></pre></div><p><code>SGML</code>: 标准通用标记语言,是现时常用的超文本格式的最高层次标准</p></blockquote></li><li><p>行内元素有哪些，块级元素有哪些，空(void)元素有那些</p><blockquote><p>​    </p></blockquote></li><li><p>简述一下你对HTML语义化的理解</p><blockquote><p>​    </p></blockquote></li><li><p>HTML5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p><blockquote><p>​    </p></blockquote></li><li><p>描述一下 cookie，sessionStorage 和 localStorage 的区别</p><blockquote><p>​    </p></blockquote></li><li><p> 如何实现浏览器内多个标签页之间的通信</p></li><li><p>HTML5的离线存储怎么使用，解释一下工作原理</p></li><li><p> src与href的区别</p></li><li><p>表单提交中Get和Post方式的区别</p></li><li><p>iframe有那些缺点？</p></li><li><p>。。。。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从浏览器地址栏输入url到显示页面的步骤 🕸️</title>
    <link href="/hexo_blog/2021/08/13/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <url>/hexo_blog/2021/08/13/url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组的查找 🤺</title>
    <link href="/hexo_blog/2021/08/12/2-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/hexo_blog/2021/08/12/2-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="题目二：二维数组的查找"><a href="#题目二：二维数组的查找" class="headerlink" title="题目二：二维数组的查找"></a>题目二：二维数组的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>Example:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">(2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">(5</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><br><span class="hljs-attr">Output:</span> <span class="hljs-number">7</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">0</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">8</span><br><span class="hljs-attr">Explanation:</span> <span class="hljs-number">342</span> <span class="hljs-string">+</span> <span class="hljs-number">465</span> <span class="hljs-string">=</span> <span class="hljs-number">807</span><span class="hljs-string">.</span><br></code></pre></div></td></tr></table></figure><p><strong>Solve:</strong> </p><h6 id="▉-算法思路："><a href="#▉-算法思路：" class="headerlink" title="▉ 算法思路："></a>▉ 算法思路：</h6><blockquote><p>1）观察 Example 规律，关联到链表，用一个带头的链表存储。</p><p>2）多位数加多位数，反转链表转化整数，如果整数相加，可能会溢出，此方法行不通。</p><p>3）直接进行位数运算，两链表每取出一个就做运算，将结果放入到新链表中。</p></blockquote><h6 id="▉-临界条件："><a href="#▉-临界条件：" class="headerlink" title="▉ 临界条件："></a>▉ 临界条件：</h6><blockquote><p>1）一个链表比另一个链表长；</p><p>2）其中一个链表为 null。</p><p>3）求和运算会出现额外的进位（一般进位与最高位进位两种情况）。</p></blockquote><h6 id="▉-步骤："><a href="#▉-步骤：" class="headerlink" title="▉ 步骤："></a>▉ 步骤：</h6><blockquote><p>1）遍历链表之前，要定义一个哨兵结点、临时结点、存储计算结果的结点、进位标志；</p><p>2）开始遍历数据，判断当前结点是否为 null，为 null 就用 0 代替，否则取出数值；</p><p>3）求和（加 carray 进位），判断是否进位？记录进位值；</p><p>4）求模取余，计算两位数的各位数存储到链表中，指针向后移动；</p><p>5）判断结点是否为 null，继续遍历（如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理）</p><ol start="6"><li>退出 while 循环勿忘最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位，存放到链表最后</li></ol></blockquote><h6 id="▉-代码实现："><a href="#▉-代码实现：" class="headerlink" title="▉ 代码实现："></a>▉ 代码实现：</h6><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 性能分析：</span><br><span class="hljs-comment"> * 1)遍历整个链表，时间复杂度为 O（n）。</span><br><span class="hljs-comment"> * 2)需要额外的 n 大小的空间存储 计算结果结点，空间复杂度为 O(n)。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<br>    <span class="hljs-comment">//定义哨兵结点</span><br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);<br>    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span><br>    <span class="hljs-comment">//存储计算后的链表</span><br>    <span class="hljs-keyword">let</span> sumNode = head;<br>    <span class="hljs-comment">//定义进位变量</span><br>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span><br>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span><br>        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 == <span class="hljs-literal">null</span></span>)</span>&#123;<br>            num1 = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            num1 = l1.val;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 == <span class="hljs-literal">null</span></span>)</span>&#123;<br>            num2 = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            num2 = l2.val;<br>        &#125;<br>        <span class="hljs-comment">// let num1 = l1 == null ? 0 : l1.val;</span><br>        <span class="hljs-comment">// let num2 = l2 == null ? 0 : l2.val;</span><br>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span><br>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;<br>        <span class="hljs-comment">//判断是否需要存储进位值 1</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;<br>           carray = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            carray = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span><br>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)<br>        <span class="hljs-comment">//将指针指向下一链表结点</span><br>        current = current.next;<br>        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果链表 l1 比 l2 短,没有下一结点只能返回本身下次处理当做 null 处理</span><br>            l1 = l1;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>            l2 = l2.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果链表 l2 比 l1 短,没有下一结点只能返回本身下次处理当做 null 处理</span><br>            l2 = l2;<br>        &#125;<br>        <span class="hljs-comment">// l1 为不为 null 才满足条件</span><br>        <span class="hljs-comment">// l1 = l1 ? l1.next : l1;</span><br>        <span class="hljs-comment">// l2 = l2 ? l2.next : l2;</span><br>    &#125;<br>    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;<br>        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回哨兵结点之后的链表</span><br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="▉-代码缩减"><a href="#▉-代码缩减" class="headerlink" title="▉ 代码缩减:"></a>▉ 代码缩减:</h6><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<br>    <span class="hljs-comment">//定义哨兵结点</span><br>    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-string">&quot;head&quot;</span>);<br>    <span class="hljs-keyword">let</span> current = head;<span class="hljs-comment">//临时指针</span><br>    <span class="hljs-comment">//存储计算后的链表</span><br>    <span class="hljs-keyword">let</span> sumNode = head;<br>    <span class="hljs-comment">//定义进位变量</span><br>    <span class="hljs-keyword">let</span> carray = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始遍历两个链表取数据，判断链表是否为 null</span><br>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">l1 !== <span class="hljs-literal">null</span> || l2 !== <span class="hljs-literal">null</span></span>)</span>&#123;<br>        <span class="hljs-comment">//判断取数据的链表是否为nulL,为 null 就用 0 替换</span><br>        <span class="hljs-keyword">let</span> num1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>        <span class="hljs-keyword">let</span> num2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>        <span class="hljs-comment">//计算取出的两个数值的和用于判断是否满进位，如果满 10,carray 需要记录进位,默认为 0</span><br>        <span class="hljs-keyword">let</span> sum = num1 + num2 + carray;<br>        <span class="hljs-comment">//判断是否需要存储进位值 1</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">sum &gt; <span class="hljs-number">9</span></span>)</span>&#123;<br>           carray = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            carray = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//carray = sum &gt; 9 ? 1 : 0;</span><br>        <span class="hljs-comment">//将两数之和相加[取模(取余运算)]添加到 sumNode 新链表中,一次排列</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>)<br>        <span class="hljs-comment">//将指针指向下一链表结点</span><br>        current = current.next;<br>        <span class="hljs-comment">//继续遍历链表中的数据，判断下一结点是否为 null</span><br>        l1 为不为 <span class="hljs-literal">null</span> 才满足条件<br>        l1 = l1 ? l1.next : l1;<br>        l2 = l2 ? l2.next : l2;<br>    &#125;<br>    <span class="hljs-comment">//最高位满位情况,carray 还存放着 1,所以判断最高位是否需要进位</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">carray === <span class="hljs-number">1</span></span>)</span>&#123;<br>        <span class="hljs-comment">//有哨兵的，所以需要 next 才能存放下一结点</span><br>        current.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回哨兵结点之后的链表</span><br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="▉-总结：需要注意几点。"><a href="#▉-总结：需要注意几点。" class="headerlink" title="▉ 总结：需要注意几点。"></a>▉ 总结：需要注意几点。</h6><blockquote><p>1、<code> l1 = l1 ? l1.next : l1</code> 代表的是 l1 不等于 null 会去 l1.next 的值。</p><p>2、用到哨兵思想，所以注意当前的指针指向。</p><p>3、两位数取模运算。</p></blockquote><h6 id="▉-扩展："><a href="#▉-扩展：" class="headerlink" title="▉ 扩展："></a>▉ 扩展：</h6><blockquote><p>三位数怎么取得各个位置上的数字？（水仙花数）</p><p><strong>答：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//移动小数点向前一位，得到小数点后一位</span><br>个位：a = <span class="hljs-number">123</span> % <span class="hljs-number">10</span> = <span class="hljs-number">3</span><br><span class="hljs-comment">//移动小数点向前两位，得到小数点后两位，除以10取整</span><br>十位：b  = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br><span class="hljs-comment">//移动小数点向前三位，得到小数点后三位，除以100取整</span><br>百位:：c = <span class="hljs-built_in">parseInt</span>((<span class="hljs-number">123</span> % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>)<br><span class="hljs-comment">//依次类推.....</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise笔记🤓</title>
    <link href="/hexo_blog/2021/08/12/promise/"/>
    <url>/hexo_blog/2021/08/12/promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise笔记"><a href="#Promise笔记" class="headerlink" title="Promise笔记"></a>Promise笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Promise</code>本质上是一个对象,js的标准内置对象，官方对他的描述就是：Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p><blockquote><p>  面试时相关问题</p></blockquote><div class="hljs code-wrapper"><pre><code>1、了解 Promise 吗？2、Promise 解决的痛点是什么？3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。4、Promise 如何使用？5、Promise 常用的方法有哪些？它们的作用是什么？6、Promise 在事件循环中的执行过程是怎样的？7、Promise 的业界实现都有哪些？8、能不能手写一个 Promise 的 polyfill。</code></pre></div><blockquote><p>用来解决的问题</p></blockquote><p>众所周知，<code>promise</code>解决了js的回调地狱问题(层层调用，嵌套无底洞)</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>diff算法⛏️</title>
    <link href="/hexo_blog/2021/08/11/diff%E7%AE%97%E6%B3%95/"/>
    <url>/hexo_blog/2021/08/11/diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue双向绑定💻</title>
    <link href="/hexo_blog/2021/08/11/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <url>/hexo_blog/2021/08/11/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a>vue双向绑定</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vue的双向绑定&amp;响应式原理是框架的</p><p> ▉ </p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue双向绑定💻</title>
    <link href="/hexo_blog/2021/08/11/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <url>/hexo_blog/2021/08/11/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a>vue双向绑定</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vue的双向绑定&amp;响应式原理是框架的</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组去重💪</title>
    <link href="/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中的10种，面试官很有可能对你刮目相看。<br>在真实的项目中碰到的数组去重，一般都是后台去处理，很少让前端处理数组去重。虽然日常项目用到的概率比较低，但还是需要了解一下，以防面试的时候可能回被问到。</p><p>注：写的匆忙，加上这几天有点忙，还没有非常认真核对过，不过思路是没有问题，可能一些小细节出错而已。</p><h2 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h2><h2 id="一、利用ES6-Set去重（ES6中最常用）"><a href="#一、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="一、利用ES6 Set去重（ES6中最常用）"></a>一、利用ES6 Set去重（ES6中最常用）</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span> (arr) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Set</span>(arr))<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>console.log(<span class="hljs-keyword">unique</span>(arr))<br> //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;&#125;, &#123;&#125;]<br></code></pre></div></td></tr></table></figure><p>不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。</p><h2 id="二、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#二、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="二、利用for嵌套for，然后splice去重（ES5中最常用）"></a>二、利用for嵌套for，然后splice去重（ES5中最常用）</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr)&#123;            <br>        <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>; i&lt;arr.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(var j=i+<span class="hljs-number">1</span>; j&lt;arr.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(arr[i]==arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个<br>                    arr.splice(j,<span class="hljs-number">1</span>);<br>                    j<span class="hljs-comment">--;</span><br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-keyword">return</span> arr;<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>    console.log(<span class="hljs-keyword">unique</span>(arr))<br>    //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //<span class="hljs-keyword">NaN</span>和&#123;&#125;没有去重，两个<span class="hljs-keyword">null</span>直接消失了<br></code></pre></div></td></tr></table></figure><p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。<br>想快速学习更多常用的ES6语法，可以看我之前的文章<a href="https://segmentfault.com/a/1190000016068235">《学习ES6笔记──工作中常用到的ES6语法》</a>。</p><h2 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    var <span class="hljs-keyword">array</span> = [];<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span> .indexOf(arr[i]) === <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">array</span> .push(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>console.log(<span class="hljs-keyword">unique</span>(arr))<br>   // [<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //<span class="hljs-keyword">NaN</span>、&#123;&#125;没有去重<br></code></pre></div></td></tr></table></figure><p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p><h2 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    arr = arr.sort()<br>    var arrry= [arr[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] !== arr[i<span class="hljs-number">-1</span>]) &#123;<br>            arrry.push(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arrry;<br>&#125;<br>     var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>// [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>, &quot;NaN&quot;, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, &quot;true&quot;, undefined]      //<span class="hljs-keyword">NaN</span>、&#123;&#125;没有去重<br></code></pre></div></td></tr></table></figure><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p><h2 id="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"><a href="#五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）" class="headerlink" title="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"></a>五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    var arrry= [];<br>     var  obj = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!obj[arr[i]]) &#123;<br>            arrry.push(arr[i])<br>            obj[arr[i]] = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj[arr[i]]++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arrry;<br>&#125;<br>    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;]    //两个<span class="hljs-keyword">true</span>直接去掉了，<span class="hljs-keyword">NaN</span>和&#123;&#125;去重<br></code></pre></div></td></tr></table></figure><h2 id="六、利用includes"><a href="#六、利用includes" class="headerlink" title="六、利用includes"></a>六、利用includes</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    var <span class="hljs-keyword">array</span> =[];<br>    <span class="hljs-keyword">for</span>(var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>( !<span class="hljs-keyword">array</span>.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值<br>                    <span class="hljs-keyword">array</span>.push(arr[i]);<br>              &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span><br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>    console.log(<span class="hljs-keyword">unique</span>(arr))<br>    //[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重<br></code></pre></div></td></tr></table></figure><h2 id="七、利用hasOwnProperty"><a href="#七、利用hasOwnProperty" class="headerlink" title="七、利用hasOwnProperty"></a>七、利用hasOwnProperty</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    var obj = &#123;&#125;;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">function</span>(item, <span class="hljs-keyword">index</span>, arr)&#123;<br>        <span class="hljs-keyword">return</span> obj.hasOwnProperty(typeof item + item) ? <span class="hljs-keyword">false</span> : (obj[typeof item + item] = <span class="hljs-keyword">true</span>)<br>    &#125;)<br>&#125;<br>    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了<br></code></pre></div></td></tr></table></figure><p>利用hasOwnProperty 判断是否存在对象属性</p><h2 id="八、利用filter"><a href="#八、利用filter" class="headerlink" title="八、利用filter"></a>八、利用filter</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-keyword">filter</span>(<span class="hljs-keyword">function</span>(item, <span class="hljs-keyword">index</span>, arr) &#123;<br>    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素<br>    <span class="hljs-keyword">return</span> arr.indexOf(item, <span class="hljs-number">0</span>) === <span class="hljs-keyword">index</span>;<br>  &#125;);<br>&#125;<br>    var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>        console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, undefined, <span class="hljs-keyword">null</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]<br></code></pre></div></td></tr></table></figure><h2 id="九、利用递归去重"><a href="#九、利用递归去重" class="headerlink" title="九、利用递归去重"></a>九、利用递归去重</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>        var <span class="hljs-keyword">array</span>= arr;<br>        var len = <span class="hljs-keyword">array</span>.length;<br><br>    <span class="hljs-keyword">array</span>.sort(<span class="hljs-keyword">function</span>(a,b)&#123;   //排序后更加方便去重<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;)<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">loop</span>(<span class="hljs-keyword">index</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> &gt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span>] === <span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span><span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-keyword">array</span>.splice(<span class="hljs-keyword">index</span>,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">loop</span>(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);    //递归<span class="hljs-keyword">loop</span>，然后数组去重<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">loop</span>(len<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;<br>&#125;<br> var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;a&quot;, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>, &#123;…&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, undefined]<br></code></pre></div></td></tr></table></figure><h2 id="十、利用Map数据结构去重"><a href="#十、利用Map数据结构去重" class="headerlink" title="十、利用Map数据结构去重"></a>十、利用Map数据结构去重</h2><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> arrayNonRepeatfy(arr) &#123;<br>  let map = <span class="hljs-built_in">new</span> Map();<br>  let <span class="hljs-keyword">array</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Array</span>();  // 数组用于返回结果<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span>(map .has(arr[i])) &#123;  // 如果有该key值<br>      map .<span class="hljs-keyword">set</span>(arr[i], <span class="hljs-keyword">true</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>      map .<span class="hljs-keyword">set</span>(arr[i], <span class="hljs-keyword">false</span>);   // 如果没有该key值<br>      <span class="hljs-keyword">array</span> .push(arr[i]);<br>    &#125;<br>  &#125; <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span> ;<br>&#125;<br> var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>, undefined,undefined, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br>    console.log(<span class="hljs-keyword">unique</span>(arr))<br>//[<span class="hljs-number">1</span>, &quot;a&quot;, &quot;true&quot;, <span class="hljs-keyword">true</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>, &#123;…&#125;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">NaN</span>, <span class="hljs-keyword">NaN</span>, &quot;NaN&quot;, <span class="hljs-number">0</span>, &quot;a&quot;, &#123;…&#125;, undefined]<br></code></pre></div></td></tr></table></figure><p>创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</p><h2 id="十一、利用reduce-includes"><a href="#十一、利用reduce-includes" class="headerlink" title="十一、利用reduce+includes"></a>十一、利用reduce+includes</h2><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">function unique(arr)&#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-params">(prev,cur)</span> =&gt;</span> prev.includes(cur) ? prev : [...prev,cur],[]);<br>&#125;<br>var arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<br><span class="hljs-built_in">console</span>.log(unique(arr));<br><span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">15</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-string">&quot;NaN&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;a&quot;</span>, &#123;…&#125;, &#123;…&#125;]<br></code></pre></div></td></tr></table></figure><h2 id="十二、-…new-Set-arr"><a href="#十二、-…new-Set-arr" class="headerlink" title="十二、[…new Set(arr)]"></a>十二、[…new Set(arr)]</h2><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">[.<span class="hljs-built_in">..new</span> <span class="hljs-keyword">Set</span>(arr)] <br><span class="hljs-comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span><br></code></pre></div></td></tr></table></figure><p>PS：有些文章提到了foreach+indexOf数组去重的方法，个人觉得都是大同小异，所以没有写上去。</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化✊</title>
    <link href="/hexo_blog/2021/08/06/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/hexo_blog/2021/08/06/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化🔓"><a href="#模块化🔓" class="headerlink" title="模块化🔓"></a>模块化🔓</h1><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。参见阮一峰老师的文章 <a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/module-loader">module-loader</a> 。</p><h2 id="一、CommonJS"><a href="#一、CommonJS" class="headerlink" title="一、CommonJS"></a>一、CommonJS</h2><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义模块math.js</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123; <span class="hljs-comment">//在这里写上需要向外暴露的函数、变量</span><br>  add: add,<br>  basicNum: basicNum<br>&#125;<br><br><span class="hljs-comment">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="hljs-keyword">var</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math&#x27;</span>);<br>math.add(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 引用核心模块时，不需要带路径</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br>http.createService(...).listen(<span class="hljs-number">3000</span>);<br>复制代码<br></code></pre></div></td></tr></table></figure><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><h2 id="二、AMD和require-js"><a href="#二、AMD和require-js" class="headerlink" title="二、AMD和require.js"></a>二、AMD和require.js</h2><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">/** 网页中引入<span class="hljs-keyword">require</span>.js及main.js **<span class="hljs-regexp">/</span><br><span class="hljs-regexp">&lt;script src=&quot;js/require</span>.js<span class="hljs-string">&quot; data-main=&quot;</span>js/main<span class="hljs-string">&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">/** main.js 入口文件/主模块 **/</span><br><span class="hljs-string">// 首先用config()指定各模块路径和引用名</span><br><span class="hljs-string">require.config(&#123;</span><br><span class="hljs-string">  baseUrl: &quot;</span>js/<span class="hljs-class"><span class="hljs-keyword">lib</span>&quot;,</span><br>  <span class="hljs-symbol">paths:</span> &#123;<br>    <span class="hljs-string">&quot;jquery&quot;</span>: <span class="hljs-string">&quot;jquery.min&quot;</span>,  <span class="hljs-regexp">//</span>实际路径为js/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">jquery</span>.<span class="hljs-title">min</span>.<span class="hljs-title">js</span></span><br>    <span class="hljs-string">&quot;underscore&quot;</span>: <span class="hljs-string">&quot;underscore.min&quot;</span>,<br>  &#125;<br>&#125;);<br>/<span class="hljs-regexp">/ 执行基本操作</span><br><span class="hljs-regexp">require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;</span><br><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ some code here</span><br><span class="hljs-regexp">&#125;);</span><br><span class="hljs-regexp">复制代码</span><br></code></pre></div></td></tr></table></figure><p>引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 定义math.js模块</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        add: add,<br>        basicNum :basicNum<br>    &#125;;<br>&#125;);<br><span class="hljs-comment">// 定义一个依赖underscore.js的模块</span><br>define([<span class="hljs-string">&#x27;underscore&#x27;</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> classify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">list</span></span>)</span>&#123;<br>    _.countBy(<span class="hljs-keyword">list</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">30</span> ? <span class="hljs-string">&#x27;old&#x27;</span> : <span class="hljs-string">&#x27;young&#x27;</span>;<br>    &#125;)<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>    classify :classify<br>  &#125;;<br>&#125;)<br><br><span class="hljs-comment">// 引用模块，将模块放在[]内</span><br><span class="hljs-keyword">require</span>([<span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-string">&#x27;math&#x27;</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$, math</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> sum = math.add(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>  $(<span class="hljs-string">&quot;#sum&quot;</span>).html(sum);<br>&#125;);<br>复制代码<br></code></pre></div></td></tr></table></figure><h2 id="三、CMD和sea-js"><a href="#三、CMD和sea-js" class="headerlink" title="三、CMD和sea.js"></a>三、CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">define([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c, d, e, f)</span> </span>&#123; <br>    <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>      b.foo()<br>    &#125; <br>&#125;);<br>复制代码<br></code></pre></div></td></tr></table></figure><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/** AMD写法 **/</span><br>define([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e, f</span>) </span>&#123; <br>     <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span><br>    a.doSomething();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>        b.doSomething()<br>    &#125; <br>&#125;);<br><br><span class="hljs-comment">/** CMD写法 **/</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>); <span class="hljs-comment">//在需要时申明</span><br>    a.doSomething();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>);<br>        b.doSomething();<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">/** sea.js **/</span><br><span class="hljs-comment">// 定义模块 math.js</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery.js&#x27;</span>);<br>    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <span class="hljs-built_in">exports</span>.add = add;<br>&#125;);<br><span class="hljs-comment">// 加载模块</span><br>seajs.use([<span class="hljs-string">&#x27;math.js&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sum = math.add(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>);<br>&#125;);<br>复制代码<br></code></pre></div></td></tr></table></figure><h2 id="四、ES6-Module"><a href="#四、ES6-Module" class="headerlink" title="四、ES6 Module"></a>四、ES6 Module</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">/** 定义模块 math.js **/</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br>export &#123; basicNum, add &#125;;<br><br><span class="hljs-comment">/** 引用模块 **/</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> &#123; basicNum, add &#125; from &#x27;./math&#x27;;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">(ele)</span> </span>&#123;<br>    ele.textContent = add(<span class="hljs-number">99</span> + basicNum);<br>&#125;<br>复制代码<br></code></pre></div></td></tr></table></figure><p>如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了<code>export default</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于ADM的引用写法。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/** export default **/</span><br><span class="hljs-comment">//定义输出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; basicNum, add &#125;;<br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">ele</span>) </span>&#123;<br>    ele.textContent = math.add(<span class="hljs-number">99</span> + math.basicNum);<br>&#125;<br>复制代码<br></code></pre></div></td></tr></table></figure><p>ES6的模块不是对象，<code>import</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h2 id="五、-ES6-模块与-CommonJS-模块的差异"><a href="#五、-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="五、 ES6 模块与 CommonJS 模块的差异"></a>五、 ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>原文作者：subwaydown<br>原文链接：<a href="https://juejin.cn/post/6844903576309858318">https://juejin.cn/post/6844903576309858318</a></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC🚓</title>
    <link href="/hexo_blog/2021/08/06/BFC/"/>
    <url>/hexo_blog/2021/08/06/BFC/</url>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p><code>常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</code></p><ul><li>普通流 (normal flow)</li></ul><blockquote><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></blockquote><ul><li>浮动 (float)</li></ul><blockquote><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></blockquote><ul><li>绝对定位 (absolute positioning)</li></ul><blockquote><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p></blockquote><p><strong>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong></p><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p><p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h4 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h4><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h4 id="BFC-特性及应用"><a href="#BFC-特性及应用" class="headerlink" title="BFC 特性及应用"></a>BFC 特性及应用</h4><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>div&#123;<br>    width: 100px;<br>    height: 100px;<br>    background: lightblue;<br>    margin: 100px;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>.container &#123;<br>    overflow: hidden;<br>&#125;<br>p &#123;<br>    width: 100px;<br>    height: 100px;<br>    background: lightblue;<br>    margin: 100px;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这时候，两个盒子边距就变成了 200px</p><p><img src="https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_720w.png" alt="img"></p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>效果如图：</p><p><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, <br>也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组常用api🎇</title>
    <link href="/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/"/>
    <url>/hexo_blog/2021/08/06/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/</url>
    
    <content type="html"><![CDATA[<h1 id="数组常用api✊"><a href="#数组常用api✊" class="headerlink" title="数组常用api✊"></a>数组常用api✊</h1><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组:"></a>创建一个数组:</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> 字面量方式:<br>    <span class="hljs-regexp">//</span> 这个方法也是我们最常用的，在初始化数组的时候 相当方便<br>    var a = [<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>];  <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>];<br>    <span class="hljs-regexp">//</span> 构造器:<br>    <span class="hljs-regexp">//</span> 实际上 new Array === Array,加不加new 一点影响都没有。<br>    var a = Array(); <span class="hljs-regexp">//</span> [] <br>    var a = Array(<span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> [,,] <br>    var a = Array(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> [ <span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span> ]<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="ES6-Array-of-返回由所有参数值组成的数组"><a href="#ES6-Array-of-返回由所有参数值组成的数组" class="headerlink" title="ES6 Array.of()  返回由所有参数值组成的数组"></a>ES6 Array.of()  返回由所有参数值组成的数组</h4><p>定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。</p><p>目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-keyword">let</span> a = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// [3,11,8]</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3]</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="ES6-Arrary-from-将两类对象转为真正的数组"><a href="#ES6-Arrary-from-将两类对象转为真正的数组" class="headerlink" title="ES6 Arrary.from() 将两类对象转为真正的数组"></a>ES6 Arrary.from() 将两类对象转为真正的数组</h4><p>定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。</p><p>参数：</p><p>第一个参数(必需):要转化为真正数组的对象。</p><p>第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。</p><p>第三个参数(可选): 用来绑定this。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 对象拥有length属性<br>    let obj = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>, length: <span class="hljs-number">3</span>&#125;;<br>    let arr = Array.from(obj); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象<br>    let arr = Array.from(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]<br>    let arr = Array.from(new Set([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>])); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h2><p>数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。</p><h3 id="改变原数组的方法-9个"><a href="#改变原数组的方法-9个" class="headerlink" title="改变原数组的方法(9个):"></a>改变原数组的方法(9个):</h3><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">    let a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    ES5:<br>     a.splice()<span class="hljs-regexp">/ a.sort() /</span> a.<span class="hljs-keyword">pop</span>()<span class="hljs-regexp">/ a.shift()/</span>  a.<span class="hljs-keyword">push</span>()<span class="hljs-regexp">/ a.unshift()/</span> a.<span class="hljs-keyword">reverse</span>()<br>    ES6:<br>    a.copyWithin() / a.fill<br>复制代码<br></code></pre></div></td></tr></table></figure><p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。</p><h4 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h4><p>定义： splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p><p>语法： <code>array.splice(index,howmany,item1,.....,itemX)</code></p><p>参数:</p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX： 可选。向数组添加的新项目。</li></ol><p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p><p>eg1:删除元素</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,</span> <span class="hljs-number">3</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从数组下标0开始，删除3个元素</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(-1,</span> <span class="hljs-number">3</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> [<span class="hljs-number">7</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>eg2: 删除并添加</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">     <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,3,&#x27;添加&#x27;);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;添加&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span><br>     <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">b.splice(-2,3,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">console.log(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>eg3: 不删除只添加:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.splice(0,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [] <span class="hljs-string">没有删除元素，返回空数组</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">b.splice(-1,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;);</span> <span class="hljs-string">//</span> [] <span class="hljs-string">没有删除元素，返回空数组</span><br>    <span class="hljs-string">console.log(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;添加1&#x27;</span>,<span class="hljs-string">&#x27;添加2&#x27;</span>,<span class="hljs-number">7</span>] <span class="hljs-string">在最后一个元素的前面添加两个元素</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>从上述三个栗子可以得出:</p><ol><li>数组如果元素不够，会删除到最后一个元素为止</li><li>操作的元素，包括开始的那个元素</li><li>可以添加很多个元素</li><li>添加是在开始的元素前面添加的</li></ol><h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h4><p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p><p>参数可选: 规定排序顺序的比较函数。</p><p>默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> 字符串排列 看起来很正常<br>    var a = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>    a.sort(); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-string">&quot;Mango&quot;</span>,<span class="hljs-string">&quot;Orange&quot;</span>]<br>    <span class="hljs-regexp">//</span> 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的<br>    vara = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>];<br>    console.log(a.sort()) <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>];<br>复制代码<br></code></pre></div></td></tr></table></figure><p><strong>比较函数的两个参数：</strong></p><p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p><ul><li>若比较函数返回值&lt;0，那么a将排到b的前面;</li><li>若比较函数返回值=0，那么a 和 b 相对位置不变；</li><li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li></ul><p>对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章<a href="https://juejin.cn/post/6844903507439419399">深入了解javascript的sort方法</a></p><p><strong>sort排序常见用法</strong>：</p><ol><li><p>数组元素为数字的升序、降序:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"> <span class="hljs-string">var</span> <span class="hljs-string">array</span> <span class="hljs-string">=</span>  [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>,<span class="hljs-number">20</span>,<span class="hljs-number">4</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>]<span class="hljs-string">;</span><br> <span class="hljs-string">//</span> <span class="hljs-string">升序</span> <span class="hljs-string">a-b</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0</span>   <span class="hljs-string">a将排到b的前面，按照a的大小来排序的</span> <br> <span class="hljs-string">//</span> <span class="hljs-string">比如被减数a是10，减数是20</span>  <span class="hljs-number">10</span><span class="hljs-number">-20</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0</span>   <span class="hljs-string">被减数a(10)在减数b(20)前面</span>   <br> <span class="hljs-string">array.sort(function(a,b)&#123;</span><br>   <span class="hljs-string">return</span> <span class="hljs-string">a-b;</span><br> <span class="hljs-string">&#125;);</span><br> <span class="hljs-string">console.log(array);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>]<span class="hljs-string">;</span><br> <span class="hljs-string">//</span> <span class="hljs-string">降序</span> <span class="hljs-string">被减数和减数调换了</span>  <span class="hljs-number">20</span><span class="hljs-number">-10</span><span class="hljs-string">&gt;0</span> <span class="hljs-string">被减数b(20)在减数a(10)的前面</span><br> <span class="hljs-string">array.sort(function(a,b)&#123;</span><br>   <span class="hljs-string">return</span> <span class="hljs-string">b-a;</span><br> <span class="hljs-string">&#125;);</span><br> <span class="hljs-string">console.log(array);</span> <span class="hljs-string">//</span> [<span class="hljs-number">25</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<span class="hljs-string">;</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure></li><li><p>数组多条件排序</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"> var <span class="hljs-keyword">array</span> = [<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span>,age:<span class="hljs-number">2</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">5</span>,age:<span class="hljs-number">4</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">6</span>,age:<span class="hljs-number">10</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">9</span>,age:<span class="hljs-number">6</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">2</span>,age:<span class="hljs-number">8</span>&#125;,<span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span>,age:<span class="hljs-number">9</span>&#125;];<br>     <span class="hljs-keyword">array</span><span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span>(a,b)&#123;<br>         <span class="hljs-keyword">if</span>(a<span class="hljs-built_in">.id</span> === b<span class="hljs-built_in">.id</span>)&#123;// 如<span class="hljs-built_in">果id</span>的值相等，按照age的值降序<br>             <span class="hljs-keyword">return</span> b.age - a.age<br>         &#125;<span class="hljs-keyword">else</span>&#123; // 如<span class="hljs-built_in">果id</span>的值不相等，按<span class="hljs-built_in">照id</span>的值升序<br>             <span class="hljs-keyword">return</span> a<span class="hljs-built_in">.id</span> - b<span class="hljs-built_in">.id</span><br>         &#125;<br>     &#125;)<br>  // [&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">6</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">9</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">2</span>&#125;] <br>复制代码<br></code></pre></div></td></tr></table></figure></li><li><p>自定义比较函数，天空才是你的极限</p></li></ol><p>类似的：<strong>运用好返回值，我们可以写出任意符合自己需求的比较函数</strong></p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery">    var <span class="hljs-keyword">array</span> = [<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;Koro1&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;OB&#x27;</span>&#125;];<br>    <span class="hljs-keyword">array</span><span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span>(a,b)&#123;<br>        <span class="hljs-keyword">if</span>(a<span class="hljs-built_in">.name</span> === <span class="hljs-string">&#x27;Koro1&#x27;</span>)&#123;// 如<span class="hljs-built_in">果name</span>是<span class="hljs-string">&#x27;Koro1&#x27;</span> 返回-<span class="hljs-number">1</span> ，-<span class="hljs-number">1</span>&lt;<span class="hljs-number">0</span> a排在b的前面<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123; // 如果不是的话，a排在b的后面<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>    &#125;)<br>    // [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Koro1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OB&quot;</span>&#125;] <br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h4><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p><p>参数: 无。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.pop();</span>  <span class="hljs-string">//</span> <span class="hljs-number">3</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h4><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p><p>参数: 无。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.shift();</span>  <span class="hljs-string">//</span> <span class="hljs-number">1</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h4><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p>参数:  item1, item2, …, itemX ,要添加到数组末尾的元素</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.push(&#x27;末尾&#x27;);</span>  <span class="hljs-string">//</span> <span class="hljs-number">4</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;末尾&#x27;</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><p>参数:  item1, item2, …, itemX ,要添加到数组开头的元素</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">item</span> <span class="hljs-string">=</span> <span class="hljs-string">a.unshift(&#x27;开头&#x27;);</span>  <span class="hljs-string">//</span> <span class="hljs-number">4</span><br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-string">&#x27;开头&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h4><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p><p>参数: 无</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span>  <span class="hljs-string">a</span> <span class="hljs-string">=</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">a.reverse();</span>  <br>    <span class="hljs-string">console.log(a);</span> <span class="hljs-string">//</span> [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="ES6-copyWithin-指定位置的成员复制到其他位置"><a href="#ES6-copyWithin-指定位置的成员复制到其他位置" class="headerlink" title="ES6: copyWithin() 指定位置的成员复制到其他位置"></a>ES6: copyWithin() 指定位置的成员复制到其他位置</h4><p>定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.copy<span class="hljs-constructor">Within(<span class="hljs-params">target</span>, <span class="hljs-params">start</span> = 0, <span class="hljs-params">end</span> = <span class="hljs-params">this</span>.<span class="hljs-params">length</span>)</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>三个参数都是数值，如果不是，会自动转为数值.</p><ol><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。</li></ol><p>浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持</p><p>eg:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">        <span class="hljs-regexp">//</span> -<span class="hljs-number">2</span>相当于<span class="hljs-number">3</span>号位，-<span class="hljs-number">1</span>相当于<span class="hljs-number">4</span>号位<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)<br>        <span class="hljs-regexp">//</span> [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>        var a=[<span class="hljs-string">&#x27;OB1&#x27;</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-string">&#x27;OB2&#x27;</span>,<span class="hljs-string">&#x27;Koro2&#x27;</span>,<span class="hljs-string">&#x27;OB3&#x27;</span>,<span class="hljs-string">&#x27;Koro3&#x27;</span>,<span class="hljs-string">&#x27;OB4&#x27;</span>,<span class="hljs-string">&#x27;Koro4&#x27;</span>,<span class="hljs-string">&#x27;OB5&#x27;</span>,<span class="hljs-string">&#x27;Koro5&#x27;</span>]<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>位置开始被替换,<span class="hljs-number">3</span>位置开始读取要替换的 <span class="hljs-number">5</span>位置前面停止替换<br>        a.copyWithin(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>        <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;OB1&quot;</span>,<span class="hljs-string">&quot;Koro1&quot;</span>,<span class="hljs-string">&quot;Koro2&quot;</span>,<span class="hljs-string">&quot;OB3&quot;</span>,<span class="hljs-string">&quot;OB3&quot;</span>,<span class="hljs-string">&quot;Koro3&quot;</span>,<span class="hljs-string">&quot;OB4&quot;</span>,<span class="hljs-string">&quot;Koro4&quot;</span>,<span class="hljs-string">&quot;OB5&quot;</span>,<span class="hljs-string">&quot;Koro5&quot;</span>] <br>复制代码<br></code></pre></div></td></tr></table></figure><p>从上述栗子:</p><ol><li>第一个参数是开始被替换的元素位置</li><li>要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取</li><li>数组的长度不会改变</li><li><strong>读了几个元素就从开始被替换的地方替换几个元素</strong></li></ol><h4 id="ES6-fill-填充数组"><a href="#ES6-fill-填充数组" class="headerlink" title="ES6: fill() 填充数组"></a>ES6: fill() 填充数组</h4><p>定义:  使用给定值，填充一个数组。</p><p>参数:</p><p>第一个元素(必须): 要填充数组的值</p><p>第二个元素(可选): 填充的开始位置,默认值为0</p><p>第三个元素(可选)：填充的结束位置，默认是为<code>this.length</code></p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill%23%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">MDN浏览器兼容</a></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].fill(<span class="hljs-number">7</span>)<br>    <span class="hljs-regexp">//</span> [<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]<br>    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].fill(<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><hr><h3 id="不改变原数组的方法-8个"><a href="#不改变原数组的方法-8个" class="headerlink" title="不改变原数组的方法(8个):"></a>不改变原数组的方法(8个):</h3><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">    ES5：<br>    slice、<span class="hljs-keyword">join</span>、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、<br>    ES7：<br>    <span class="hljs-keyword">includes</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h4><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p><p><strong>注意</strong>：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。</p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">    <span class="hljs-keyword">array</span>.<span class="hljs-keyword">slice</span>(<span class="hljs-keyword">begin</span>, <span class="hljs-keyword">end</span>);<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。</p><p>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</p><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">    let a= [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];<br>    let b=a.slice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); // [<span class="hljs-string">&#x27;hello&#x27;</span>]<br>    a[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;改变原数组&#x27;</span>;<br>    console.log(a,b); // [<span class="hljs-string">&#x27;改变原数组&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>] [<span class="hljs-string">&#x27;hello&#x27;</span>]<br>    b[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;改变拷贝的数组&#x27;</span>;<br>     console.log(a,b); // [<span class="hljs-string">&#x27;改变原数组&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>] [<span class="hljs-string">&#x27;改变拷贝的数组&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><p>如上：新数组是浅拷贝的，<strong>元素是简单数据类型，改变之后不会互相干扰</strong>。</p><p>如果是<strong>复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变</strong>。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a= [&#123;name:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;];<br>    let b=a.slice();<br>    console.log(b,a); <span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OBKoro1&quot;</span>&#125;]  [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;OBKoro1&quot;</span>&#125;]<br>    <span class="hljs-regexp">//</span> a[<span class="hljs-number">0</span>].name=<span class="hljs-string">&#x27;改变原数组&#x27;</span>;<br>    <span class="hljs-regexp">//</span> console.log(b,a); <span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变原数组&quot;</span>&#125;] [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变原数组&quot;</span>&#125;]<br>    <span class="hljs-regexp">//</span> b[<span class="hljs-number">0</span>].name=<span class="hljs-string">&#x27;改变拷贝数组&#x27;</span>,b[<span class="hljs-number">0</span>].koro=<span class="hljs-string">&#x27;改变拷贝数组&#x27;</span>;<br>    <span class="hljs-regexp">//</span>  [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>,<span class="hljs-string">&quot;koro&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>&#125;] [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>,<span class="hljs-string">&quot;koro&quot;</span>:<span class="hljs-string">&quot;改变拷贝数组&quot;</span>&#125;]<br>复制代码<br></code></pre></div></td></tr></table></figure><p>原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。</p><h4 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join()  数组转字符串"></a>join()  数组转字符串</h4><p>定义:  join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p><p>语法:</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">    array.<span class="hljs-keyword">join</span>(<span class="hljs-built_in">str</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">let</span> a= [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];<br>    <span class="hljs-keyword">let</span> str=a.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// &#x27;hello,world&#x27;</span><br>    <span class="hljs-keyword">let</span> str2=a.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;+&#x27;</span>); <span class="hljs-comment">// &#x27;hello+world&#x27;</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">let</span> a= [[<span class="hljs-string">&#x27;OBKoro1&#x27;</span>,<span class="hljs-string">&#x27;23&#x27;</span>],<span class="hljs-string">&#x27;test&#x27;</span>];<br>    <span class="hljs-keyword">let</span> str1=a.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// OBKoro1,23,test</span><br>    <span class="hljs-keyword">let</span> b= [&#123;name:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>,age:<span class="hljs-string">&#x27;23&#x27;</span>&#125;,<span class="hljs-string">&#x27;test&#x27;</span>];<br>    <span class="hljs-keyword">let</span> str2 = b.<span class="hljs-keyword">join</span>(); <span class="hljs-comment">// [object Object],test</span><br>    <span class="hljs-comment">// 对象转字符串推荐JSON.stringify(obj);</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>所以，<code>join()/toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用<code>join()/toString()</code>,如果是对象的话，对象会被转为<code>[object Object]</code>字符串。</p><h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：无。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">    <span class="hljs-keyword">let</span> a=[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;abcd&#x27;</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()];<br>    <span class="hljs-keyword">let</span> str=a.toLocaleString(); <span class="hljs-comment">// [object Object],23,abcd,2018/5/28 下午1:52:20 </span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>如上述栗子：调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的<code>toLocaleString</code>方法，对象调用对象的<code>toLocaleString</code>,Date调用Date的<code>toLocaleString</code>。</p><h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a>toString() 数组转字符串 不推荐</h4><p>定义: toString() 方法可把数组转换为由逗号链接起来的字符串。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数: 无。</p><p>该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p><p><strong>值得注意的是</strong>：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">   let b= [ <span class="hljs-string">&#x27;toString&#x27;</span>,<span class="hljs-string">&#x27;演示&#x27;</span>].toString(); <span class="hljs-regexp">//</span> toString,演示<br>   let a= [<span class="hljs-string">&#x27;调用toString&#x27;</span>,<span class="hljs-string">&#x27;连接在我后面&#x27;</span>]+<span class="hljs-string">&#x27;啦啦啦&#x27;</span>; <span class="hljs-regexp">//</span> 调用toString,连接在我后面啦啦啦<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="cancat"><a href="#cancat" class="headerlink" title="cancat"></a>cancat</h4><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p><p>语法：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    var newArr =oldArray.concat(<span class="hljs-built_in">array</span>X,<span class="hljs-built_in">array</span>X,......,<span class="hljs-built_in">array</span>X)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：</p><p>arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p><p>eg1:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">//连接两个数组</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">newVal=a.concat(b);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">连接三个数组</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">c</span> <span class="hljs-string">=</span> [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>    <span class="hljs-string">let</span> <span class="hljs-string">newVal2</span> <span class="hljs-string">=</span> <span class="hljs-string">a.concat(b,</span> <span class="hljs-string">c);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>    <span class="hljs-string">//</span> <span class="hljs-string">添加元素</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">newVal3</span> <span class="hljs-string">=</span> <span class="hljs-string">a.concat(&#x27;添加元素&#x27;,b,</span> <span class="hljs-string">c,&#x27;再加一个&#x27;);</span> <br>    <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;添加元素&quot;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&quot;再加一个&quot;</span>]<br>   <span class="hljs-string">//</span> <span class="hljs-string">合并嵌套数组</span>  <span class="hljs-string">会浅拷贝嵌套数组</span><br>   <span class="hljs-string">let</span> <span class="hljs-string">d</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span> ]<span class="hljs-string">;</span><br>   <span class="hljs-string">let</span> <span class="hljs-string">f</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>]]<span class="hljs-string">;</span><br>   <span class="hljs-string">let</span> <span class="hljs-string">newVal4</span> <span class="hljs-string">=</span> <span class="hljs-string">d.concat(f);</span> <span class="hljs-string">//</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>]]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p><strong>ES6扩展运算符<code>...</code>合并数组</strong>：</p><p>因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用<code>...</code>来处理，<code>...</code>运算符可以实现<code>cancat</code>的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>    <span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> [ <span class="hljs-number">4</span>,<span class="hljs-string">...a</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<br>    <span class="hljs-string">console.log(a,b);</span> <span class="hljs-string">//</span>  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><p>更多关于扩展符的详细内容移步阮一峰大神的<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">ECMAScript 6 入门</a></p><h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.index<span class="hljs-constructor">Of(<span class="hljs-params">searchElement</span>,<span class="hljs-params">fromIndex</span>)</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p><p>严格相等的搜索:</p><p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p><p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p><p>eg:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">    let <span class="hljs-keyword">a</span>=[<span class="hljs-string">&#x27;啦啦&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">24</span>,NaN]<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;啦&#x27;</span>)); <span class="hljs-comment"> // -1 </span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;NaN&#x27;</span>)); <span class="hljs-comment"> // -1 </span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>.indexOf(<span class="hljs-string">&#x27;啦啦&#x27;</span>));<span class="hljs-comment"> // 0</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>使用场景：</p><ol><li><a href="https://juejin.cn/post/6844903577421365255#heading-10">数组去重</a></li><li>根据获取的数组下标执行操作，改变数组中的值等。</li><li>判断是否存在，执行操作。</li></ol><h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><p>定义:  方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    arr.last<span class="hljs-constructor">IndexOf(<span class="hljs-params">searchElement</span>,<span class="hljs-params">fromIndex</span>)</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>searchElement(必须): 被查找的元素</p><p>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</p><p>关于fromIndex有三个规则:</p><ol><li><p>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</p></li><li><p>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</p></li><li><p>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"> let a=[<span class="hljs-string">&#x27;OB&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>]; <span class="hljs-regexp">//</span> 数组长度为<span class="hljs-number">10</span><br> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 从下标<span class="hljs-number">4</span>开始往前找 返回下标<span class="hljs-number">2</span><br> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-regexp">//</span>  大于或数组的长度 查找整个数组 返回<span class="hljs-number">9</span><br> <span class="hljs-regexp">//</span> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">11</span>); <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span> 数组不会被查找<br> let b=a.lastIndexOf(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">9</span>); <span class="hljs-regexp">//</span> 从第二个元素<span class="hljs-number">4</span>往前查找，没有找到 返回-<span class="hljs-number">1</span><br>复制代码<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h4><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p><p>语法：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-built_in">array</span>.includes(searchElement,fromIndex=<span class="hljs-number">0</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p><p><strong>includes方法是为了弥补indexOf方法的缺陷而出现的:</strong></p><ol><li>indexOf方法不能识别<code>NaN</code></li><li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于<code>-1</code>，表达不够直观</li></ol><p>eg:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a=[<span class="hljs-string">&#x27;OB&#x27;</span>,<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">1</span>,NaN];<br>    <span class="hljs-regexp">//</span> let b=a.includes(NaN); <span class="hljs-regexp">//</span> true 识别NaN<br>    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-regexp">//</span> false 超过数组长度 不搜索<br>    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">3</span>);  <span class="hljs-regexp">//</span> true 从倒数第三个元素开始搜索 <br>    <span class="hljs-regexp">//</span> let b=a.includes(<span class="hljs-string">&#x27;Koro1&#x27;</span>,-<span class="hljs-number">100</span>);  <span class="hljs-regexp">//</span> true 负值绝对值超过数组长度，搜索整个数组<br>复制代码<br></code></pre></div></td></tr></table></figure><p>兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。</p><hr><h3 id="遍历方法-12个"><a href="#遍历方法-12个" class="headerlink" title="遍历方法(12个):"></a>遍历方法(12个):</h3><p>js中遍历数组并不会改变原始数组的方法总共有12个:</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">    ES5：<br>    forEach、every 、some、 <span class="hljs-built_in">filter</span>、<span class="hljs-keyword">map</span>、reduce、reduceRight、<br>    ES6：<br>    <span class="hljs-keyword">find</span>、findIndex、<span class="hljs-built_in">keys</span>、<span class="hljs-built_in">values</span>、entries<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="关于遍历："><a href="#关于遍历：" class="headerlink" title="关于遍历："></a>关于遍历：</h4><ul><li>关于遍历的效率，可以看一下这篇<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2015/12/18/traverse/%23%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87">详解JS遍历</a></li><li>尽量不要在遍历的时候，修改后面要遍历的值</li><li>尽量不要在遍历的时候修改数组的长度（删除/添加）</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>定义: 按升序为数组中含有效值的每一项执行一次回调函数。</p><p>语法：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">    <span class="hljs-built_in">array</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">currentValue</span>, <span class="hljs-params">index</span>, <span class="hljs-params">arr</span>)</span>, thisValue)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p><strong>关于forEach()你要知道</strong>：</p><ul><li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 undefined值,即使你return了一个值。</li></ul><h4 id="下面类似语法同样适用这些规则"><a href="#下面类似语法同样适用这些规则" class="headerlink" title="下面类似语法同样适用这些规则"></a>下面类似语法同样适用这些规则</h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-number">1.</span> 对于空数组是不会执行回调函数的<br>    <span class="hljs-number">2.</span> 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数<br>    <span class="hljs-number">3.</span> 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。<br>    <span class="hljs-number">4.</span> 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。<br>复制代码<br></code></pre></div></td></tr></table></figure><p>eg:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ,<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 最后第二个元素是空的，不会遍历(undefined、null会遍历)<br>    let obj = &#123; name: <span class="hljs-string">&#x27;OBKoro1&#x27;</span> &#125;;<br>    let result = a.forEach(<span class="hljs-keyword">function</span> (value, index, array) &#123; <br>      a[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;改变元素&#x27;</span>;<br>      a.push(<span class="hljs-string">&#x27;添加到尾端，不会被遍历&#x27;</span>)<br>      console.log(value, <span class="hljs-string">&#x27;forEach传递的第一个参数&#x27;</span>); <span class="hljs-regexp">//</span> 分别打印 <span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,改变元素<br>      console.log(this.name); <span class="hljs-regexp">//</span> OBKoro1 打印三次 this绑定在obj对象上<br>      <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>会报错<br>      return value; <span class="hljs-regexp">//</span> return只能结束本次回调 会执行下次回调<br>      console.log(<span class="hljs-string">&#x27;不会执行，因为return 会执行下一次循环回调&#x27;</span>)<br>    &#125;, obj);<br>    console.log(result); <span class="hljs-regexp">//</span> 即使return了一个值,也还是返回undefined<br>    <span class="hljs-regexp">//</span> 回调函数也接受接头函数写法<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a>every 检测数组所有元素是否都符合判断条件</h4><p>定义: 方法用于检测数组所有元素是否都符合函数定义的条件</p><p>语法：</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.every(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>, <span class="hljs-title">thisValue</span>)</span><br><span class="hljs-function">复制代码</span><br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>方法返回值规则:</p><ol><li>如果数组中检测到<strong>有一个元素不满足，则整个表达式返回 false</strong>，且剩余的元素不会再进行检测。</li><li>如果所有元素<strong>都满足条件，则返回 true</strong>。=</li></ol><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">function</span> <span class="hljs-string">isBigEnough(element,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123; <br>      <span class="hljs-string">return</span> <span class="hljs-string">element</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">判断数组中的所有元素是否都大于10</span><br>    &#125;<br>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(isBigEnough);</span>   <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">接受箭头函数写法</span> <br>    [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(x</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br>    [<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<span class="hljs-string">.every(x</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a>some 数组中的是否有满足判断条件的元素</h4><p>定义：数组中的是否有满足判断条件的元素</p><p>语法：</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.some(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(currentValue, <span class="hljs-keyword">index</span>, arr)</span>, <span class="hljs-title">thisValue</span>)</span><br><span class="hljs-function">复制代码</span><br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>方法返回值规则：</p><ol><li><p>如果<strong>有一个元素满足条件，则表达式返回true</strong>, 剩余的元素不会再执行检测。</p></li><li><p>如果<strong>没有满足条件的元素，则返回false</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"> <span class="hljs-string">function</span> <span class="hljs-string">isBigEnough(element,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;<br>   <span class="hljs-string">return</span> <span class="hljs-string">(element</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">10</span><span class="hljs-string">);</span> <span class="hljs-string">//数组中是否有一个元素大于</span> <span class="hljs-number">10</span><br> &#125;<br> <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-string">.some(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br> <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-string">.some(isBigEnough);</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure></li></ol><h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><p>语法：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">     <span class="hljs-string">let</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>]<span class="hljs-string">;</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-string">a.filter(function</span> <span class="hljs-string">(value,</span> <span class="hljs-string">index,</span> <span class="hljs-string">array)</span> &#123;<br>      <span class="hljs-string">return</span> <span class="hljs-string">value</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">18</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">返回a数组中所有大于18的元素</span><br>    &#125;<span class="hljs-string">);</span><br>    <span class="hljs-string">console.log(result,a);//</span> [<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">40</span>] [<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">16</span>,<span class="hljs-number">40</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><p>语法：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>eg:</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>];<br><span class="hljs-keyword">let</span> result = a.<span class="hljs-keyword">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-keyword">value</span>, index, <span class="hljs-keyword">array</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> + <span class="hljs-string">&#x27;新数组的新元素&#x27;</span><br>&#125;);<br>console.log(result, a); <br>// [<span class="hljs-string">&quot;1新数组的新元素&quot;</span>,<span class="hljs-string">&quot;2新数组的新元素&quot;</span>,<span class="hljs-string">&quot;3新数组的新元素&quot;</span>,<span class="hljs-string">&quot;4新数组的新元素&quot;</span>] [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><p>定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。</p><p>语法：</p><figure class="highlight delphi"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs delphi">    <span class="hljs-keyword">array</span>.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(total, currentValue, currentIndex, arr)</span>, <span class="hljs-title">initialValue</span>)</span><br><span class="hljs-function">复制代码</span><br></code></pre></div></td></tr></table></figure><p>参数：</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> total(必须)，初始值, 或者上一次调用回调返回的值<br>    <span class="hljs-number">2.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">3.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">4.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>initialValue(可选): 指定第一次回调 的第一个参数。</p><p>回调第一次执行时:</p><ul><li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li><li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li><li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li></ul><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">    <span class="hljs-string">//</span> <span class="hljs-string">数组求和</span> <br>    <span class="hljs-string">let</span> <span class="hljs-string">sum</span> <span class="hljs-string">=</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.reduce(function</span> <span class="hljs-string">(a,</span> <span class="hljs-string">b)</span> &#123;<br>      <span class="hljs-string">return</span> <span class="hljs-string">a</span> <span class="hljs-string">+</span> <span class="hljs-string">b;</span><br>    &#125;<span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">);</span><br>    <span class="hljs-string">//</span> <span class="hljs-number">6</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">将二维数组转化为一维</span> <span class="hljs-string">将数组元素展开</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">flattened</span> <span class="hljs-string">=</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-string">.reduce(</span><br>      <span class="hljs-string">(a,</span> <span class="hljs-string">b)</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">a.concat(b),</span><br>      []<br>    <span class="hljs-string">);</span><br>     <span class="hljs-string">//</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-string">复制代码</span><br></code></pre></div></td></tr></table></figure><h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight  从右至左累加"></a>reduceRight  从右至左累加</h4><p>这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p><h4 id="ES6：find-amp-findIndex-根据条件找到数组成员"><a href="#ES6：find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6：find()&amp; findIndex() 根据条件找到数组成员"></a>ES6：find()&amp; findIndex() 根据条件找到数组成员</h4><p>find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。</p><p>findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><p>这两个方法</p><p>语法：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">    let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>     let <span class="hljs-keyword">new</span><span class="hljs-type">_array</span> = arr.findIndex(<span class="hljs-function"><span class="hljs-keyword">function</span></span>(currentValue, index, arr), thisArg)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">    <span class="hljs-comment">// 回调函数的参数</span><br>    <span class="hljs-number">1.</span> currentValue(必须),数组当前元素的值<br>    <span class="hljs-number">2.</span> index(可选), 当前元素的索引值<br>    <span class="hljs-number">3.</span> arr(可选),数组对象本身<br>复制代码<br></code></pre></div></td></tr></table></figure><p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p><p>这两个方法都可以识别<code>NaN</code>,弥补了<code>indexOf</code>的不足.</p><p>eg:</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">        <span class="hljs-comment">// find</span><br>        let a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>].find((n) =&gt; n &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回元素-5</span><br>        let b = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>,NaN].find((n) =&gt; Object.<span class="hljs-keyword">is</span>(NaN, n));  <span class="hljs-comment">// 返回元素NaN</span><br>        <span class="hljs-comment">// findIndex</span><br>        let a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>].findIndex((n) =&gt; n &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回索引2</span><br>        let b = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">10</span>,NaN].findIndex((n) =&gt; Object.<span class="hljs-keyword">is</span>(NaN, n));  <span class="hljs-comment">// 返回索引4</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,</p><h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</h4><p>定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p><p>语法：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">    <span class="hljs-built_in">array</span>.keys()<br>    <span class="hljs-built_in">array</span>.<span class="hljs-built_in">values</span>()<br>    <span class="hljs-built_in">array</span>.entries()<br>复制代码<br></code></pre></div></td></tr></table></figure><p>参数：无。</p><p>遍历栗子(摘自<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values">ECMAScript 6 入门</a>)：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    <span class="hljs-keyword">for</span> (let index of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].keys()) &#123;<br>      console.log(index);<br>    &#125;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> (let elem of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].values()) &#123;<br>      console.log(elem);<br>    &#125;<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;b&#x27;</span><br>    <br>    <span class="hljs-keyword">for</span> (let [index, elem] of [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].entries()) &#123;<br>      console.log(index, elem);<br>    &#125;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span> <span class="hljs-string">&quot;a&quot;</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <span class="hljs-string">&quot;b&quot;</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</p><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的next方法，进行遍历:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">    let letter = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>    let entries = letter.entries();<br>    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br>    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br>    console.log(entries.<span class="hljs-keyword">next</span>().value); <span class="hljs-regexp">//</span> [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>复制代码<br></code></pre></div></td></tr></table></figure><p>entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1</p><p>keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,</p><p><strong>注意</strong>:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现</p><hr>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>let和const</title>
    <link href="/hexo_blog/2021/07/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/hexo_blog/2021/07/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章涉及3个知识点，var，let，const</p><h3 id="var-命令"><a href="#var-命令" class="headerlink" title="var 命令"></a>var 命令</h3><blockquote><p>​    JavaScript中，我们通常说的作用域是函数作用域，使用var声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p><p>也就是说，如果在函数内部声明的变量，都会被提升到该函数开头，而在全局声明的变量，就会提升到全局作用域的顶部。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>&#125;<br><br>test()<br></code></pre></div></td></tr></table></figure><blockquote><p>实际执行时，上面的代码中的变量a会提升到函数顶部声明，即使if语句的条件是false，也一样不影响a变量提升。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a<br>    <span class="hljs-comment">//a声明没有赋值</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      a = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">//a声明没有赋值</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3: &#x27;</span>, a) <span class="hljs-comment">//undefined</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>在函数嵌套函数的场景下，变量只会提升到最近的一个函数顶部，而不会提升到外部函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//b提升到函数a顶部，但不会提升到函数test。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>          &#125;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b: &#x27;</span>, b)<br>    &#125;<br>    <br>    test() <span class="hljs-comment">//b is not defined</span><br></code></pre></div></td></tr></table></figure><blockquote><p>如果a没有声明，那么就会报错，<strong>没有声明和声明后没有赋值是不一样的</strong>，这点一定要区分开，有助于我们找bug。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">//a没有声明的情况</span><br>   a <span class="hljs-keyword">is</span> not defined<br></code></pre></div></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p>let和const都能够声明块级作用域，用法和var是类似的，let的特点是不会变量提升，而是被锁在当前块中。</p><p>一个非常简单的例子：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//TDZ，俗称临时死区，用来描述变量不提升的现象</span><br>      <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br>test()  <span class="hljs-comment">// a is not defined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(a)<br>&#125;    <br>test() <span class="hljs-comment">// a is not defined</span><br></code></pre></div></td></tr></table></figure><blockquote><p>唯一正确的使用方法：<strong>先声明，再访问。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;<br>          <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>          <span class="hljs-built_in">console</span>.log(a)<br>        &#125;<br>    &#125;<br>    test() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><blockquote><p>声明常量，一旦声明，不可更改，而且常量必须初始化赋值。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">const<span class="hljs-built_in"> type </span>= <span class="hljs-string">&quot;ACTION&quot;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>我们试试重新声明type，看看会报什么错：</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">const <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;ACTION&quot;</span><br>    <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">type</span>) //<span class="hljs-string">&quot;type&quot;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span><br>    <br>    const <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;ACTION&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">type</span>) //Duplicate declaration <span class="hljs-string">&quot;type&quot;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>​    const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值包括新增删除键值对也是可以的。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">const <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= &#123;<br>      a: <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">type</span>.a = <span class="hljs-number">2</span> <span class="hljs-comment">//没有直接修改type的值，而是修改type.a的属性值，这是允许的。</span><br>    console.log(<span class="hljs-class"><span class="hljs-keyword">type</span>) <span class="hljs-comment">// &#123;a: 2&#125;</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    <span class="hljs-title">type</span>.<span class="hljs-title">b</span> </span>= <span class="hljs-number">3</span> <span class="hljs-comment">//拓展Object也是没有问题的</span><br>    console.log(<span class="hljs-class"><span class="hljs-keyword">type</span>) <span class="hljs-comment">// &#123;a: 2 , b: 3&#125;</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    <span class="hljs-title">delete</span> <span class="hljs-title">type</span>.<span class="hljs-title">b=3</span> <span class="hljs-comment">//删除整个键值对也OK的</span></span><br><span class="hljs-class">    <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-params">type</span>) <span class="hljs-comment">// &#123;a: 2&#125;</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    <span class="hljs-comment">//如果重新定义数据结构~常量的内存地址值发生改变,这个是不可行的。</span></span><br><span class="hljs-class">    <span class="hljs-title">type=</span></span>&#123;&#125;; <span class="hljs-comment">//Assignment to constant variable.</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span></span>=[]; <span class="hljs-comment">//Assignment to constant variable.</span><br></code></pre></div></td></tr></table></figure><h3 id="const和let的异同点"><a href="#const和let的异同点" class="headerlink" title="const和let的异同点"></a>const和let的异同点</h3><blockquote><p><strong>相同点：</strong>const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升，不能重复声明。</p><p><strong>不同点：</strong>const不能再赋值，let声明的变量可以重复赋值。</p></blockquote><h3 id="块级作用域的使用场景"><a href="#块级作用域的使用场景" class="headerlink" title="块级作用域的使用场景"></a>块级作用域的使用场景</h3><blockquote><p>​    除了上面提到的常用声明方式，我们还可以在循环中使用，最出名的一道面试题：循环中定时器闭包的考题</p><p>在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//5, 5, 5, 5, 5</span><br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//5 i跳出循环体污染外部函数</span><br>    <br>    <span class="hljs-comment">//将var改成let之后</span><br>    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 0,1,2,3,4</span><br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">//i is not defined i无法污染外部函数</span><br></code></pre></div></td></tr></table></figure><p><code>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了</code></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>节流防抖🗽</title>
    <link href="/hexo_blog/2021/05/21/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <url>/hexo_blog/2021/05/21/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h3 id="节流防抖🗽"><a href="#节流防抖🗽" class="headerlink" title="节流防抖🗽"></a>节流防抖🗽</h3><ul><li><p>定义🎉🎉🎉：</p><ul><li><strong>防抖：</strong>在任务高频率触发时，只有触发间隔超过制定间隔的任务才会执行。即一个动作连续触发则只执行最后一次。防抖的原理则是不管你在一段时间内如何不停的触发事件，只要设置了防抖，则只在触发n秒后才执行。如果我们在一个事件触发的n秒内又触发了相同的事件，那我们便以新的事件时间为标准，n秒之后再执行。</li></ul></li></ul><div class="hljs code-wrapper"><pre><code><figure class="highlight js"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = flase;<br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">// 清除未执行的定时器（如果之前已经触发过不到300毫秒又触发了一次则清除之前的）重置回初始化状态</span><br>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;函数防抖&quot;</span>)<br>  &#125;, <span class="hljs-number">300</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure></code></pre><ul><li><p><strong>节流：</strong>在制定间隔内任务只执行1次。节流的原理是不管你在一段时间内如何不停地触发事件，只要设置了节流，就会每隔一段时间执行一次。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>;<br>  canRun = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数节流&#x27;</span>)<br>    canRun = <span class="hljs-literal">true</span><br>  &#125;, <span class="hljs-number">300</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure></li></ul><div class="hljs code-wrapper"><pre><code>&lt;img src=&quot;C:\Users\l&#39;x\AppData\Roaming\Typora\typora-user-images\image-20210521162630790.png&quot; alt=&quot;image-20210521162630790&quot; style=&quot;zoom:50%;&quot; /&gt;</code></pre></div><h3 id="原理📣"><a href="#原理📣" class="headerlink" title="原理📣"></a>原理📣</h3><blockquote><p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p></blockquote><blockquote><p>如： 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p></blockquote><p>  <strong>手写简化版🚔</strong></p>  <figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><br><span class="hljs-comment">// wait是等待时间</span><br><span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 缓存一个定时器id</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 这里返回的函数是每次用户实际调用的防抖函数</span><br>  <span class="hljs-comment">// 如果已经设定过定时器了就清空上一次的定时器</span><br>  <span class="hljs-comment">// 开始一个新的定时器，延迟执行用户传入的方法</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.apply(<span class="hljs-built_in">this</span>, args)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p></blockquote><blockquote><p>例:（连续不断动都需要调用时用，设一时间间隔），像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多</p></blockquote><p>  <strong>手写简版🚔</strong></p>  <figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><br><span class="hljs-comment">// wait是等待时间</span><br><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">func, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 上一次执行该函数的时间</span><br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-comment">// 当前时间</span><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    <span class="hljs-comment">// 将当前时间和上一次执行函数时间对比</span><br>    <span class="hljs-comment">// 如果差值大于设置的等待时间就执行函数</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt; wait) &#123;<br>      lastTime = now<br>      func.apply(<span class="hljs-built_in">this</span>, args)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(<br>  throttle(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  &#125;, <span class="hljs-number">500</span>),<br>  <span class="hljs-number">1</span><br>)<br></code></pre></div></td></tr></table></figure><h3 id="函数防抖的应用场景🎟️"><a href="#函数防抖的应用场景🎟️" class="headerlink" title="函数防抖的应用场景🎟️"></a>函数防抖的应用场景🎟️</h3><p>  连续的事件，只需触发一次回调的场景有：</p><ul><li><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求</p></li><li><p>手机号、邮箱验证输入检测</p></li><li><p>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p><h3 id="函数节流的应用场景🎟️"><a href="#函数节流的应用场景🎟️" class="headerlink" title="函数节流的应用场景🎟️"></a>函数节流的应用场景🎟️</h3><p>间隔一段时间执行一次回调的场景有：</p></li><li><p>滚动加载，加载更多或滚到底部监听</p></li><li><p>谷歌搜索框，搜索联想功能</p></li><li><p>高频点击提交，表单重复提交</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>get和post请求🍺</title>
    <link href="/hexo_blog/2021/05/11/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <url>/hexo_blog/2021/05/11/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>变量声明</p><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><blockquote><p>用法类似var，但是let只在<code>let</code>命令所在的代码块内有效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><br>a <span class="hljs-comment">// ReferenceError: a is not defined.</span><br>b <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><blockquote><p>可用于for内部变量循环，var变量在预编译的时候会发生变量提升，而块级作用域的let只在循环内部有效</p><p><code>每一次循环的</code>i<code>其实都是一个新的变量，所以最后输出的是</code>6<code>。你可能会问，如果每一轮循环的变量</code>i<code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量</code>i<code>时，就在上一轮循环的基础上进行计算。</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;;<br>&#125;<br>a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span><br></code></pre></div></td></tr></table></figure><blockquote><p><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><p><code>函数内部的变量</code>i<code>与循环变量</code>i<code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 </code>let<code> 重复声明同一个变量）。</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br></code></pre></div></td></tr></table></figure><blockquote><p>​    暂时性死区</p><p>​    ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>下面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// TDZ开始</span><br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// ReferenceError</span><br><br>  <span class="hljs-keyword">let</span> tmp; <span class="hljs-comment">// TDZ结束</span><br>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// undefined</span><br><br>  tmp = <span class="hljs-number">123</span>;<br>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// 123</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><blockquote><p>​    <code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p><code>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github使用总结🎟️</title>
    <link href="/hexo_blog/2021/05/11/evenloop/"/>
    <url>/hexo_blog/2021/05/11/evenloop/</url>
    
    <content type="html"><![CDATA[<h1 id="Evenloop事件循环"><a href="#Evenloop事件循环" class="headerlink" title="Evenloop事件循环"></a>Evenloop事件循环</h1><p>先，JavaScript是一个单线程的脚本语言。</p><p>所以就是说在一行代码执行的过程中，必然不会存在同时执行的另一行代码，就像使用<code>alert()</code>以后进行疯狂<code>console.log</code>，如果没有关闭弹框，控制台是不会显示出一条<code>log</code>信息的。</p><p>亦或者有些代码执行了大量计算，比方说在前端暴力破解密码之类的鬼操作，这就会导致后续代码一直在等待，页面处于假死状态，因为前边的代码并没有执行完。</p><p>所以如果全部代码都是同步执行的，这会引发很严重的问题，比方说我们要从远端获取一些数据，难道要一直循环代码去判断是否拿到了返回结果么？<em>就像去饭店点餐，肯定不能说点完了以后就去后厨催着人炒菜的，会被揍的。</em></p><p>于是就有了异步事件的概念，注册一个回调函数，比如说发一个网络请求，我们告诉主程序等到接收到数据后通知我，然后我们就可以去做其他的事情了。</p><p>然后在异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁等待，等到程序空闲下来才有时间去看哪些异步已经完成了，可以去执行。</p><p><em>比如说打了个车，如果司机先到了，但是你手头还有点儿事情要处理，这时司机是不可能自己先开着车走的，一定要等到你处理完事情上了车才能走。</em></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/15/1653c82e7835e1a9~tplv-t2oaga2asx-zoom-in-crop-mark:652:0:0:0.awebp" alt="img"></p><p>这个就像去银行办业务一样，先要取号进行排号。<br> 一般上边都会印着类似：“您的号码为XX，前边还有XX人。”之类的字样。</p><p>因为柜员同时职能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。<br> 所以多个宏任务合在一起就可以认为说有一个任务队列在这，里边是当前银行中所有排号的客户。<br> <strong>任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中，就像在银行中排号，如果叫到你的时候你不在，那么你当前的号牌就作废了，柜员会选择直接跳过进行下一个客户的业务处理，等你回来以后还需要重新取号</strong></p><p>而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。<br> 所以本来快轮到你来办理业务，会因为老大爷临时添加的“<strong>理财业务</strong>”而往后推。<br> 也许老大爷在办完理财以后还想 <strong>再办一个信用卡</strong>？或者 <strong>再买点儿纪念币</strong>？<br> 无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。</p><p>这就说明：你大爷永远是你大爷<br> <strong>在当前的微任务没有执行完成时，是不会执行下一个宏任务的。</strong></p><p>所以就有了那个经常在面试题、各种博客中的代码片段：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p><code>setTimeout</code>就是作为宏任务来存在的，而<code>Promise.then</code>则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。</p><p><strong>所有会进入的异步都是指的事件回调中的那部分代码</strong><br> 也就是说<code>new Promise</code>在实例化的过程中所执行的代码都是同步进行的，而<code>then</code>中注册的回调才是异步执行的。<br> 在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。<br> 所以就得到了上述的输出结论<code>1、2、3、4</code>。</p><p><em>+部分表示同步执行的代码</em></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">+<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>-  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<br>+&#125;)<br><br>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>+  resolve()<br>+  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>+&#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>-  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>+&#125;)<br><br>+<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>本来<code>setTimeout</code>已经先设置了定时器（相当于取号），然后在当前进程中又添加了一些<code>Promise</code>的处理（临时添加业务）。</p><p>所以进阶的，即便我们继续在<code>Promise</code>中实例化<code>Promise</code>，其输出依然会早于<code>setTimeout</code>的宏任务：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before timeout&#x27;</span>)<br>  &#125;).then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;also before timeout&#x27;</span>)<br>    &#125;)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>当然了，实际情况下很少会有简单的这么调用<code>Promise</code>的，一般都会在里边有其他的异步操作，比如<code>fetch</code>、<code>fs.readFile</code>之类的操作。<br> 而这些其实就相当于注册了一个宏任务，而非是微任务。</p><p><em>P.S. 在<a href="https://link.juejin.cn/?target=https://promisesaplus.com/%23notes">Promise/A+的规范</a>中，<code>Promise</code>的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少<code>Chrome</code>是这么做的)，<code>Promise</code>应该是属于微任务阵营的</em></p><p>所以，明白哪些操作是宏任务、哪些是微任务就变得很关键，这是目前业界比较流行的说法：</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><table><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td><code>I/O</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setTimeout</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setInterval</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setImmediate</code></td><td>❌</td><td>✅</td></tr><tr><td><code>requestAnimationFrame</code></td><td>✅</td><td>❌</td></tr></tbody></table><p><em>有些地方会列出来<code>UI Rendering</code>，说这个也是宏任务，可是在读了<a href="https://link.juejin.cn/?target=https://html.spec.whatwg.org/multipage/webappapis.html%23event-loop-processing-model">HTML规范文档</a>以后，发现这很显然是和微任务平行的一个操作步骤</em><br> <em><code>requestAnimationFrame</code>姑且也算是宏任务吧，<code>requestAnimationFrame</code>在<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">MDN的定义</a>为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行</em></p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><table><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td><code>process.nextTick</code></td><td>❌</td><td>✅</td></tr><tr><td><code>MutationObserver</code></td><td>✅</td><td>❌</td></tr><tr><td><code>Promise.then catch finally</code></td><td>✅</td><td>✅</td></tr></tbody></table><h2 id="Event-Loop是个啥"><a href="#Event-Loop是个啥" class="headerlink" title="Event-Loop是个啥"></a>Event-Loop是个啥</h2><p>上边一直在讨论 宏任务、微任务，各种任务的执行。<br> 但是回到现实，<code>JavaScript</code>是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。</p><p>每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。*<strong>（检查还有没有微任务需要处理）***<br> 而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。*</strong>（结束本次宏任务、检查还有没有宏任务需要处理）***<br> 这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为<code>Event Loop</code>。*(这是个非常简易的描述了，实际上会复杂很多)*</p><p>而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">const macroTaskList = [<br>  [<span class="hljs-string">&#x27;task1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;task2&#x27;</span>, <span class="hljs-string">&#x27;task3&#x27;</span>],<br>  [<span class="hljs-string">&#x27;task4&#x27;</span>],<br>]<br><br><span class="hljs-keyword">for</span> (let macroIndex = <span class="hljs-number">0</span>; macroIndex &lt; macroTaskList.length; macroIndex++) &#123;<br>  const microTaskList = macroTaskList[macroIndex]<br>  <br>  <span class="hljs-keyword">for</span> (let microIndex = <span class="hljs-number">0</span>; microIndex &lt; microTaskList.length; microIndex++) &#123;<br>    const microTask = microTaskList[microIndex]<br><br>    <span class="hljs-regexp">//</span> 添加一个微任务<br>    <span class="hljs-keyword">if</span> (microIndex === <span class="hljs-number">1</span>) microTaskList.push(<span class="hljs-string">&#x27;special micro task&#x27;</span>)<br>    <br>    <span class="hljs-regexp">//</span> 执行任务<br>    console.log(microTask)<br>  &#125;<br><br>  <span class="hljs-regexp">//</span> 添加一个宏任务<br>  <span class="hljs-keyword">if</span> (macroIndex === <span class="hljs-number">2</span>) macroTaskList.push([<span class="hljs-string">&#x27;special macro task&#x27;</span>])<br>&#125;<br><br><span class="hljs-regexp">//</span> &gt; task1<br><span class="hljs-regexp">//</span> &gt; task2<br><span class="hljs-regexp">//</span> &gt; task3<br><span class="hljs-regexp">//</span> &gt; special micro task<br><span class="hljs-regexp">//</span> &gt; task4<br><span class="hljs-regexp">//</span> &gt; special macro task<br>复制代码<br></code></pre></div></td></tr></table></figure><p><em>之所以使用两个<code>for</code>循环来表示，是因为在循环内部可以很方便的进行<code>push</code>之类的操作（添加一些任务），从而使迭代的次数动态的增加。</em></p><p>以及还要明确的是，<code>Event Loop</code>只是负责告诉你该执行那些任务，或者说哪些回调被触发了，真正的逻辑还是在进程中执行的。</p><h2 id="在浏览器中的表现"><a href="#在浏览器中的表现" class="headerlink" title="在浏览器中的表现"></a>在浏览器中的表现</h2><p>在上边简单的说明了两种任务的差别，以及<code>Event Loop</code>的作用，那么在真实的浏览器中是什么表现呢？<br> 首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）</p><p><code>I/O</code>这一项感觉有点儿笼统，有太多的东西都可以称之为<code>I/O</code>，点击一次<code>button</code>，上传一个文件，与程序产生交互的这些都可以称之为<code>I/O</code>。</p><p>假设有这样的一些<code>DOM</code>结构：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;style&gt;<br>  <span class="hljs-comment">#outer &#123;</span><br>    padding: <span class="hljs-number">20</span>px;<br>    background: <span class="hljs-comment">#616161;</span><br>  &#125;<br><br>  <span class="hljs-comment">#inner &#123;</span><br>    width: <span class="hljs-number">100</span>px;<br>    height: <span class="hljs-number">100</span>px;<br>    background: <span class="hljs-comment">#757575;</span><br>  &#125;<br>&lt;/style&gt;<br>&lt;div id=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>  &lt;div id=<span class="hljs-string">&quot;inner&quot;</span>&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>复制代码<br><span class="hljs-keyword">const</span> $inner = document.querySelector(<span class="hljs-string">&#x27;#inner&#x27;</span>)<br><span class="hljs-keyword">const</span> $outer = document.querySelector(<span class="hljs-string">&#x27;#outer&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span> (<span class="hljs-params"></span>) </span>&#123;<br>  console.log(<span class="hljs-string">&#x27;click&#x27;</span>) <span class="hljs-comment">// 直接输出</span><br><br>  Promise.resolve().then(_ =&gt; console.log(<span class="hljs-string">&#x27;promise&#x27;</span>)) <span class="hljs-comment">// 注册微任务</span><br><br>  setTimeout(_ =&gt; console.log(<span class="hljs-string">&#x27;timeout&#x27;</span>)) <span class="hljs-comment">// 注册宏任务</span><br><br>  requestAnimationFrame(_ =&gt; console.log(<span class="hljs-string">&#x27;animationFrame&#x27;</span>)) <span class="hljs-comment">// 注册宏任务</span><br><br>  $outer.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, Math.random()) <span class="hljs-comment">// DOM属性修改，触发微任务</span><br>&#125;<br><br><span class="hljs-keyword">new</span> MutationObserver(_ =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;observer&#x27;</span>)<br>&#125;).observe($outer, &#123;<br>  attributes: <span class="hljs-literal">true</span><br>&#125;)<br><br>$inner.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br>$outer.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, handler)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>如果点击<code>#inner</code>，其执行顺序一定是：<code>click</code> -&gt; <code>promise</code> -&gt; <code>observer</code> -&gt; <code>click</code> -&gt; <code>promise</code> -&gt; <code>observer</code> -&gt; <code>animationFrame</code> -&gt; <code>animationFrame</code> -&gt; <code>timeout</code> -&gt; <code>timeout</code>。</p><p>因为一次<code>I/O</code>创建了一个宏任务，也就是说在这次任务中会去触发<code>handler</code>。<br> 按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了<code>Promise</code>和<code>MutationObserver</code>两个微任务，遂执行之。<br> 因为<code>click</code>事件会冒泡，所以对应的这次<code>I/O</code>会触发两次<code>handler</code>函数(<em>一次在<code>inner</code>、一次在<code>outer</code></em>)，所以会优先执行冒泡的事件(<em>早于其他的宏任务</em>)，也就是说会重复上述的逻辑。<br> 在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。<br> 需要注意的一点是，因为我们触发了<code>setAttribute</code>，实际上修改了<code>DOM</code>的属性，这会导致页面的重绘，而这个<code>set</code>的操作是同步执行的，也就是说<code>requestAnimationFrame</code>的回调会早于<code>setTimeout</code>所执行。</p><h3 id="一些小惊喜"><a href="#一些小惊喜" class="headerlink" title="一些小惊喜"></a>一些小惊喜</h3><p>使用上述的示例代码，如果将手动点击<code>DOM</code>元素的触发方式变为<code>$inner.click()</code>，那么会得到不一样的结果。<br> 在<code>Chrome</code>下的输出顺序大致是这样的：<br> <code>click</code> -&gt; <code>click</code> -&gt; <code>promise</code> -&gt; <code>observer</code> -&gt; <code>promise</code> -&gt;  <code>animationFrame</code> -&gt; <code>animationFrame</code> -&gt; <code>timeout</code> -&gt; <code>timeout</code>。</p><p>与我们手动触发<code>click</code>的执行顺序不一样的原因是这样的，因为并不是用户通过点击元素实现的触发事件，而是类似<code>dispatchEvent</code>这样的方式，我个人觉得并不能算是一个有效的<code>I/O</code>，在执行了一次<code>handler</code>回调注册了微任务、注册了宏任务以后，实际上外边的<code>$inner.click()</code>并没有执行完。<br> 所以在微任务执行之前，还要继续冒泡执行下一次事件，也就是说触发了第二次的<code>handler</code>。<br> 所以输出了第二次<code>click</code>，等到这两次<code>handler</code>都执行完毕后才会去检查有没有微任务、有没有宏任务。</p><p>两点需要注意的：</p><ol><li><code>.click()</code>的这种触发事件的方式个人认为是类似<code>dispatchEvent</code>，可以理解为同步执行的代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>))<br><br><span class="hljs-built_in">document</span>.body.click()<br><span class="hljs-built_in">document</span>.body.dispatchEvent(<span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;click&#x27;</span>))<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;done&#x27;</span>)<br><br><span class="hljs-comment">// &gt; click</span><br><span class="hljs-comment">// &gt; click</span><br><span class="hljs-comment">// &gt; done</span><br>复制代码<br></code></pre></div></td></tr></table></figure><ol><li><code>MutationObserver</code>的监听不会说同时触发多次，多次修改只会有一次回调被触发。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;observer&#x27;</span>)<br>  <span class="hljs-comment">// 如果在这输出DOM的data-random属性，必然是最后一次的值，不解释了</span><br>&#125;).observe(<span class="hljs-built_in">document</span>.body, &#123;<br>  attributes: <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random())<br><span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random())<br><span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random())<br><br><span class="hljs-comment">// 只会输出一次 ovserver</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p><em>这就像去饭店点餐，服务员喊了三次，XX号的牛肉面，不代表她会给你三碗牛肉面。</em><br> <em>上述观点参阅自<a href="https://link.juejin.cn/?target=https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/%23level-1-bossfight">Tasks, microtasks, queues and schedules</a>，文中有动画版的讲解</em></p><h2 id="在Node中的表现"><a href="#在Node中的表现" class="headerlink" title="在Node中的表现"></a>在Node中的表现</h2><p>Node也是单线程，但是在处理<code>Event Loop</code>上与浏览器稍微有些不同，这里是<a href="https://link.juejin.cn/?target=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/%23event-loop-explained">Node官方文档</a>的地址。</p><p>就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的<code>process.nextTick</code>以及宏任务的<code>setImmediate</code>。</p><h3 id="setImmediate与setTimeout的区别"><a href="#setImmediate与setTimeout的区别" class="headerlink" title="setImmediate与setTimeout的区别"></a>setImmediate与setTimeout的区别</h3><p>在官方文档中的定义，<code>setImmediate</code>为一次<code>Event Loop</code>执行完毕后调用。<br> <code>setTimeout</code>则是通过计算一个延迟时间后进行执行。</p><p>但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。<br> 因为如果主进程中先注册了两个任务，然后执行的代码耗时超过<code>XXs</code>，而这时定时器已经处于可执行回调的状态了。<br> 所以会先执行定时器，而执行完定时器以后才是结束了一次<code>Event Loop</code>，这时才会执行<code>setImmediate</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">set<span class="hljs-constructor">Timeout(<span class="hljs-params">_</span> =&gt; <span class="hljs-params">console</span>.<span class="hljs-params">log</span>(&#x27;<span class="hljs-params">setTimeout</span>&#x27;)</span>)<br>set<span class="hljs-constructor">Immediate(<span class="hljs-params">_</span> =&gt; <span class="hljs-params">console</span>.<span class="hljs-params">log</span>(&#x27;<span class="hljs-params">setImmediate</span>&#x27;)</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>有兴趣的可以自己试验一下，执行多次真的会得到不同的结果。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/15/1653c82abfac7543~tplv-t2oaga2asx-zoom-in-crop-mark:652:0:0:0.awebp" alt="img"></p><p>但是如果后续添加一些代码以后，就可以保证<code>setTimeout</code>一定会在<code>setImmediate</code>之前触发了：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>))<br>setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>))<br><br><span class="hljs-keyword">let</span> countdown = <span class="hljs-number">1e9</span><br><br><span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">countdown--</span>)</span> &#123; &#125; <span class="hljs-comment">// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`</span><br>复制代码<br></code></pre></div></td></tr></table></figure><p>如果在另一个宏任务中，必然是<code>setImmediate</code>先执行：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).readFile(__dirname, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>))<br>  setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p>就像上边说的，这个可以认为是一个类似于<code>Promise</code>和<code>MutationObserver</code>的微任务实现，在代码执行的过程中可以随时插入<code>nextTick</code>，并且会保证在下一个宏任务开始之前所执行。</p><p>在使用方面的一个最常见的例子就是一些事件绑定类的操作：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lib</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">require</span>(<span class="hljs-params">&#x27;events&#x27;</span>).<span class="hljs-title">EventEmitter</span> </span>&#123;<br>  constructor () &#123;<br>    <span class="hljs-keyword">super</span>()<br><br>    <span class="hljs-keyword">this</span>.emit(<span class="hljs-symbol">&#x27;ini</span>t&#x27;)<br>  &#125;<br>&#125;<br><br>const lib = <span class="hljs-keyword">new</span> <span class="hljs-type">Lib</span>()<br><br>lib.on(<span class="hljs-symbol">&#x27;ini</span>t&#x27;, _ =&gt; &#123;<br>  <span class="hljs-comment">// 这里将永远不会执行</span><br>  console.log(<span class="hljs-symbol">&#x27;init</span>!&#x27;)<br>&#125;)<br>复制代码<br></code></pre></div></td></tr></table></figure><p>因为上述的代码在实例化<code>Lib</code>对象时是同步执行的，在实例化完成以后就立马发送了<code>init</code>事件。<br> 而这时在外层的主程序还没有开始执行到<code>lib.on(&#39;init&#39;)</code>监听事件的这一步。<br> 所以会导致发送事件时没有回调，回调注册后事件不会再次发送。</p><p>我们可以很轻松的使用<code>process.nextTick</code>来解决这个问题：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lib</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">require</span>(<span class="hljs-params">&#x27;events&#x27;</span>).<span class="hljs-title">EventEmitter</span> </span>&#123;<br>  constructor () &#123;<br>    <span class="hljs-keyword">super</span>()<br><br>    process.nextTick(_ =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.emit(<span class="hljs-symbol">&#x27;ini</span>t&#x27;)<br>    &#125;)<br><br>    <span class="hljs-comment">// 同理使用其他的微任务</span><br>    <span class="hljs-comment">// 比如Promise.resolve().then(_ =&gt; this.emit(&#x27;init&#x27;))</span><br>    <span class="hljs-comment">// 也可以实现相同的效果</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></div></td></tr></table></figure><p>这样会在主进程的代码执行完毕后，程序空闲时触发<code>Event Loop</code>流程查找有没有微任务，然后再发送<code>init</code>事件。</p><p><em>关于有些文章中提到的，循环调用<code>process.nextTick</code>会导致报警，后续的代码永远不会被执行，这是对的，参见上边使用的双重循环实现的<code>loop</code>即可，相当于在每次<code>for</code>循环执行中都对数组进行了<code>push</code>操作，这样循环永远也不会结束</em></p><h2 id="多提一嘴async-await函数"><a href="#多提一嘴async-await函数" class="headerlink" title="多提一嘴async/await函数"></a>多提一嘴async/await函数</h2><p>因为，<code>async/await</code>本质上还是基于<code>Promise</code>的一些封装，而<code>Promise</code>是属于微任务的一种。所以在使用<code>await</code>关键字与<code>Promise.then</code>效果类似：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;<br><br>main()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>复制代码<br></code></pre></div></td></tr></table></figure><p><strong>async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于<code>new Promise</code>时传入的代码，await之后的所有代码都是在<code>Promise.then</code>中的回调</strong></p><p>原文链接：<a href="https://juejin.cn/post/6844903657264136200">https://juejin.cn/post/6844903657264136200</a></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>get和post请求🍺</title>
    <link href="/hexo_blog/2021/02/11/get%E5%92%8Cpost/"/>
    <url>/hexo_blog/2021/02/11/get%E5%92%8Cpost/</url>
    
    <content type="html"><![CDATA[<h1 id="get和post请求"><a href="#get和post请求" class="headerlink" title="get和post请求"></a>get和post请求</h1><p><code>W3c</code></p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><blockquote><p>GET和POST是什么?HTTP协议中的两种发送请求的方法。</p></blockquote><blockquote><p>HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p></blockquote><blockquote><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p></blockquote><div class="hljs code-wrapper"><pre><code>     在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，     整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，     而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢?</code></pre></div><p>​        在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p><p><code>其实，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</code></p><p>GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包;POST产生两个TCP数据包。</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github使用总结📣</title>
    <link href="/hexo_blog/2020/12/11/github/"/>
    <url>/hexo_blog/2020/12/11/github/</url>
    
    <content type="html"><![CDATA[<h1 id="一些-GitHub-的基本概念"><a href="#一些-GitHub-的基本概念" class="headerlink" title="一些 GitHub 的基本概念"></a>一些 GitHub 的基本概念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一些常用的git操作</p><p><img src="https://img-blog.csdnimg.cn/20190628180240306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YW5zaHVqaW43Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="获取与创建项目"><a href="#获取与创建项目" class="headerlink" title="获取与创建项目"></a>获取与创建项目</h3><blockquote><p>​    </p><ul><li>创建仓库的途径有：<ol><li>在本地已有的目录，初始化一个新的；</li><li>克隆复制一份别人的项目。</li></ol></li></ul><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><ul><li>在当前目录下创建.git目录，同时当前目录成为一个Git仓库。</li></ul><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><ul><li><code>git clone Git仓库url</code>：将http或ssh链接指向的Git仓库拷贝到本地。</li><li><code>git clone Git仓库url 本地目录路径</code>：将远程Git仓库拷贝到本地指定目录。</li></ul></blockquote><h3 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h3><blockquote><p>​    基本流程</p><ol><li>使用<code>git add</code>添加需要追踪的新文件和待提交的更改；</li><li>使用<code>git status</code>和<code>git diff</code>查看有何改动；</li><li>使用<code>git commit</code>提交快照。</li></ol><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><ul><li><code>git add 文件</code>：将文件添加到缓存区，该文件被标记为被追踪。</li><li><code>git add .</code>：缓存当前目录下所有文件，不包括已删除的文件。</li></ul><hr><ul><li>注意，git add只是复制一份当前状态下的该文件到缓存区，该文件之后的修改若不重新git add，则提交的时候，只会将上次git add的缓存提交给仓库。</li></ul><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><ul><li>将缓存写入仓库中。</li><li><code>git add</code>是<strong>工作区-&gt;缓存区</strong>，<code>git commit</code>是<strong>缓存区-&gt;仓库</strong>。</li><li><code>git commit -m &quot;本次提交说明&quot;</code>：一次性将缓存区所有文件修改提交到仓库的当前分支。</li><li><code>git commit -am &quot;本次提交说明&quot;</code>：自动把所有<strong>已经跟踪过</strong>的文件缓存，并提交到仓库。常用于跳过<code>git add</code>步骤快速提交。</li><li><code>git commit --amend &quot;本次提交说明&quot;</code>：重新提交。此次提交代替上一次提交的结果。尤其适用于提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了的情况。</li></ul><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><ul><li><p><code>git status</code>：显示当前仓库的最新状态。</p></li><li><p><code>git status -s</code>：当前仓库的最新状态的简介。</p><p><img src="https://upload-images.jianshu.io/upload_images/1291453-ea460a22aae2bf76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/170/format/webp" alt="img"></p><p>git status -s</p><ul><li>状态值第一栏是关于缓存区的（绿色），第二栏是关于工作区的（红色）。<ul><li>??表示该文件仅是本地文件。</li><li>绿色A表示该文件以前没被提交过，添加到缓存；（提交时会告知仓库添加此快照）。</li><li>绿色M表示该文件以前被提交过后，又添加到缓存；（提交时会告知仓库修改此快照）。</li><li>绿色D表示该文件以前被提交过后，被本地删除了，又删除缓存；（提交时会告知仓库删除此快照）。</li><li>绿色R表示该文件添加到快照时，系统发现某个D快照与其相同，并将D文件名改为该文件名。</li><li>红色M表示该文件被本地修改过。</li><li>红色D表示该文件被本地删除了。</li></ul></li></ul></li></ul><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><ul><li><code>git diff</code>：比较工作区和缓存区的不同。</li><li><code>git diff --cached</code>：比较缓存区和仓库的不同。</li><li><code>git diff 文件</code>：比较指定文件在工作区和缓存区的不同。</li><li><code>git diff 文件 --cached</code>：比较指定文件在缓存区和仓库的不同。</li></ul><hr><ul><li><code>git diff 提交版本号1 提交版本号2</code>：比较两次提交之间的区别。</li><li><code>git diff 分支1 分支2</code>：比较两个分支之间的区别。</li></ul><hr><ul><li>注意：只会比较那些跟踪文件(即<code>git add</code>过的文件)。</li></ul><h2 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h2><ul><li><code>git show</code>：查看最后一个提交的内容。</li><li><code>git show HEAD~1</code>：查看倒数第二个提交的内容。</li><li><code>git show 提交版本号</code>：查看指定提交的内容。</li></ul></blockquote><h3 id="删除与恢复"><a href="#删除与恢复" class="headerlink" title="删除与恢复"></a>删除与恢复</h3><blockquote><p>​    </p></blockquote><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><blockquote><p>​    </p></blockquote><h3 id="远程项目"><a href="#远程项目" class="headerlink" title="远程项目"></a>远程项目</h3><blockquote><p>​    </p></blockquote><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><blockquote><p>​    </p></blockquote><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><blockquote><p>​    </p></blockquote><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><p><code>git config --global user.name &lt;your_name&gt;</code></p><p><code>git config --global user.email &lt;your_email@example.com&gt;</code></p><h4 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h4><div class="hljs code-wrapper"><pre><code>版本查询 -&gt;    git --version设置当前用户信息      git config --global user.name &quot;xxx&quot;    git config --global user.email &quot;xxx@xxx&quot;显示当前用户信息    git config --list显示git常用指令    git初始化仓库// xxx 代表仓库名/文件夹名    mkdir xxx    cd xxx    git init远程仓库// xx 指远程名称， xxx指远程地址// 如果是git clone得到的仓库，远程名称默认为origin// 添加远程仓库    git remote add xx xxx// 查询远程仓库名    git remote// 查询远程仓库详细信息    git remote -v// 复制远程仓库    git clone// 提交至远程仓库    git push -u xx xxx// 将本地与远程同步    git pull 或 git fetch &amp;&amp; git merge查询仓库状态    git status将文件添加到暂存区    git add.生成“后悔药”    git commit -m &quot;xxx&quot;“后悔药”查询    // 基本查询    git log    // 详细查询，包括修改对比    git log -p    // 以精简模式显示    git log --oneline    // 查看“后悔树”    git log --graph吃“后悔药”，版本回退    // xxx 代表编号或标记，可用git log查询    git checkout xxx    // 回退到最近的版本    git checkout -标记    git tag    // xx 代表标记， xxx代表注释    git tag -a xx -m &quot;xxx&quot;    // 显示标记    git show xx分支    // xxx代表分支名    // 产生分支    git branch xxx    // 分支跳转    git checkout xxx    // 创建并跳转分支    git checkout -b xxx    // 合并分支    git merge</code></pre></div><p><img src="https://img-blog.csdn.net/20180801143428728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Njg0NjY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习总结🎺</title>
    <link href="/hexo_blog/2020/11/05/HTML%20&amp;%20CSS/"/>
    <url>/hexo_blog/2020/11/05/HTML%20&amp;%20CSS/</url>
    
    <content type="html"><![CDATA[<h3 id="第一部分-HTML"><a href="#第一部分-HTML" class="headerlink" title="第一部分 HTML"></a>第一部分 HTML</h3><hr><h4 id="第一章-职业规划和前景"><a href="#第一章-职业规划和前景" class="headerlink" title="第一章 职业规划和前景"></a>第一章 职业规划和前景</h4><hr><ul><li><p><strong>职业方向规划定位：</strong></p><ul><li><code>web</code>前端开发工程师</li><li><code>web</code>网站架构师</li><li>自己创业</li><li>转岗管理或其他<a id="more"></a></li></ul></li><li><p><strong><code>web</code>前端开发的前景展望：</strong></p><ul><li>未来<code>IT</code>行业企业需求最多的人才</li><li>结合最新的<code>html5</code>抢占移动端的市场</li><li>自己创业做老板</li><li>随着互联网的普及<code>web</code>开发成为企业的宠儿和核心</li></ul></li><li><p><strong><code>web</code>职业发展目标：</strong></p><ul><li><p>第一、梳理知识架构</p><ul><li>负责内容的<code>HTML</code></li><li>负责外观的<code>css</code>（层叠样式表）</li><li>负责行为的<code>js</code></li><li><code>ps</code>切图</li></ul></li><li><p>第二、分解目标（起步阶段、提升阶段、成型阶段）</p><ul><li><p>起步阶段：</p><ul><li>基本知识的掌握</li><li>常用工具的掌握</li><li>沟通技巧的掌握（围绕客户的需求）</li><li>良好的开发习惯（加注释、对齐方式）</li></ul></li><li><p>提升阶段：</p><ul><li>熟悉掌握<code>HTML</code>基本标签和属性</li><li>熟练掌握<code>css</code>的基本语法和使用</li><li>浏览器兼容和w3c标准的掌握</li><li>结合<code>html</code>+<code>css</code>+<code>js</code>开始系统项目的开发</li></ul></li><li><p>成型阶段：</p><ul><li>精通<code>DIV</code>+<code>CCS</code>布局</li><li>精通<code>css</code>样式表控制<code>html</code>标签</li><li>熟悉运用<code>js</code>制作动态网站的效果</li><li>能独立开发完成网站</li></ul></li></ul></li></ul></li></ul><hr><h4 id="第二章-html基本结构"><a href="#第二章-html基本结构" class="headerlink" title="第二章 html基本结构"></a>第二章 html基本结构</h4><hr><ul><li><p>认识HTML：</p><ul><li><code>html</code>不是一种编程语言，是一种标志语言</li><li>标记语言是由一套标识标签组成的</li><li><code>html</code>使用标签来描述网页</li></ul></li><li><p><code>html</code>结构：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/main.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 逻辑代码 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 逻辑代码底部 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lib/jquery/jquery-2.1.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><code>&lt;head&gt;</code>中添加信息</li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;smile@kang.cool&quot;</span>&gt;</span>------作者<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span>------网页描述<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;a,b,c&quot;</span>&gt;</span>------关键字,“，”分隔<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Wed, 26 Feb 1997 08：21：57 GMT&quot;</span>&gt;</span>------设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Pragma&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span>------禁止浏览器从本地机的缓存中调阅页面内容<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Window-target&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;_top&quot;</span>&gt;</span>------用来防止别人在框架里调用你的页面<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;5;URL=http://kahn1990.com/&quot;</span>&gt;</span>------跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span>------content的参数有all,none,index,noindex,follow,nofollow，默认是all<br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;Shortcut Icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span>&gt;</span>------收藏图标<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Cache-Control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache, must-revalidate&quot;</span>&gt;</span>------网页不会被缓存<br></code></pre></div></td></tr></table></figure><ul><li><p>不成对出现的标签<br><code>&lt;br&gt;</code> <code>&lt;hr&gt;</code>  <code>&lt;meta&gt;</code> <code>&lt;img&gt;</code>  <code>&lt;input..&gt;</code>  <code>&lt;option..&gt;</code>  <code>&lt;link&gt;</code></p><ul><li>特殊符号：<ul><li><code>&amp;nbsp</code>; —-&gt;空格</li><li><code>&amp;gt</code>; —&gt;大于号</li><li><code>&amp;lt</code>；—&lt;小于号</li><li><code>&amp;quot</code>；—&gt;引号</li><li><code>&amp;copy</code>;–&gt;版权号</li></ul></li></ul></li></ul><hr><h4 id="第三章-html基本标签"><a href="#第三章-html基本标签" class="headerlink" title="第三章 html基本标签"></a>第三章 html基本标签</h4><hr><ul><li><p><code>&lt;html&gt;</code> <code>&lt;head&gt;</code> <code>&lt;body&gt;</code>标签</p></li><li><p><code>&lt;h1&gt;&lt;/h1</code>—-<code>&lt;h6&gt;&lt;/h6&gt;</code>仅仅用于标题文本，不要为了产生粗体文本使用它们</p></li><li><p><code>&lt;p&gt;</code>标签  段落标签</p></li><li><p><code>&lt;strong&gt;&lt;b&gt;</code>标签</p><ul><li>都会让文字产生加粗效果<ul><li><code>&lt;strong&gt;</code>用于强调文本，强度更深，表示重要文本—&gt;用于<code>SEO</code>优化</li><li><code>&lt;b&gt;</code>只是视觉加粗效果—&gt;单纯为了产生加粗</li></ul></li></ul></li><li><p><code>&lt;em&gt;</code> <code>&lt;i&gt;</code>标签</p><ul><li><code>em</code>用于强调文本</li><li><code>i</code>只是视觉斜体效果</li><li><code>&lt;strong&gt;</code>比<code>&lt;em&gt;</code>强调更强</li></ul></li><li><p><code>span</code>标签</p><ul><li>对被用来组合文档中的行内元素</li><li>注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化</li></ul></li><li><p><code>&lt;pre&gt;</code>标签</p><ul><li>文字的格式按源码的排版来显示，我们称之为预处理格式</li></ul></li><li><p><code>&lt;a&gt;</code>标签—&gt;他有一个必不可少的属性 href </p><ul><li><code>target</code>属性：</li><li><code>_self</code>(在原来页面打开) </li><li><code> _blank</code>（新窗口打开）</li><li><code>_top</code>（打开时忽略所有的框架） </li><li> <code>_parent</code>（在父窗口中打开）</li></ul></li><li><p>创建锚点和锚链接</p><ul><li>锚点也是一种超链接，是页面内进行跳转的超链接<div class="hljs code-wrapper"><pre><code>- 第一步：创建锚点 `&lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt;`- 第二步：使用创建好的锚点名称 `&lt;a href=&quot;#锚点名称&quot;&gt;内容&lt;/a&gt;`</code></pre></div></li></ul></li><li><p><code>marquee</code>标签</p><ul><li>可以创建一个内容滚动效果<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">direction</span>=<span class="hljs-string">&quot;down&quot;</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">this.stop()</span> <span class="hljs-attr">onmouseout</span>=<span class="hljs-string">this.start()</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><code>direction</code> 表示滚动方向，取值有（left,right,up,down,默认left）</li><li><code>loop </code>表示滚动循环的次数，默认为无限循环</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">onmouseover=<span class="hljs-built_in">this</span>.stop()  onmouseover=<span class="hljs-built_in">this</span>.start()  scrollamout=<span class="hljs-string">&quot;1&quot;</span>(滚动速度)<br></code></pre></div></td></tr></table></figure></li><li><p>表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动</p></li></ul><hr><h4 id="第四章-img图片标签与路径"><a href="#第四章-img图片标签与路径" class="headerlink" title="第四章 img图片标签与路径"></a>第四章 img图片标签与路径</h4><hr><ul><li><p>图片标签与路径：</p><ul><li>常见图片格式 <code>jpg</code> <code>png</code> <code>gif</code></li><li><code>Gif</code>     （只支持全透明）</li><li><code>Jpeg</code> /<code>jpg</code>     </li><li><code>Png</code> 半/全透明都支持</li></ul></li><li><p>图片标签写法 ：</p><ul><li><code>&lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt;</code></li></ul></li><li><p>图片四要素：</p><ul><li><code>src=&quot;&quot;</code>        图片路径</li><li><code>alt=&quot;&quot; </code>       图片含义</li><li><code>width=&quot;&quot;</code>     图片宽度 和图片大小保持一致</li><li><code> height=&quot;&quot;</code>     图片高度 和图片大小保持一致</li><li><code>title=&quot;&quot;</code></li></ul></li><li><p>路径知识：</p><ul><li><p>相对路径、绝对路径：</p><ul><li>相对路径：(Relative Path) 相对于该文件的路径；</li><li>绝对路径：(Absolute Path) 从磁盘出发的路径； </li></ul></li><li><p><code>&lt;img src=&quot;&quot; …… align=&quot;&quot; /&gt;</code> <code>align</code>属性–设置图片与后面文字的位置关系<br>值–<code>top</code>、<code>bottom</code>、<code>middle</code>、<code>absmiddle</code>、<code>left</code>、<code>right</code></p></li></ul></li><li><p>在静态页面中：</p><ul><li><p><code>/</code>开头表示根目录；</p></li><li><p><code>./</code>表示当前目录；（斜画线前面一个点）</p></li><li><p><code>../</code>上级目录；（斜画线前面两个点）</p></li><li><p>直接用文件名不带/也表示同一目录</p></li></ul><ul><li>这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。</li></ul></li></ul><hr><h4 id="第五章-三种列表的讲解"><a href="#第五章-三种列表的讲解" class="headerlink" title="第五章 三种列表的讲解"></a>第五章 三种列表的讲解</h4><hr><ul><li>三种列表的知识讲解：<ul><li><code>&lt;ul&gt;</code>无序列表<ul><li>无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识</li></ul></li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;ul&gt;</span><br>   <span class="hljs-section">&lt;li&gt;</span><span class="hljs-section">&lt;/li&gt;</span><br>   <span class="hljs-section">&lt;li&gt;</span><span class="hljs-section">&lt;/li&gt;</span><br>   <span class="hljs-section">&lt;li&gt;</span><span class="hljs-section">&lt;/li&gt;</span><br><span class="hljs-section">&lt;/ul&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><ol>有序列表  - 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 `<ol>` 标签。每个列表项始于 `<li> `标签。</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容二<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容三<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>列表符号</p><ul><li><p>无序列表-列表符号:</p><ul><li><code>type=&quot;circle&quot;</code>  空心圆 <code>type=“disc” </code> 实心圆  默认值 <code>type=&quot;square&quot; </code> 方块符</li></ul></li><li><p>有序列表-列表符号</p><ul><li><code>type=&quot;A&quot;</code>    A B C D</li><li><code>type=&quot;a&quot;</code>    a b c d</li><li><code>type=&quot;1&quot;</code>    1 2 3 4  默认值type=”I”    I II III type=”i”     i ii iii</li></ul></li><li><p>列表嵌套</p></li><li><p>无序列表-嵌套</p></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>柚子<br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沙田柚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>蜜柚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>荔枝<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>有序列表-嵌套</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>茶<br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>红茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>绿茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>果汁<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>牛奶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>定义列表<ul><li>定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 <code>&lt;dl&gt;</code> 标签开始。每个定义列表项以 <code>&lt;dt&gt; </code>开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code> 开始。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">&lt;<span class="hljs-built_in">dl</span>&gt;  <br>     &lt;<span class="hljs-built_in">dt</span>&gt;pc网页制作&lt;/<span class="hljs-built_in">dt</span>&gt;  <br>     &lt;<span class="hljs-built_in">dd</span>&gt;学习<span class="hljs-keyword">DIV</span>+CSS <span class="hljs-keyword">JS</span> JQ 项目实战&lt;/<span class="hljs-built_in">dd</span>&gt;  <br>     &lt;<span class="hljs-built_in">dt</span>&gt;手机网页制作&lt;/<span class="hljs-built_in">dt</span>&gt;  <br>     &lt;<span class="hljs-built_in">dd</span>&gt;手机网页制作实战&lt;/<span class="hljs-built_in">dd</span>&gt;<br>&lt;/<span class="hljs-built_in">dl</span>&gt;<br></code></pre></div></td></tr></table></figure><ul><li><p><code>dd</code>是对<code>dt</code>的解释</p><ul><li><code>&lt; dl&gt;&lt; /dl&gt;</code>用来创建一个普通的列表,</li><li><code>&lt; dt&gt;&lt; /dt&gt;</code>用来创建列表中的上层项目，</li><li><code>&lt; dd&gt;&lt; /dd&gt;</code>用来创建列表中最下层项目，</li><li><code>&lt; dt&gt;&lt; /dt&gt;</code>和<code>&lt; dd&gt;&lt; /dd&gt;</code>都必须放在<code>&lt; dl&gt;&lt; /dl&gt;</code>标志对之间。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>中国城市<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>上海 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>广州 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>美国城市<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>华盛顿 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>芝加哥 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>纽约 <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><code>dl</code>是d<code>efinition list</code>的缩写</li><li><code>dt</code>是<code>definition title</code>的缩写</li><li><code>dd</code>是d<code>efinition description</code>的缩写</li></ul><ul><li><code>list-style</code>属性具有三个属性分量：</li><li><code>list-style-position</code> ：设置列表项图标的位置，位于文本内或者文本外</li><li><code>list-style-type</code>： 设置列表项图标的类型</li><li><code>list-style-image </code>：使用图像设置列表项图标</li></ul><hr><h4 id="第六章-表单元素-上"><a href="#第六章-表单元素-上" class="headerlink" title="第六章 表单元素(上)"></a>第六章 表单元素(上)</h4><hr><ul><li><p>表单标签:</p><ul><li><p><code>&lt;form&gt;</code>表单标签</p><ul><li><code>&lt;form&gt;</code>表单是一个包含表单元素的区域，包括起来的都是表单的内容<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span>&gt;<br> &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul></li><li><p>HTML标签 - <code>Action</code>和确认按钮： </p><ul><li>当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;form action=&quot;html.do&quot; <span class="hljs-keyword">method</span>=&quot;get&quot;&gt;    <br>        username:  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;user&quot; /&gt;   <br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;submit&quot; <span class="hljs-keyword">value</span>=&quot;提  交&quot; /&gt;<br>&lt;/form&gt;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>HTML</code>标签 - 隐藏域隐藏标签：</p></li><li><p>隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器</p></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;form&gt;        <br>     &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;hid&quot; <span class="hljs-keyword">value</span>=&quot;value&quot;&gt;<br>&lt;/form&gt;<br></code></pre></div></td></tr></table></figure><ul><li><p><code>&lt;input&gt;</code>标签的掌握</p><ul><li><p>常用<code>type</code>类型：</p><ul><li><code>&lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt;</code></li><li><code>type=&quot;text&quot; </code>       单行文本输入框</li><li><code>type=&quot;password&quot;</code>    密码（<code>maxlength=&quot;&quot;</code>）</li><li><code>type=&quot;radio&quot;  </code>     单项选择（<code>checked=&quot;checked&quot;</code>） </li><li><code>type=&quot;checkbox&quot; </code>   多项选择  </li><li><code>type=&quot;button&quot;  </code>    按钮</li><li><code>type=&quot;submit&quot;</code>    提交 <code>type=&quot;image&quot;</code>图片提交</li><li><code>type=&quot;file&quot;</code>    上传文件</li><li><code>type=&quot;reset&quot;    </code>重置</li><li><code>type=&quot;hidden&quot;</code>    隐藏</li></ul></li></ul></li><li><p>关于表单中的设置默认值：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;今天心情不错&quot;</span> /&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;<br></code></pre></div></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>=&quot;&quot; &gt;<br> &lt;<span class="hljs-keyword">option</span>  <span class="hljs-keyword">value</span>=&quot;&quot;&gt;&lt;/<span class="hljs-keyword">option</span>&gt;<br> &lt;<span class="hljs-keyword">option</span>  <span class="hljs-keyword">value</span>=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/<span class="hljs-keyword">option</span>&gt;<br>&lt;<span class="hljs-keyword">select</span>&gt;<br></code></pre></div></td></tr></table></figure></li><li><p><code>textarea</code>没有默认值</p></li><li><p><code>&lt;label&gt;</code>标签的使用</p><ul><li><p><code>&lt;label&gt;&lt;/label&gt;</code></p><ul><li><code>label</code> 元素不会向用户呈现任何特殊效果。</li><li>不过，它为鼠标用户改进了可用性。</li><li>如果您在 <code>label</code> 元素内点击文本，就会触发此控件。</li><li>就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</li></ul></li><li><p><code>&lt;label&gt;</code> 标签的<code> for</code> 属性应当与相关元素的 <code>id </code>属性相同。</p></li><li><p>例子：（重要—注册表单–用户体验–必做）</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>单向选择<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>&lt;input type=<span class="hljs-string">&quot;radio&quot;</span><span class="hljs-built_in"> name</span>=<span class="hljs-string">&quot;sex&quot;</span><span class="hljs-built_in"> id</span>=<span class="hljs-string">&quot;male&quot;</span>/&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;nv&quot;</span>&gt;</span>女：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>&lt;input type=<span class="hljs-string">&quot;radio&quot;</span><span class="hljs-built_in"> name</span>=<span class="hljs-string">&quot;sex&quot;</span>checked=<span class="hljs-string">&quot;check&quot;</span>/&gt;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><hr><h4 id="第七章-表单和表格-下"><a href="#第七章-表单和表格-下" class="headerlink" title="第七章 表单和表格(下)"></a>第七章 表单和表格(下)</h4><hr><ul><li><p>表单和表格标签：</p><ul><li><code>&lt;textarea&gt;</code>文本域标签</li><li><code>&lt;textarea&gt;</code>标签：</li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>是文本域标签，可以在其中插入一段文字内容，它有两个常用属性<code>rows</code>和<code>cols</code></li></ul></li><li><p>注意：</p><ul><li><code>rows</code>表示这个文本域有多少行</li><li><code>cols</code>表示这个文本域有多少列</li></ul></li><li><p>除了这两个属性它还有<code>readonly</code>（只读，文本域的内容无法改变，相当于协议）和<code>title</code>（鼠标放上提示）</p></li><li><p><code>&lt;select&gt;</code>标签的掌握</p><ul><li>注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 <code>&lt;select&gt;</code> 表单数据提交给服务器时包括 <code>name </code>属性<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&lt;form&gt;      <br>    &lt;<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>=&quot;&quot;  id=&quot;&quot;&gt;<br>         &lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;1&quot;&gt;<span class="hljs-number">1</span>月&lt;/<span class="hljs-keyword">option</span>&gt;  <br>          &lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;2&quot;&gt;<span class="hljs-number">2</span>月&lt;/<span class="hljs-keyword">option</span>&gt;      <br>&lt;/<span class="hljs-keyword">select</span>&gt;<br>&lt;/form&gt;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>常用到的属性：<code>disabled=“disabled”  name=&quot;sel&quot;  size=&quot;2&quot;</code></p></li></ul><ul><li><p><code>&lt;table&gt;</code>表格标签</p></li><li><p><code> &lt;table&gt;</code>表格标签：<code>&lt;table&gt;</code>是表格标签，可以用它定义一个表格。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>注意：<code>&lt;table&gt;</code>的<code>border</code>属性不能少</p></li></ul><ul><li><p><code>&lt;tr&gt;</code> <code>&lt;td&gt;</code>标签的使用</p><ul><li><p><code>&lt;tr&gt;</code>行标签：</p><ul><li><code>&lt;tr&gt;</code>可以定义表格中的一行，一个&lt;<code>tr&gt;&lt;/tr&gt;</code>表示一行。<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul></li><li><p><code>&lt;td&gt;</code>单元格标签:</p><ul><li><code>&lt;td&gt;</code>可以定义表格中的一个单元格，<code>&lt;td&gt;&lt;/td&gt;</code>表示一个单元格。<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>爱好<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><code>border-collapse</code> 属性设置是否将表格边框折叠为单一边框：</li><li><code>border-collapse:collapse</code>;</li><li><code>colspan</code>左右合并</li><li><code>rowspan</code>上下合并</li></ul></li></ul></li></ul><p><strong>第一部分总结</strong>：</p><ul><li><p>非可视化标签：<code>head</code>  <code>meta</code>  <code>style</code>  <code>scrpit.</code>..</p></li><li><p>可视化标签：<code>img</code>  <code>div</code> <code>span</code> <code>a</code> <code>ul</code> <code>li</code>…</p></li><li><p>只有可视化标签，才能用<code>css</code>改变它</p></li><li><p>单标签：<code>meta</code>  <code>link</code>  <code>base</code>  <code>img</code>  <code>input</code> <code>br</code> <code>hr</code></p></li><li><p>双标签：<code>html</code> <code>head</code> <code>body</code>  <code>div</code>  <code>a</code>  <code>p</code>  <code>span</code> ..<code>ul</code> <code>li</code> <code>ol</code> <code> dl</code> ….</p></li><li><p><strong>常用可视化标签</strong></p><ul><li>** <code>div</code>** <ul><li>一般用它来布局</li></ul></li><li><strong>a</strong>  超链接标签<ul><li><code>href</code>*属性：设置跳转的网页地址</li><li><code>target</code>属性：设置跳转的目标</li><li>结论：凡事页面可以点击跳转或者表单提交的文字，都用<code>a</code>标签</li></ul></li><li><strong><code>img</code></strong><ul><li><code>src</code>*属性用来设置图片的url数据</li><li><code>alt</code>提供给搜索引擎搜索的</li><li><code>width</code></li><li><code>height</code></li><li>结论 ：显示图片</li></ul></li><li><strong>ul li</strong><ul><li>列表</li><li>结论：只要将来设计页面中有固定样式的列表，就用ul和li</li></ul></li><li><strong><code>table</code> <code>caption</code> <code>tr</code> <code>td (th)</code></strong><ul><li>慢慢已经被淘汰了 被ul li代替</li><li>如果是合并竖排的就是合并行（<code>rowspan</code>）</li><li>如果是合并横排的就是合并列（<code>colspan</code>）</li></ul></li></ul></li></ul><hr><p><strong>HTML部分导图总结</strong></p><hr><ul><li><a href="http://www.html5star.com/manual/html5label-meaning/">HTML5标签集合</a></li></ul><p><img src="./H4C2/1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="./H4C2/2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="./H4C2/3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><h3 id="第二部分-CSS"><a href="#第二部分-CSS" class="headerlink" title="第二部分 CSS"></a>第二部分 CSS</h3><hr><h4 id="第八章-css基础知识"><a href="#第八章-css基础知识" class="headerlink" title="第八章 css基础知识"></a>第八章 css基础知识</h4><hr><ul><li><p><code>css</code>基础知识：</p><ul><li><code>css</code>样式表的定义</li><li><code>css</code>：（Cascading Style Sheets）层叠样式表；</li></ul></li><li><p>分类及位置：内部样式<code>-head</code>区域<code>style</code>标签里面</p><ul><li>外部样式-<code>link</code>调用</li><li>内联样式-标签元素里面</li></ul></li><li><p><code>css</code>内的注释：/<code>*</code>注释内容<code>*</code>/</p></li><li><p><code>css</code>样式表的语法</p><ul><li><p><code>CSS</code>规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。</p></li><li><p>盒子名或者标签名{属性:值;}</p></li><li><p><strong>CSS中几种颜色的表示方法</strong></p><ul><li><strong>用颜色名表示</strong><ul><li>有17个预先确定的颜色，它们是<ul><li><code>aqua</code>, <code>black</code>, <code>blue</code>, <code>fuchsia</code>, <code>gray</code>, <code>green</code>, <code>lime</code>, <code>maroon</code>, <code>navy</code>,<br>　　<code>olive</code>, <code>orange,</code> <code>purple</code>, <code>red</code>, <code>silver</code>, <code>teal</code>, <code>white</code>, and <code>yellow</code></li></ul></li></ul></li></ul><ul><li><p><strong>用十六进制的颜色值表示(红、绿、蓝)</strong></p><ul><li><code>#FF0000</code>或者<code>#F00 </code> </li></ul></li><li><p><strong>用rgb(r,g,b)函数表示</strong></p><ul><li>如：<code>rgb(255,255,0)</code></li></ul></li><li><p><strong>用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度)</strong></p><ul><li>如：<code>hsl(120,100%,100%)</code>,色调0代表红色，<code>120</code>代表绿色，<code>240</code>代表<br>蓝色 </li></ul></li><li><p>**用<code>rgba(r,g,b,a)</code>函数表示 **</p><ul><li>其中<code>a</code>表示的是改颜色的透明度，取值范围是<code>0~1</code>，其中<code>0</code>代表完全透明</li></ul></li><li><p><strong>用hsla(Hue,Saturation,Lightness,alpha)函数表示</strong></p><ul><li>色调、饱和度、亮度、透明度 </li></ul></li><li><p>例子</p></li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute;top:0px&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:gray;&quot;</span>&gt;</span>background-color:gray<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:#F00;&quot;</span>&gt;</span>background-color:#F00<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:#ffff00;&quot;</span>&gt;</span>background-color:#ffff00<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(255,0,255);&quot;</span>&gt;</span>background-color:rgb(255,0,255)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:hsl(120,80%,50%);&quot;</span>&gt;</span>background-color:hsl(120,80%,50%)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgba(255,0,255,0.5);&quot;</span>&gt;</span>background-color:rgba(255,0,255,0.5)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:hsla(120,80%,50%,0.5);&quot;</span>&gt;</span>background-color:hsla(120,80%,50%,0.5)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1480597-39e61a813f637282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>内部样式表<ul><li>当单个页面需要设置样式时，就应该使用内部样式表。</li><li>使用 <code>&lt;style&gt;&lt;/style&gt;</code>标签在文档<code>&lt;head&gt;&lt;/head&gt;</code>里面定义内部样式表</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> &gt;</span><br><span class="css">  <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>内联样式表（优先级高）</p><ul><li><p>写在标签里面的样式</p></li><li><p>如：<code>&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt;</code></p></li></ul></li><li><p>表示给<code>p</code>标签里面的文字颜色设置为红色</p></li><li><p>区别：外链样式与导入样式</p><ul><li><p><code>link</code>标签是属于<code>xhtml</code>范畴，而<code>@import</code>则是<code>css2.1</code>中特有的。<code>link</code>标签除了可以加载<code>CSS</code>外，还可以做很多其它的事情，比如定义<code>RSS</code>，定义<code>rel</code>连接属性等，<code>@import</code>就只能加载<code>CSS</code>了。 </p></li><li><p>加载的顺序的区别，<code>link</code>加载的<code>css</code>时，是一种并行(没有尝试是否是这样)加载<code>CSS</code>方式，而<code>@impor</code>则在整个页面加载完成后才加载。</p></li><li><p>兼容性的区别，因<code>@import``CSS2.1</code>才特有的，所以对于不兼容<code>CSS2.1</code>的浏览器来说，无效。</p></li><li><p>在样式控制上(比如动态改变网页的布局时,使用<code>javascript</code>操作<code>DOM</code>)的区别，此时<code>@import</code>就无能为力了。</p></li></ul></li><li><p><strong>样式的优先级补充</strong></p><ul><li>相同权值情况下，<code>CSS</code>样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）：<ul><li><code>内联样式表（标签内部）</code> &gt; <code>嵌入样式表（当前文件中）</code>&gt; <code>外部样式表（外部文件中）</code></li></ul></li></ul></li><li><p>权值不同时，浏览器是根据权值来判断使用哪种<code>css</code>样式的，哪种样式权值高就使用哪种样式</p></li><li><p>层叠优先级是:</p><ul><li> <code>浏览器缺省</code>&lt; <code>外部样式表</code> &lt; <code>内部样式表</code> &lt; <code>内联样式</code></li></ul></li><li><p>其中样式表又有:<code>类选择器</code> &lt; <code>类派生选择器 </code>&lt;<code> ID选择器</code> &lt; <code>ID派生选择器</code></p></li><li><p>派生选择器以前叫上下文选择器，所以完整的层叠优先级是:</p><ul><li><code>浏览器缺省</code> &lt;<code> 外部样式表</code> &lt; <code>外部样式表类选择器</code> &lt; <code>外部样式表类派生选择器 </code>&lt; <code>外部样式表ID选择器</code> &lt; <code>外部样式表ID派生选择器 </code>&lt; <code>内部样式表</code> &lt; <code>内部样式表类选择器</code> &lt; <code>内部样式表类派生选择器</code> &lt; <code>内部样式表ID选择器</code> &lt; <code>内部样式表ID派生选择器</code> &lt; <code>内联样式</code>…共<code>12</code>个优先级</li></ul></li><li><p>另外，如果同一个元素在没有其他样式的作用影响下，其<code>Class</code>定义了多个并以空格分开，其优先级顺序为：</p><ul><li>一个元素同时应用多个<code>class</code>，后定义的优先（即近者优先），加上<code>!important</code>者最优先！</li></ul></li><li><p>选择器权重</p><table><thead><tr><th>选择器</th><th>权重值</th></tr></thead><tbody><tr><td>!important</td><td>infinity（正无穷）</td></tr><tr><td>行间样式</td><td>1000</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>class、属性、伪类选择器</td><td>10</td></tr><tr><td>标签选择器、伪元素选择器</td><td>1</td></tr><tr><td>通配符选择器</td><td>0</td></tr></tbody></table></li></ul><hr><h4 id="第九章-css选择器-上"><a href="#第九章-css选择器-上" class="headerlink" title="第九章 css选择器(上)"></a>第九章 css选择器(上)</h4><ul><li><p><code>css</code>选择器：</p><ul><li><code>class</code>类选择器可以重复利用    </li><li><code>id</code>选择器唯一</li></ul></li><li><p>标签选择器</p><ul><li>什么是选择器：css选择器就是要改变样式的对象</li></ul></li><li><p>选择器<code>&#123;属性:值;属性:值;&#125;</code></p></li><li><p>标签选择器：页面中所有的标签都是一个选择器  <code>p&#123;color:red;&#125;</code></p></li><li><p>通配符选择器 *</p><ul><li>选择全部的元素 以 <code>*</code> 开头，如: <code>*&#123;color:#0f0;&#125;</code></li></ul></li><li><p><code>ID</code>选择器</p><ul><li>选择<code>id</code>命名的元素 以 <code>#</code> 开头   <code>#p1&#123;color:#0f0;&#125;</code></li></ul></li><li><p>类选择器</p><ul><li><code>class</code>选择器，选择<code>clas</code>命名的元素 以<code>.</code>开头  <code>.first&#123;color:#00f;&#125;</code></li></ul></li><li><p><code>css</code>代码写完后上线前要经过压缩处理 </p></li><li><p>本地和服务器分两个<code>css</code>版本（备份）</p></li><li><p>压缩后注释都清除，空间体积减少</p></li><li><p>群组选择器</p><ul><li>选择多个元素,以逗号隔开 <code>#main,.first,span,a,h1&#123;color:red;&#125;</code></li></ul></li><li><p>包含选择器</p><ul><li>选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开<code>p</code>   <ul><li><code>span&#123;color:red;&#125;</code></li></ul></li></ul></li><li><p>属性选择器</p><ul><li>选择包含某一属性的元素</li><li><code>a[title]&#123;color:red;&#125;</code>  选择包含<code>title</code>的<code>a</code>标签</li><li><code>a[title][href]&#123;color:red;&#125;</code> 选择包含<code>title</code>和<code>href</code>的<code>a</code>标签</li></ul></li><li><p><code>&gt; </code> <code>+</code> 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素）</p><ul><li><code>p &gt; span&#123;color:red;&#125;</code></li></ul></li><li><p>相邻兄弟选择器：只选择后面的相邻兄弟元素</p><ul><li><code>p + span&#123;color:red;&#125;</code></li></ul></li></ul><hr><h4 id="第十章-css选择器-下"><a href="#第十章-css选择器-下" class="headerlink" title="第十章 css选择器(下)"></a>第十章 css选择器(下)</h4><hr><ul><li><p><code>&lt;a&gt;</code>伪类选择器</p><ul><li><p><code>a:link &#123;color:#FF0000;&#125;</code>    /* 超链接未访问时的状态 */ （只用于a标签）</p></li><li><p><code>a:visited &#123;color:#00FF00;&#125;</code>    /* 超链接访问过后的状态 */ （只用于a标签）</p></li><li><p><code>a:hover &#123;color:#FF00FF;&#125;    </code>/* 鼠标悬停状态</p></li><li><p><code>*/</code>（可和其他标签结合一起用）</p></li><li><p><code>a:active &#123;color:#0000FF;&#125;</code>    /* 激活状态，鼠标按下状态 */</p></li><li><p><strong>注意</strong></p><ul><li>伪类选择器的排序很重要，<code>a:link</code> <code>a:visited</code> <code>a:hover</code> <code>a:active</code>，记作<code>lvha</code></li></ul></li></ul></li><li><p>输入伪类选择器（针对表单）</p><ul><li><code>input:focus&#123;color:red;&#125; </code>      /* 键盘输入焦点 */</li></ul></li><li><p>位置伪类选择器（针对表单）</p><ul><li><code>p:first-child&#123;color:red;&#125;</code>     /<code>* 第一个p *</code>/</li><li><code>p:last-child&#123;color:red;&#125;</code>     /<code>* 最后一个p *</code>/</li></ul></li><li><p>伪元素选择器</p><ul><li><code>:before</code> 在元素之前添加内容。</li><li><code>:after</code> 在元素之后添加内容。</li></ul></li><li><p><code>css</code>优先规则</p><ul><li>内联样式表-&gt; <code>ID</code> 选择器—&gt; <code>Class</code> 类选择器-&gt;标签选择器</li></ul></li></ul><hr><h4 id="第十一章-背景属性"><a href="#第十一章-背景属性" class="headerlink" title="第十一章 背景属性"></a>第十一章 背景属性</h4><hr><ul><li><p>背景属性：</p><ul><li><p>背景的添加 ：</p></li><li><p>背景颜色的添加:</p><ul><li><code>background:red;</code></li><li><code>backgronnd-color:red;</code></li></ul></li><li><p>背景图片的添加：</p><ul><li><code>background:url(“images/1.jpg”);</code></li><li><code>backgronnd-image:url(“images/1.jpg”);</code></li></ul></li><li><p>背景的平铺</p></li><li><p>什么是平铺？平铺就是图片是否重复出现</p><ul><li>不平铺：<code>background-repeat:no-repeat;</code></li><li>水平方向平铺：<code>background-repeat:repeat-x;</code></li><li>垂直方向平铺：<code>background-repeat:repeat-y;</code></li><li>完全平铺：默认为完全平铺</li></ul></li><li><p>背景图片的定位</p><ul><li>背景图片的定位就是可以设置显示背景图片的位置，通过属性<code>background-position</code>来实现</li><li><code>background-position</code>的取值可为英文单词或者数值和百分值。</li><li><code>background-positon</code>的英文单词取值</li><li><code>top left </code>                   </li><li><code>top  center  </code>                   </li><li><code>top  right</code></li><li><code>center left  </code>            </li><li><code>center  center </code>                   </li><li><code>center right</code></li><li><code>bottom left  </code>           </li><li><code>bottom  center </code>    </li><li><code>ottom right</code></li></ul></li><li><p><code>background-positon</code>的数值取值     </p><ul><li><code>background-position:x  y;</code>  </li></ul></li><li><p><code>positon</code>的百分值取值     </p><ul><li><code>background-position:x%  y%; </code> </li></ul></li><li><p>背景图片的大小</p><ul><li>背景图片的大小可以通过属性<code>background-size</code>来设置<code>background-size</code>的取值可为数值和百分值。</li></ul></li><li><p><code>background-size</code>的数值取值     </p><ul><li><code>background-size:x  y;</code>  </li></ul></li><li><p><code>background-size</code>的数值取值     </p><ul><li><code>background-size:x%  y%;</code></li></ul></li><li><p>背景图片的滚动</p><ul><li><p>背景图片是否随着内容的滚动而滚动由<code>background-attachment</code>设置</p></li><li><p><code>background-attachment:fixed; </code>  固定，不随内容的滚动而滚动    </p></li><li><p><code>background-attachment:scroll; </code> 滚动，随内容的滚动而滚动</p></li></ul></li></ul></li></ul><hr><h4 id="第十二章-文字文本属性"><a href="#第十二章-文字文本属性" class="headerlink" title="第十二章 文字文本属性"></a>第十二章 文字文本属性</h4><hr><ul><li><p><code>css</code>文字文本属性：</p><ul><li><p><strong>文字属性</strong></p><ul><li><code>color:red;</code>    文字颜色</li><li><code>font-size:12px</code>;    文字大小</li><li><code>font-weight:“bold”</code>    文字粗细(<code>bold/normal</code>)</li><li><code>font-family:“宋体”</code>    文字字体</li><li><code>font-variant:small-caps </code>小写字母以大写字母显示</li></ul></li></ul></li></ul><ul><li><p><strong>文本属性</strong></p><ul><li><code>text-align:center;</code>   文本对齐(<code>right</code>/<code>left</code>/<code>center</code>)</li><li><code>line-height:10px; </code> 行间距(可通过它实现文本的垂直居中)</li><li><code>text-indent:20px;</code>  首行缩进</li><li><code>text-decoration:none; </code> <ul><li>文本线(<code>none</code>/<code>underline</code>/<code>overline</code>/<code>line-through</code>)</li></ul></li><li><code>letter-spacing</code>:   字间距</li></ul></li></ul><hr><h4 id="第十三章-盒子模型"><a href="#第十三章-盒子模型" class="headerlink" title="第十三章 盒子模型"></a>第十三章 盒子模型</h4><hr><ul><li><p><strong>盒子模型</strong></p><ul><li>盒子模型就是一个有高度和宽度的矩形区域</li><li>所有<code>html</code>标签都是盒子模型</li><li><code>div</code>标签自定义盒子模型</li></ul></li><li><p>所有的标签都是盒子模型</p><ul><li><code>class</code>和<code>id</code>的主要差别是：<code>class</code>用于元素组（类似的元素，或者可以理解为某一类元素），而<code>id</code>用于标识单独的唯一的元素。</li></ul></li><li><p><strong>盒子模型的组成</strong></p><ul><li>盒子模型组成部分：<ul><li>自身内容：<code> width</code>、h<code>eight</code> 宽高</li><li>内边距：   <code>padding</code></li><li>盒子边框： <code>border</code> 边框线</li><li>与其他盒子距离：  <code>margin </code>外边距</li><li>内容+内边距+边框+外边距=面积</li></ul></li></ul></li><li><p><code>border</code> 边框</p><ul><li>常见写法  <code>border:1px solid #f00;</code></li></ul></li><li><p>单独属性：</p><ul><li><code>border-width</code>:</li><li><code>border-style:</code> <ul><li><code>dotted </code> 点状虚线</li><li><code>dashed</code>（虚线）</li><li><code>solid</code>（实线）</li><li><code>double</code>（双实线）</li></ul></li><li><code>border-color</code> (颜色)</li></ul></li><li><p><code>padding</code> 内边距</p><ul><li><p>值：<code>像素</code>/<code>厘米</code>等长度单位、百分比</p><ul><li><code>padding:10px; </code>                      上下左右</li><li><code>padding:10px 10px; </code>                 上下  左右</li><li><code>padding:10px 10px 10px; </code>         上 左右 下</li><li><code>padding:10px 10px 10px 10px; </code> 上 右 下 左（设置4个点–&gt;顺时针方向）</li></ul></li></ul></li><li><p>单独属性：</p><ul><li><code>padding-top:</code></li><li><code>padding-right:</code></li><li><code>padding-bottom:</code></li><li><code> padding-left:</code></li></ul></li><li><p>当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据<code>width</code>和<code>height</code>减小</p></li><li><p>margin 外边距</p><ul><li><p>值：与<code>padding</code>相同</p></li><li><p>单独属性：与<code>padding</code>相同</p></li></ul></li><li><p>外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并</p></li></ul><hr><p><strong>补充盒子模型内容</strong></p><hr><ul><li><p><strong>标准盒子模型</strong></p><ul><li>盒子模型是<code>css</code>中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 <code>ie </code>盒子模型和标准 <code>w3c</code> 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型</li></ul></li></ul><p><img src="./H4C2/w3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li><p>从上图可以看到标准 <code>w3c</code> 盒子模型的范围包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code>，并且 <code>content </code>部分不包含其他部分</p></li><li><p>** IE盒子模型**</p></li></ul><p><img src="./H4C2/ie.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li><p>从上图可以看到 <code>ie </code>盒子模型的范围也包括 <code>margin</code>、<code>border</code>、<code>padding</code>、<code>content</code></p></li><li><p>和标准 <code>w3c</code> 盒子模型不同的是：<code>ie</code> 盒子模型的 <code>content</code> 部分包含了 <code>border </code>和 <code>padding</code></p></li><li><p><code>IE</code>盒子模型<code>width</code> = <code>padding</code>+<code>border</code>+<code>内容</code></p></li><li><p>标准盒子模型 = 内容的宽度（不包含<code>border</code>+<code>padding</code>）</p></li><li><p>例：</p><ul><li>一个盒子的   <code>margin</code>为 20px，<code>border</code> 为 1px，<code>padding </code>为 10px，<code>content</code> 的宽为 200px、高为 50px，假如用标准 <code>w3c</code> 盒子模型解释，那么这个盒子需要占据的位置为：宽 <code>20*2+1*2+10*2+200=262px</code>、高 <code>20*2+1*2*10*2+50=112px</code>，盒子的实际大小为：宽 <code>1*2+10*2+200=222px</code>、高 <code>1*2+10*2+50=72px</code>；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 <code>20*2+200=240px</code>、高 <code>20*2+50=70px</code>，盒子的实际大小为：宽 <code>200px</code>、高 <code>50px</code></li></ul></li><li><p>那应该选择哪中盒子模型呢？当然是“标准 <code>w3c</code> 盒子模型”了。怎么样才算是选择了“标准 <code>w3c </code>盒子模型”呢？很简单，就是在网页的顶部加上 <code>doctype</code> 声明。</p></li><li><p>假如不加<code> doctype</code> 声明，那么各个浏览器会根据自己的行为去理解网页，即 <code>ie </code>浏览器会采用 <code>ie</code> 盒子模型去解释你的盒子，而 <code>ff </code>会采用标准<code> w3c</code> 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。</p></li><li><p>反之，假如加上了 <code>doctype</code> 声明，那么所有浏览器都会采用标准 <code>w3c </code>盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。</p></li></ul><hr><ul><li>用 <code>jquery</code> 做的例子来证实一下</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你用的盒子模型是？<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> sbox = $.boxmodel ? <span class="hljs-string">&quot;标准w3c&quot;</span>:<span class="hljs-string">&quot;ie&quot;</span>;</span><br><span class="javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您的页面目前支持：&quot;</span>+sbox+<span class="hljs-string">&quot;盒子模型&quot;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>　上面的代码没有加上 <code>doctype</code> 声明，在 <code>ie</code> 浏览器中显示  <code>ie</code>盒子模型，在 ff 浏览器中显示“标准<code>w3c</code> 盒子模型”。</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">public</span> <span class="hljs-meta-string">&quot;-//w3c//dtd xhtml 1.0 transitional//en&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你用的盒子模型是标准w3c盒子模型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> sbox = $.boxmodel ? <span class="hljs-string">&quot;标准w3c&quot;</span>:<span class="hljs-string">&quot;ie&quot;</span>;</span><br><span class="javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您的页面目前支持：&quot;</span>+sbox+<span class="hljs-string">&quot;盒子模型&quot;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>　代码2 与代码1 唯一的不同的就是顶部加了 <code>doctype </code>声明。在所有浏览器中都显示“标准 <code>w3c </code>盒子模型”</li></ul><ul><li><p> 所以为了让网页能兼容各个浏览器，让我们用标准 <code>w3c</code> 盒子模型</p></li><li><p>扩展</p><ul><li><a href="http://www.jianshu.com/p/e2eb0d8c9de6">学会使用box-sizing布局</a></li></ul></li></ul><hr><h4 id="第十四章-块元素、行元素与溢出"><a href="#第十四章-块元素、行元素与溢出" class="headerlink" title="第十四章 块元素、行元素与溢出"></a>第十四章 块元素、行元素与溢出</h4><hr><ul><li><p>基本概念</p><ul><li>块级元素：默认情况下独占一行的元素，可控制宽高、上下边距；</li><li>行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距</li></ul></li><li><p>行块转换</p><ul><li><code>display:none</code>;  不显示</li><li><code>display:block</code>; 变成块级元素</li><li><code>display:inline</code>; 变成行级元素</li><li><code>display:inline-block</code>; 以块级元素样式展示，以行级元素样式排列</li></ul></li><li><p>溢出</p><ul><li><code>overflow:hidden</code>;   溢出隐藏</li><li><code>overflow:scroll</code>;   内容会被修剪，浏览器会显示滚动条</li><li><code>overflow:auto</code>;   如果内容被修剪，则产生滚动条</li></ul></li><li><p>文本不换行：<code>white-space:nowrap</code>;</p></li><li><p>长单词换行：<code>word-wrap:break-word</code>;</p></li></ul><ul><li><p>行内元素和快级元素小结</p><ul><li><p>一、<strong>块级元素</strong>：block element</p><ul><li><p>每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（<code>float</code>浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；</p></li><li><p>块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。</p></li><li><p><code>DIV</code> 是最常用的块级元素，元素样式的<code>display:block</code>都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。</p></li></ul></li><li><p>二、<strong>行内元素</strong>：inline element</p><ul><li>也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 <code>SPAN </code>元素，<code>IFRAME</code>元素和元素样式的<code>display : inline</code>的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。</li></ul></li><li><p>三、<strong>block（块）元素的特点:</strong></p><ul><li>①、总是在新行上开始；</li><li>②、高度，行高以及外边距和内边距都可控制；</li><li>③、宽度缺省是它的容器的100%，除非设定一个宽度。</li><li>④、它可以容纳内联元素和其他块元素</li></ul></li><li><p>四、<strong>inline元素的特点</strong></p><ul><li>①、和其他元素都在一行上；</li><li>②、高，行高及外边距和内边距不可改变；</li><li>③、宽度就是它的文字或图片的宽度，不可改变</li><li>④、内联元素只能容纳文本或者其他内联元素</li></ul></li><li><p><strong>对行内元素，需要注意如下</strong>:</p><ul><li>设置宽度<code>width</code> 无效。 设置高度<code>height </code>无效，可以通过<code>line-height</code>来设置。 设置<code>margin</code></li><li>只有左右<code>margin</code>有效，上下无效。</li><li>设置<code>padding</code>只有左右<code>padding</code>有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。</li></ul></li><li><p>五、<strong>常见的块状元素</strong></p><ul><li><code>address</code> – 地址</li><li><code>blockquote</code> – 块引用</li><li><code>center</code> – 举中对齐块</li><li><code>dir</code> – 目录列表</li><li><code>div</code> – 常用块级容易，也是<code>CSS layout</code>的主要标签</li><li><code>dl</code> – 定义列表</li><li><code>fieldset</code> – <code>form</code>控制组</li><li><code>form</code> – 交互表单</li><li><code>h1</code> – 大标题</li><li><code>h2</code> – 副标题</li><li><code>h3</code> – 3级标题</li><li><code>h4</code> – 4级标题</li><li><code>h5</code> – 5级标题</li><li><code>h6</code> – 6级标题</li><li><code>hr</code> – 水平分隔线</li><li><code>isindex</code> – <code>input prompt</code></li><li><code>menu</code> – 菜单列表</li><li><code>noframes</code> – <code>frames</code>可选内容，（对于不支持frame的浏览器显示此区块内容</li><li><code>noscript</code> – 可选脚本内容（对于不支持<code>script</code>的浏览器显示此内容）</li><li><code>ol</code> – 有序表单</li><li><code>p</code> – 段落</li><li><code>pre</code> – 格式化文本</li><li><code>table</code> – 表格</li><li><code>ul</code> – 无序列表</li></ul></li><li><p>六、<strong>常见的内联元素</strong></p><ul><li><code>a</code> – 锚点</li><li><code>abbr</code> – 缩写</li><li><code>acronym</code> – 首字</li><li><code>b</code> – 粗体(不推荐)</li><li><code>bdo</code> – <code>bidi override</code></li><li><code>big</code> – 大字体</li><li><code>br</code> – 换行</li><li><code>cite</code> – 引用</li><li><code>code</code> – 计算机代码(在引用源码的时候需要)</li><li><code>dfn</code> – 定义字段</li><li><code>em</code> – 强调</li><li><code>font</code> – 字体设定(不推荐)</li><li><code>i</code> – 斜体</li><li><code>img</code> – 图片</li><li><code>input</code> – 输入框</li><li><code>kbd</code> – 定义键盘文本</li><li><code>label</code> – 表格标签</li><li><code>q</code> – 短引用</li><li><code>s</code> – 中划线(不推荐)</li><li><code>samp</code> – 定义范例计算机代码</li><li><code>select</code> – 项目选择</li><li><code>small</code> – 小字体文本</li><li><code>span</code> – 常用内联容器，定义文本内区块</li><li><code>strike</code> – 中划线</li><li><code>strong</code> – 粗体强调</li><li><code>sub</code> – 下标</li><li><code>sup</code> – 上标</li><li><code>textarea</code> – 多行文本输入框</li><li><code>tt</code> – 电传文本</li><li><code>u</code> – 下划线</li></ul></li><li><p>七，<strong>可变元素</strong></p><ul><li>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</li><li><code>applet</code> - <code>java applet</code></li><li><code>button</code> - 按钮</li><li><code>del </code>- 删除文本</li><li><code>iframe</code> - <code>inline frame</code></li><li><code>ins</code> - 插入的文本</li><li><code>map</code> - 图片区块(<code>map</code>)</li><li><code>object</code> - <code>object</code>对象</li><li><code>script</code> - 客户端脚本</li></ul></li><li><p>八、<strong>行内元素与块级元素有什么不同</strong></p><ul><li><p>区别一：</p><ul><li>块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度</li><li>行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。</li></ul></li><li><p>区别二：</p><ul><li>块级：块级元素可以设置宽高</li><li>行内：行内元素不可以设置宽高</li></ul></li><li><p>区别三：</p><ul><li>块级：块级元素可以设置<code>margin</code>，<code>padding</code></li><li>行内：行内元素水平方向的<code>margin-left;</code> <code>margin-right;</code></li></ul></li><li><p><code>padding-left;</code> <code>padding-right</code>;可以生效。但是竖直方向的<code>margin-bottom</code>; <code>margin-top</code>; <code>padding-top</code>; <code>padding-bottom</code>;却不能生效。</p></li><li><p>区别四：</p><ul><li>块级：<code>display:block</code>;</li><li>行内：<code>display:inline</code>;</li></ul></li></ul></li><li><p>替换元素有如下：（和<code>img</code>一样的设置方法）</p><ul><li><code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code></li><li><code>&lt;object&gt;</code>都是替换元素，这些元素都没有实际的内容</li></ul></li></ul></li><li><p>可以通过修改<code>display</code>属性来切换块级元素和行内元素</p></li></ul><hr><h4 id="第十五章-定位"><a href="#第十五章-定位" class="headerlink" title="第十五章 定位"></a>第十五章 定位</h4><hr><ul><li><p><code>static</code>静态定位（不对它的位置进行改变，在哪里就在那里）</p><ul><li> 默认值。没有定位，元素出现在正常的流中（忽略 <code>top</code>,<code> bottom,</code>  <code>left, right</code> 或者 <code>z-index</code> 声明）。</li></ul></li><li><p><code>fixed</code>固定定位（参照物–浏览器窗口）—做 弹窗广告用到</p><ul><li>生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 <code>&quot;left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot; </code>以及 <code>&quot;bottom&quot; </code>属性进行规定。 </li></ul></li><li><p><code>relative</code>（相对定位 ）（参照物以他本身）</p><ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li><p><code>absolute</code>（绝对定位）(除了<code>static</code>都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位)</p><ul><li>生成绝对定位的元素，相对于 <code>static</code> 定位以外的第一个父元素进行定位。</li><li>元素的位置通过 “<code>left&quot;</code>, <code>&quot;top&quot;</code>, <code>&quot;right&quot;</code> 以及 <code>&quot;bottom&quot;</code> 属性进行规定</li></ul></li><li><p>z-index</p><ul><li><code>z-index</code> 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</li><li>定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</li></ul></li><li><p>一切皆为框</p><ul><li>块级元素: <code>div</code>、<code>h1</code>或<code>p</code>元素 即：显示为一块内容称之为 “块框“ ;</li><li>行内元素: <code>span</code>,<code>strong</code>,<code>a</code>等元素 即：内容显示在行中称 “行内框”;</li><li>使用display属性改变成框的类型 即：<code>display:block</code>; 让行内元素设置为块级元素，<code>display:none;</code> 没有框</li></ul></li><li><p>相对定位：</p><ul><li>如果对一个元素进行相对定位，它将出现在它所在的位置上。 </li><li>通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动</li><li><code>.adv_relative &#123;  position: relative;  left: 30px;  top: 20px; &#125;</code></li></ul></li><li><p>绝对定位：</p><ul><li>元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 <code>.adv_absolute &#123;  position: absolute;  left: 30px;  top: 20px; &#125;</code></li></ul></li></ul><hr><p><img src="./H4C2/danci.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="./H4C2/position.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><h4 id="第十六章-框架"><a href="#第十六章-框架" class="headerlink" title="第十六章 框架"></a>第十六章 框架</h4><hr><ul><li><p><code>frameset</code>框架：</p><ul><li><code>&lt;frameset&gt; </code> —-  用来定义一个框架；双标签<br>不能和  <code>&lt;body&gt;</code>  一起使用</li></ul></li><li><p><code>rows</code>、<code>cols</code>属性</p><ul><li><code>rows </code> 定义行表示框架有多少行（取值 <code>px </code>/<code>%</code>/ <code>*</code> ）</li><li><code>cols</code>   定义列表示框架有多少列（取值<code>px</code>/ <code>% </code>/ <code>*</code> ）</li></ul></li><li><p>frame子框架</p><ul><li><p>&lt;<code>frame</code>&gt;  —-  表示框架中的某一个部分；单标签，要跟结束标志</p><ul><li><code>src</code> 显示的网页的路径</li><li><code>name</code> 框架名</li><li><code>frameborder</code>  边框线（取值 0 / 1）</li></ul></li><li><p>&lt;<code>noframes</code>&gt;属性</p></li><li><p>&lt;<code>noframes</code>&gt; 提供不支持框架的浏览器显示<code>body</code>的内容；双标签</p></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">“”</span>  /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">“”</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">“”</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">noframes</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">noframes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><code>&lt;iframe&gt;</code>内联框架<ul><li><code>iframe </code>元素会创建包含另外一个文档的内联框架（即行内框架）</li><li>允许和 <code>body</code> 一起使用</li><li><code>width</code> 宽（取值 px / %）</li><li><code>height</code> 高（取值 px / %）</li><li><code>name</code> 框架名</li><li><code>frameborder </code> 边框线（取值 0 / 1）</li><li><code>src</code> 显示的网页的路径</li></ul></li></ul><hr><h4 id="第十七章-css高级属性"><a href="#第十七章-css高级属性" class="headerlink" title="第十七章 css高级属性"></a>第十七章 css高级属性</h4><hr><ul><li><code>opacity</code>透明属性<ul><li><code>opacity</code><ul><li>对于<code>IE6/7/</code>，使用<code>filter:alpha(opacity:值;</code>)  值为<code>0-100</code></li><li>对于<code>Webkit</code>，<code>Opera</code>，<code>Firefox</code>，<code>IE9+</code>，使用<code>opacity</code>:值; 值为<code>0-1</code></li><li>对于早期火狐，使用<code>-moz-opacity</code>:值; 值为<code>0-1</code></li><li>所以写透明属性时，一般写法是</li></ul></li></ul></li></ul><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"> &#123;<br>    <span class="hljs-attribute">opacity</span>:<span class="hljs-number">0.5</span>;<br>   <span class="hljs-attribute">filter</span>:alpha(opacity：<span class="hljs-number">50</span>);<span class="hljs-comment">/*0-100*/</span><br>   -moz-<span class="hljs-attribute">opacity</span>:<span class="hljs-number">0.5</span>;<span class="hljs-comment">/*取值0-1*/</span>--&gt;针对早起版本的火狐兼容问题的解决<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p><code>border-radius</code>圆角边框属性</p><ul><li>向 <code>div</code> 元素添加圆角边框<ul><li><code>border-radius:10px</code>;</li></ul></li></ul></li><li><p><code>box-shadow</code>阴影属性</p><ul><li><p><code>box-shadow </code>属性向框添加阴影效果,后面跟4个参数。</p></li><li><p><code>box-shadow:0px   0px   10px   #000;</code></p></li></ul></li><li><p><code>&lt;embed&gt;</code>属性</p><ul><li><p>是<code>HTML5</code>中新增的标签,媒体嵌入插件标签，可以通过<code>&lt;embed&gt;</code>插入音频或视频</p></li><li><p><code>&lt;embed src=“media/music.mp3” /&gt;</code></p></li><li><p>格式<code>.mid </code> <code>.wav</code> <code>.mp3</code>等</p></li></ul></li></ul><hr><hr><p><img src="./H4C2/overflow.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><ul><li><a href="https://yunpan.cn/cM9va2bHD4wwu">原文件下载地址</a>   访问密码 342a</li></ul><hr><p><img src="./H4C2/csstixi.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><ul><li><code>css</code>常见简写</li></ul><p><img src="./H4C2/sucha.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css简写速查"></p><hr><h3 id="第三部分-附录"><a href="#第三部分-附录" class="headerlink" title="第三部分 附录"></a>第三部分 附录</h3><hr><h4 id="附录一-CSS书写规范"><a href="#附录一-CSS书写规范" class="headerlink" title="附录一 CSS书写规范"></a>附录一 CSS书写规范</h4><blockquote><p>为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入</p></blockquote><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 放置所有浏览器样式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;</span><br><span class="hljs-comment">&lt;!--[if IE]</span><br><span class="hljs-comment">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</span><br><span class="hljs-comment">&lt;![endif]--&gt;</span><br></code></pre></div></td></tr></table></figure><p>CSS样式新建或修改尽量遵循以下原则</p><p>根据新建样式的适用范围分为三级：全站级、产品级、页面级。 尽量通过继承和层叠重用已有样式。 不要轻易改动全站级CSS。改动后，要经过全面测试。</p><hr><ul><li><p>属性显示顺序（规范写法）</p><ul><li>显示属性</li><li>元素位置</li><li>元素属性</li><li>元素内容属性</li></ul></li><li><p>CSS书写顺序</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS">  <span class="hljs-selector-class">.header</span> &#123;<br><span class="hljs-comment">/* 显示属性 */</span><br>    display || visibility<br>    <span class="hljs-selector-tag">list-style</span><br>    position top || right || bottom || left<br>    <span class="hljs-selector-tag">z-index</span><br>    <span class="hljs-selector-tag">clear</span><br>    <span class="hljs-selector-tag">float</span><br><span class="hljs-comment">/* 自身属性 */</span><br>    width max-width || min-width<br>    height max-height || min-height<br>    overflow || clip<br>    <span class="hljs-selector-tag">margin</span><br>    <span class="hljs-selector-tag">padding</span><br>    <span class="hljs-selector-tag">outline</span><br>    <span class="hljs-selector-tag">border</span><br>    <span class="hljs-selector-tag">background</span><br><span class="hljs-comment">/* 文本属性 */</span><br>    <span class="hljs-selector-tag">color</span><br>    <span class="hljs-selector-tag">font</span><br>    <span class="hljs-selector-tag">text-overflow</span><br>    <span class="hljs-selector-tag">text-align</span><br>    <span class="hljs-selector-tag">text-indent</span><br>    <span class="hljs-selector-tag">line-height</span><br>    <span class="hljs-selector-tag">white-space</span><br>    <span class="hljs-selector-tag">vertical-align</span><br>    <span class="hljs-selector-tag">cursor</span><br>    <span class="hljs-selector-tag">content</span><br>  &#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>兼容多个浏览器时，将标准属性写在底部</p></li></ul><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">-moz-<span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px; <span class="hljs-comment">/* Firefox */</span><br>-webkit-<span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px; <span class="hljs-comment">/* Safari和Chrome */</span><br><span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px; <span class="hljs-comment">/* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 */</span>/标准属性<br></code></pre></div></td></tr></table></figure><ul><li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式</li></ul><p><code>.hd,.bd,.td&#123;&#125;;//如这些命名</code></p><ul><li>可用上级节点进行限定</li></ul><p><code>.recommend-mod .hd</code></p><ul><li>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</li></ul><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.btn</span>,<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.btn</span>,<br>input[type=&quot;button&quot;] &#123;…&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>优化CSS选择器</li></ul><p><code>#header a &#123; color: #444; &#125;;/*CSS选择器是从右边到左边进行匹配*/</code></p><p>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS">避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器<br>不要限定<span class="hljs-selector-tag">id</span>选择符，如<span class="hljs-selector-tag">div</span><span class="hljs-selector-id">#header</span>（提权的除外）<br>不要限定类选择器，如<span class="hljs-selector-tag">ul</span><span class="hljs-selector-class">.recommend</span>（提权的除外）<br>不要使用 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> 这样长的选择符<br>避免使用标签子选择符，如<span class="hljs-selector-id">#header</span> &gt; <span class="hljs-selector-tag">li</span> &gt; <span class="hljs-selector-tag">a</span><br></code></pre></div></td></tr></table></figure><p>使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。 尽量避免使用CSS Hack</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* 所有浏览器 */</span><br>+<span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* IE7 */</span><br>_<span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* IE6 */</span><br>*<span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>; <span class="hljs-comment">/* IE6/7 */</span><br><span class="hljs-selector-tag">property</span><span class="hljs-selector-pseudo">:value</span>\9; <span class="hljs-comment">/* IE6/7/8/9，即所有IE浏览器 */</span><br><br>\* html selector &#123; … &#125;; /* IE6 */<br>\*:first-child+html selector &#123; … &#125;; /* IE7 */<br>html&gt;body selector &#123; … &#125;; /* 非IE6 */<br><span class="hljs-keyword">@-moz-document</span> url-prefix() &#123; … &#125;; <span class="hljs-comment">/* firefox */</span><br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span><span class="hljs-number">0</span>) &#123; … &#125;; <span class="hljs-comment">/* saf3+/chrome1+ */</span><br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span><span class="hljs-number">10000</span>),<span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio:</span><span class="hljs-number">0</span>) &#123; … &#125;; <span class="hljs-comment">/* opera */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-device-width:</span> <span class="hljs-number">480px</span>) &#123; … &#125;; <span class="hljs-comment">/* iPhone/mobile webkit */</span><br></code></pre></div></td></tr></table></figure><p>避免使用低效的选择器</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">body &gt; * &#123;…&#125;;<br>ul &gt; li &gt; a &#123;…&#125;;<br>#footer &gt; h3 &#123;…&#125;;<br>ul#top_blue_nav &#123;…&#125;;<br>#searbar span.submit a &#123; … &#125;; /* 反面示例 */<br></code></pre></div></td></tr></table></figure><p>六个不要三个避免一个使用</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">不要在标签上直接写样式<br>不要在<span class="hljs-selector-tag">CSS</span>中使用<span class="hljs-selector-tag">expression</span><br>不要在<span class="hljs-selector-tag">CSS</span>中使用<span class="hljs-keyword">@import</span><br>不要在CSS中使用!important<br>不要在CSS中使用“*”选择符<br>不要将CSS样式写为单行<br>避免使用filter<br>避免使用行内（inline）样式<br>避免使用“*”设置&#123;<span class="hljs-selector-tag">margin</span>: 0; <span class="hljs-selector-tag">padding</span>: 0;&#125;<br>使用<span class="hljs-selector-tag">after</span>或<span class="hljs-selector-tag">overflow</span>的方式清浮动<br></code></pre></div></td></tr></table></figure><p>减少使用影响性能的属性</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-comment">//如这些定位或浮动属性</span><br></code></pre></div></td></tr></table></figure><p>减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px</p><hr><h4 id="附录二-DIV命名规范"><a href="#附录二-DIV命名规范" class="headerlink" title="附录二 DIV命名规范"></a>附录二 DIV命名规范</h4><hr><ul><li><p>企业<code>DIV</code>使用频率高的命名方法</p></li><li><p><strong>网页内容类</strong></p><ul><li><p>标题: <code>title</code></p><ul><li>摘要: <code>summary</code></li><li>箭头： <code>arrow</code></li><li>商标： <code>label</code></li><li>网站标志： <code>logo</code></li><li>转角/圆角：<code> corner</code></li><li>横幅广告： <code>banner</code></li><li>子菜单： <code>subMenu</code></li><li>搜索： <code>search</code></li><li>搜索框： <code>searchBox</code></li><li>登录： <code>login</code></li><li>登录条：<code>loginbar</code></li><li>工具条： <code>toolbar</code></li><li>下拉： <code>drop</code></li><li>标签页： <code>tab</code></li><li>当前的： <code>current</code></li><li>列表： <code>list</code></li><li>滚动： <code>scroll</code></li><li>服务： <code>service</code></li><li>提示信息： <code>msg</code></li><li>热点：<code>hot</code></li><li>新闻： <code>news</code></li><li>小技巧： <code>tips</code></li><li>下载： <code>download</code></li><li>栏目标题： <code>title</code></li><li>热点： <code>hot</code></li><li>加入：<code> joinus</code></li><li>注册： <code>regsiter</code></li><li>指南： <code>guide</code></li><li>友情链接： <code>friendlink</code></li><li>状态： <code>status</code></li><li>版权： <code>copyright</code></li><li>按钮： <code>btn</code></li><li>合作伙伴： <code>partner</code></li><li>投票： <code>vote</code></li><li>左右中：<code>left</code>  <code>right</code>  <code>center</code></li></ul><hr></li><li><p>注释的写法: <code>/* Footer */ </code> 内容区<code>/* End Footer */</code></p></li></ul></li><li><p><strong>id的命名:</strong></p><ul><li><p>页面结构</p><ul><li>容器: <code>container</code></li><li>页头：<code>header</code></li><li>内容：<code>content</code>/<code>container</code></li><li>页面主体：<code>main</code></li><li>页尾：<code>footer</code></li><li>导航：<code>nav</code></li><li>侧栏：<code>sidebar</code></li><li>栏目：<code>column</code></li><li>页面外围控制整体布局宽度：<code>wrapper</code></li><li>左右中：<code>left</code> <code>right</code> <code>center</code></li></ul></li></ul><hr><ul><li><p>导航</p><ul><li>导航：<code>nav</code></li><li>主导航：<code>mainbav</code></li><li>子导航：<code>subnav</code></li><li>顶导航：<code>topnav</code></li><li>边导航：<code>sidebar</code></li><li>左导航：<code>leftsidebar</code></li><li>右导航：<code>rightsidebar</code></li><li>菜单：<code>menu</code></li><li>子菜单：<code>submenu</code></li><li>标题: <code>title</code></li><li>摘要: <code>summary</code></li></ul></li></ul><hr><ul><li><p>功能</p><ul><li>标志：<code>logo</code></li><li>广告：<code>banner</code></li><li>登陆：<code>login</code></li><li>登录条：<code>loginbar</code></li><li>注册：<code>regsiter</code></li><li>搜索：<code>search</code></li><li>功能区：<code>shop</code></li><li>标题：<code>title</code></li><li>加入：<code>joinus</code></li><li>状态：<code>status</code></li><li>按钮：<code>btn</code></li><li>滚动：<code>scroll</code></li><li>标签页：<code>tab</code></li><li>文章列表：<code>list</code></li><li>提示信息：<code>msg</code></li><li>当前的:<code> current</code></li><li>小技巧：<code>tips</code></li><li>图标: <code>icon</code></li><li>注释：<code>note</code></li><li>指南：<code>guild</code></li><li>服务：<code>service</code></li><li>热点：<code>hot</code></li><li>新闻：<code>news</code></li><li>下载：<code>download</code></li><li>投票：<code>vote</code></li><li>合作伙伴：<code>partner</code></li><li>友情链接：<code>link</code></li><li>版权：<code>copyright</code></li></ul></li></ul><hr><ul><li><p><strong><code>class</code>的命名:</strong></p></li><li><p>颜色:使用颜色的名称或者16进制代码,如</p><ul><li><code>.red &#123; color: red; &#125;</code></li><li><code>.f60 &#123; color: #f60; &#125;</code></li><li><code>.ff8600 &#123; color: #ff8600; &#125;</code></li></ul></li><li><p>字体大小,直接使用”font+字体大小”作为名称,如</p><ul><li><code>.font12px &#123; font-size: 12px; &#125;</code></li><li><code>.font9px &#123;font-size: 9pt; &#125;</code></li></ul></li><li><p>对齐样式,使用对齐目标的英文名称,如</p><ul><li><code>.left &#123; float:left; &#125;</code></li><li><code>.bottom &#123; float:bottom; &#125;</code></li></ul></li><li><p>标题栏样式,使用”类别+功能”的方式命名,如</p><ul><li><code> .barnews &#123; &#125;</code></li><li><code>.barproduct &#123; &#125;</code></li></ul><hr></li><li><p><strong>注意事项::</strong></p><ul><li>一律小写;</li><li>尽量用英文;</li><li>不加中杠和下划线;</li><li>尽量不缩写，除非一看就明白的单词.</li></ul><hr></li></ul></li><li><p><strong>推荐的 <code>CSS</code> 书写顺序：</strong></p><ul><li><p>显示属性</p><ul><li><code>display</code></li><li><code>list-style</code></li><li><code>position</code></li><li><code>float</code></li><li><code>clear</code></li></ul></li><li><p>自身属性</p><ul><li><code> width</code></li><li><code>height</code></li><li><code>margin</code></li><li><code>padding</code></li><li><code>border</code></li><li><code>background</code></li></ul></li><li><p>文本属性</p><ul><li><code>color</code></li><li><code> font</code></li><li><code>text-decoration</code></li><li><code>text-align</code></li><li><code>vertical-align</code></li><li><code>white-space</code></li><li><code>other text</code></li><li><code>content </code>    </li></ul></li></ul></li></ul><hr><h4 id="附录三-CSS精灵"><a href="#附录三-CSS精灵" class="headerlink" title="附录三 CSS精灵"></a>附录三 CSS精灵</h4><hr><ul><li><p><strong>CSS精灵原理以及应用</strong></p><ul><li><code>CSS</code>雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。<ul><li>该图片使用<code>CSS</code>   <code>background和background-position</code>属性渲染，这也就意味着你的标签变得更加复杂了，图片是在<code>CSS</code>中定义，而非<code>&lt;img&gt;</code>标签。</li></ul></li></ul></li><li><p><strong>一个简单的例子</strong>：</p><ul><li>一张图片作出一个按钮的三个状态</li><li>一个链接用<code>CSS</code>做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，<code>a:link</code>，<code>a:hover</code>，<code>a:active</code> <code>&lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt;</code></li><li>加入右侧的图片为：<code>200px 65px</code>的三个按钮图拼合而成的图片<code>button.png</code>，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用<code>CSS</code>进行定义。<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">display</span>:block; <br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>; <br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">65px</span>; <br>    <span class="hljs-attribute">line-height</span>:<span class="hljs-number">65px</span>; <span class="hljs-comment">/*定义状态*/</span><br>    <span class="hljs-attribute">text-indent</span>:-<span class="hljs-number">2015px</span>; <span class="hljs-comment">/*隐藏文字*/</span><br>    <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(button.png); <span class="hljs-comment">/*定义背景图片*/</span><br>    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*定义链接的普通状态，此时图像显示的是顶上的部分*/</span><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">0</span> -<span class="hljs-number">66px</span>;<br>    <span class="hljs-comment">/*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/</span><br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">0</span> -<span class="hljs-number">132px</span>;                      <br>    <span class="hljs-comment">/*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>更多的<code>CSS</code>雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值</p><ul><li>如：<code>background:url(nav.png) -180px 24pxno-repeat</code>; 来达到更精确的定位</li></ul></li><li><p><strong>优点：</strong></p><ul><li>减少加载网页图片时对服务器的请求次数</li><li>可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</li><li>提高页面的加载速度</li><li><code>sprite </code>技术的其中一个好处是图片的加载时间(在有许多 <code>sprite</code> 时，单张图片的加载时间)。由所需图片拼成的一张 <code>GIF</code>图片的尺寸会明显小于所有图片拼合前的大小。单张的 <code>GIF</code>只有相关的一个色表，而单独分割的每一张 <code>GIF</code> 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 <code>JPEG</code> 或者 <code>PNG</code> <code>sprite</code> 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。</li><li>减少鼠标滑过的一些<code>bug</code></li><li><code>IE6</code>不会主动预加载鼠标滑过即<code>a:hover</code>中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用<code>CSS</code>雪碧，由于一张图片即可，所以不会出现这种现象。</li></ul></li><li><p><strong>不足：</strong></p><ul><li><code>CSS</code>雪碧的最大问题是内存使用</li><li>影响浏览器的缩放功能</li><li>拼图维护比较麻烦</li><li>使<code>CSS</code>的编写变得困难</li><li><code>CSS</code> 雪碧调用的图片不能被打印</li><li>错误得使用 <code>Sprites</code> 影响可访问性</li></ul></li></ul><h4 id="附录四-一些tips解决方案"><a href="#附录四-一些tips解决方案" class="headerlink" title="附录四 一些tips解决方案"></a>附录四 一些tips解决方案</h4><hr><h5 id="页面优化实践"><a href="#页面优化实践" class="headerlink" title="页面优化实践"></a>页面优化实践</h5><hr><ul><li><p>从下面的几个方面可以进行页面的优化：</p><ul><li>减少请求数</li><li>图片合并</li><li><code>CSS </code>文件合并</li><li>减少内联样式</li><li>避免在 <code>CSS </code>中使用 <code>import</code></li><li>减少文件大小</li><li>选择适合的图片格式</li><li>图片压缩</li><li><code>CSS</code> 值缩写（<code>Shorthand Property</code>)</li><li>文件压缩</li><li>页面性能</li><li>调整文件加载顺序</li><li>减少标签数量</li><li>调整选择器长度</li><li>尽量使用<code> CSS</code> 制作显示表现</li><li>增强代码可读性与可维护性</li><li>规范化</li><li>语义化</li><li>模块化</li></ul></li></ul><h5 id="写DIV-CSS-的一些常识"><a href="#写DIV-CSS-的一些常识" class="headerlink" title="写DIV+CSS 的一些常识"></a>写DIV+CSS 的一些常识</h5><hr><ul><li><p>不要使用过小的图片做背景平铺</p><ul><li>这就是为何很多人都不用 <code>1px</code> 的原因，这才知晓。宽高 <code>1px</code> 的图片平铺出一个宽高 <code>200px</code> 的区域，需要 <code>200200=40, 000</code> 次，占用资源</li></ul></li><li><p>无边框</p><ul><li>推荐的写法是 <code>border:none</code>;，哈哈，我一直在用这个。 <code>border:0;</code> 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源</li></ul></li><li><p>慎用 通配符</p><ul><li>所谓通配符，就是将<code> CSS</code> 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。</li></ul></li><li><p><code>CSS </code>的十六进制颜色代码缩写</p><ul><li>习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。</li></ul></li><li><p> 样式放头上，脚本放脚下。不内嵌，只外链</p></li><li><p> 坚决不用 <code>CSS </code>表达式</p></li><li><p>使用 引用样式表，而不是通过<code> @import</code> 导入。</p></li><li><p> 一般来说，<code>PNG </code>比 <code>GIF</code> 要小，小得多。再者，<code>GIF</code> 中有多少颜色是被浪费的，很值得优化。</p></li><li><p>千万不要在 <code>HTML </code>中缩放图片，一者不好看，二者占资源。</p></li><li><p>正文字体最好用偶数</p><ul><li><code>12px</code>、<code>14px</code>、<code>16px</code>，效果非常好。特例，<code>15px</code>。</li></ul></li><li><p><code>block</code>、<code>ul</code>、<code>ol </code>等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。</p></li><li><p>段落之间，至少要有一倍行距</p></li><li><p>强行指定某些元素的 <code>line-height</code>，正文 <code>1.6 </code>倍于文字大小，标题<code>1.3 </code>倍。</p></li><li><p>中文标点用全角</p><ul><li>英文夹杂在中文中，左右空格，半角。</li></ul></li><li><p>中文字体的粗体和斜体，远离较好</p></li></ul><h5 id="常用代码片段"><a href="#常用代码片段" class="headerlink" title="常用代码片段"></a>常用代码片段</h5><hr><ul><li>雅虎工程师提供的<code>CSS</code>初始化示例代码【仅供参考】<ul><li>可以在<code>html</code>头文件中直接引用，从而避免浏览器的不兼容带来的错误。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<br><span class="hljs-selector-tag">div</span>,<br><span class="hljs-selector-tag">dl</span>,<br><span class="hljs-selector-tag">dt</span>,<br><span class="hljs-selector-tag">dd</span>,<br><span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-tag">li</span>,<br><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-tag">h2</span>,<br><span class="hljs-selector-tag">h3</span>,<br><span class="hljs-selector-tag">h4</span>,<br><span class="hljs-selector-tag">h5</span>,<br><span class="hljs-selector-tag">h6</span>,<br><span class="hljs-selector-tag">pre</span>,<br><span class="hljs-selector-tag">code</span>,<br><span class="hljs-selector-tag">form</span>,<br><span class="hljs-selector-tag">fieldset</span>,<br><span class="hljs-selector-tag">legend</span>,<br><span class="hljs-selector-tag">input</span>,<br><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">textarea</span>,<br><span class="hljs-selector-tag">p</span>,<br><span class="hljs-selector-tag">blockquote</span>,<br><span class="hljs-selector-tag">th</span>,<br><span class="hljs-selector-tag">td</span> &#123; <br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>; <br>    <span class="hljs-attribute">color</span>:<span class="hljs-number">#555</span>; <br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>; <br>    <span class="hljs-attribute">font-family</span>: Verdana, Arial, Helvetica, sans-serif; <br>&#125;<br><span class="hljs-selector-tag">td</span>,<br><span class="hljs-selector-tag">th</span>,<br><span class="hljs-selector-tag">caption</span> &#123; <br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;<br>&#125;<br><span class="hljs-selector-tag">h1</span>, <br><span class="hljs-selector-tag">h2</span>, <br><span class="hljs-selector-tag">h3</span>, <br><span class="hljs-selector-tag">h4</span>, <br><span class="hljs-selector-tag">h5</span>, <br><span class="hljs-selector-tag">h6</span> &#123; <br>    <span class="hljs-attribute">font-weight</span>:normal; <br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>; <br>&#125;<br><br><span class="hljs-selector-tag">address</span>, <br><span class="hljs-selector-tag">caption</span>,<br><span class="hljs-selector-tag">cite</span>, <br><span class="hljs-selector-tag">code</span>, <br><span class="hljs-selector-tag">dfn</span>, <br><span class="hljs-selector-tag">em</span>, <br><span class="hljs-selector-tag">strong</span>,<br><span class="hljs-selector-tag">th</span>, <br><span class="hljs-selector-tag">var</span> &#123; <br>    <span class="hljs-attribute">font-style</span>:normal; <br>    <span class="hljs-attribute">font-weight</span>:normal;<br>&#125;<br><span class="hljs-selector-tag">a</span> &#123; <br>    <span class="hljs-attribute">color</span>:<span class="hljs-number">#555</span>; <br>    <span class="hljs-attribute">text-decoration</span>:none; <br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; <br>    <span class="hljs-attribute">text-decoration</span>:underline; <br>&#125;<br><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">border</span>:none;<br>&#125;<br><span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">li</span> &#123; <br>    <span class="hljs-attribute">list-style</span>:none; <br>&#125;<br><span class="hljs-selector-tag">input</span>, <br><span class="hljs-selector-tag">textarea</span>, <br><span class="hljs-selector-tag">select</span>, <br><span class="hljs-selector-tag">button</span> &#123; <br>    <span class="hljs-attribute">font</span>:<span class="hljs-number">14px</span> Verdana,Helvetica,Arial,sans-serif; <br>&#125;<br><span class="hljs-selector-tag">table</span> &#123; <br>    <span class="hljs-attribute">border-collapse</span>:collapse; <br>&#125;<br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">overflow-y</span>: scroll;<br>&#125; <br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;.&quot;</span>; <br>    <span class="hljs-attribute">display</span>: block; <br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>; <br>    <span class="hljs-attribute">clear</span>:both; <br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span> &#123; <br>    *zoom:1; <br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><code>mobile meta </code>标签</li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”width</span>=<span class="hljs-string">320,target-densitydpi</span>=<span class="hljs-string">dpi_value,initial-scale</span>=<span class="hljs-string">1,</span> <span class="hljs-attr">user-scalable</span>=<span class="hljs-string">no”/</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>表格不被撑开</li></ul><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table-layout</span>: <span class="hljs-selector-tag">fixed</span>;<br><span class="hljs-selector-tag">word-break</span>: <span class="hljs-selector-tag">break-all</span>;<br><span class="hljs-selector-tag">border-collapse</span>: <span class="hljs-selector-tag">collapse</span>;<br></code></pre></div></td></tr></table></figure><ul><li>不设宽高居中</li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”abc”</span> <span class="hljs-attr">style</span>=<span class="hljs-string">”display:table;text-align:center;width:100%;height:100%;”</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">”background:#f00;</span> <span class="hljs-attr">display:table-cell</span>; <span class="hljs-attr">vertical-align:middle</span>;”&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”button”</span> <span class="hljs-attr">value</span>=<span class="hljs-string">”item1″</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>透明度的兼容代码</li></ul><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">filter:alpha(opacity=50); /*1-100*/<br><span class="hljs-selector-tag">-moz-opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/*0-1.0*/</span><br><span class="hljs-selector-tag">-khtml-opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/*0-1.0*/</span><br><span class="hljs-selector-tag">opacity</span><span class="hljs-selector-pseudo">:0.5</span>; <span class="hljs-comment">/*0-1.0*/</span><br></code></pre></div></td></tr></table></figure><ul><li>文字溢出点点省略</li></ul><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">white-space</span><span class="hljs-selector-pseudo">:nowrap</span>;<br><span class="hljs-selector-tag">text-overflow</span><span class="hljs-selector-pseudo">:ellipsis</span>;<br><span class="hljs-selector-tag">overflow</span><span class="hljs-selector-pseudo">:hidden</span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>清除浮动的几种方法</p><ul><li><p>方法一：<code>投机取巧法</code> – 不推荐</p><ul><li>直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强</li></ul></li><li><p>方法二：<code>overflow + zoom</code>方法  –不推荐<br> <code>.fix&#123;overflow:hidden; zoom:1;&#125;</code></p><ul><li>此方法优点在于代码简洁，涵盖所有浏览器</li></ul></li><li><p>方法三：<code>after + zoom</code>方法 -推荐–此方法可以说是综合起来最好的方法了</p><ul><li><code>clearfix</code>只应用在包含浮动子元素的父级元素上</li></ul></li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.fix</span>&#123;<span class="hljs-attribute">zoom</span>:<span class="hljs-number">1</span>;&#125;<br><span class="hljs-selector-class">.fix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>     <span class="hljs-attribute">display</span>:block; <br>     <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;clear&#x27;</span>; <br>     <span class="hljs-attribute">clear</span>:both;<br>     <span class="hljs-attribute">line-height</span>:<span class="hljs-number">0</span>; <br>     <span class="hljs-attribute">visibility</span>:hidden;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>更多代码片段详情<ul><li><a href="http://www.jianshu.com/p/e878122a92a3">实用的60个CSS代码片段</a></li></ul></li></ul><h5 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h5><hr><ul><li><p>自动继承属性：</p><ul><li><code>color</code></li><li><code>font</code></li><li><code>text-align</code></li><li><code>list-style</code><br>…</li></ul></li><li><p>非继承属性：</p><ul><li><code>background</code></li><li><code>border</code></li><li><code>position</code><br>…</li></ul></li><li><p>具有破坏性的元素：</p><ul><li><code>float</code></li><li><code>display:none;</code></li><li><code>position:absoblute/fixed/sticky;</code></li></ul></li><li><p>具有包裹性的元素：</p><ul><li><p><code>display:inline-block/table-cell</code></p></li><li><p><code>position:absolute/fixed/sticky</code></p></li><li><p><code>overflow:hidden/scroll</code></p></li></ul></li><li><p>消除图片底部间隙的方法</p><ul><li><p>图片块状化-无基线对齐<br><code>img&#123;display:block;&#125;</code></p></li><li><p>图片底线对齐<br><code>img&#123;vertical-align:bottom;&#125;</code></p></li><li><p>行高足够小 - 基线位置上移<br><code>.box&#123;line-height:0;&#125;</code></p></li></ul></li></ul><h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><hr><ul><li><p>BFC</p><ul><li>BFC全称<code>”Block Formatting Context”</code> 中文为“块级格式化上下文”</li></ul><ul><li><p>记住这么一句话：<code>BFC</code>元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素</p></li><li><p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></li><li><p>扩展阅读</p><ul><li><a href="https://github.com/dwqs/blog/issues/22">CSS中的BFC</a></li></ul></li></ul></li><li><p>优雅降级(<code>graceful degradation</code>)</p><ul><li>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li></ul></li><li><p>渐进增强 <code>progressive enhancement</code>：</p><ul><li>是在浏览器开启<code>JavaScript</code>功能后，如果浏览器版本不支持某些  <code>JavaScript</code>  能力，我们解决这种问题的方式</li></ul></li><li><p>平稳退化</p><ul><li>是在浏览器没有<code>JavaScript</code>功能，或没有开启<code>JavaScript</code>功能情况下，我们解决这种问题的方式；</li></ul></li></ul><h5 id="方案荟萃扩展阅读"><a href="#方案荟萃扩展阅读" class="headerlink" title="方案荟萃扩展阅读"></a>方案荟萃扩展阅读</h5><hr><ul><li><p><strong>关于布局</strong></p><ul><li><a href="http://www.qianduan.net/css-to-achieve-the-vertical-center-of-the-five-kinds-of-methods/">垂直居中</a></li><li><a href="http://codepen.io/shshaw/full/gEiDt">css完全居中</a></li><li><a href="http://www.w3cplus.com/collective-5.html">居中之美</a></li><li><a href="http://www.zhihu.com/question/35290742#answer-20340542">网页中的底部foot定位</a></li><li><a href="http://www.webhek.com/css-100-percent-height">页面高度100%</a></li><li><a href="https://github.com/phoetry/textareaAutoHeight">textarea高度自适应</a></li><li><a href="http://dotdotdot.frebsite.nl/">多行溢出省略</a></li><li><a href="http://jinlong.github.io/2015/05/24/css-retina-hairlines/">Retina屏1px线</a></li><li><a href="https://github.com/philipwalton/flexbugs">Flexbugs</a></li></ul></li><li><p><strong>其他</strong></p><ul><li><a href="http://www.stepday.com/topic/?690">IF IE ENDIF条件判断之IE10</a></li><li><a href="http://www.zhihu.com/question/20158063">Chrome 翻译插件</a></li><li><a href="http://blog.netsh.org/posts/website-retina_1779.netsh.html">网页retina优化</a></li><li><a href="http://segmentfault.com/a/1190000002407912">常用meta</a></li><li><a href="http://www.cnblogs.com/mq0036/p/3531848.html">树状菜单</a></li><li><a href="http://www.w3ctrain.com/2015/07/24/comprehensive-guide-when-to-use-em-vs-rem/">em vs rem</a></li><li><a href="https://github.com/classicemi/blog/issues/3#issuecomment-113861251">css vs js</a></li><li><a href="http://www.w3cplus.com/solution/index/index.html">css解决方案（w3cplus）</a></li><li><a href="http://riccardoscalco.github.io/textures/">Textures生成纹理</a></li><li><a href="http://una.im/CSSgram/">CSSgram</a></li><li><a href="http://zmoazeni.github.io/csscss/">Csscss（检查重复声明等）</a></li></ul></li></ul><h4 id="附录五-部分工具资源"><a href="#附录五-部分工具资源" class="headerlink" title="附录五 部分工具资源"></a>附录五 部分工具资源</h4><hr><ul><li><a href="http://blog.poetries.top/2016/03/14/Emmet%EF%BC%9AHTML-CSS%E4%BB%A3%E7%A0%81%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99%E7%A5%9E%E5%99%A8/">学会使用Emmet插件快速编码</a></li><li><a href="http://blog.poetries.top/2016/09/09/Emmet%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/#more">Emmet常用快捷键</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/sublime-text.md">Sublime专题</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Sublime%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93.md">Sublime常用插件总结</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Front-End%20-Develop%20-Tools.md">Front-End -Develop -Tools</a></li><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/Tools.md">ToolsBox-自己整理的一份工具列表</a></li></ul><h4 id="附录六-编码规范"><a href="#附录六-编码规范" class="headerlink" title="附录六 编码规范"></a>附录六 编码规范</h4><hr><ul><li><a href="https://github.com/poetries/mywiki/blob/master/bookmark/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md">编码规范</a></li><li><a href="http://front-end-standards.com/">前端规范</a></li><li><a href="https://github.com/poetries/mywiki/wiki/web-develop-standard">web develop standard</a></li><li><a href="http://codecloud.net/5622.html">Web 前端开发规范文档</a></li><li><a href="http://zhibimo.com/read/Ashu/front-end-style-guide/index.html">前端开发规范手册</a></li></ul><h4 id="附录七-进阶学习"><a href="#附录七-进阶学习" class="headerlink" title="附录七 进阶学习"></a>附录七 进阶学习</h4><hr><ul><li><a href="http://www.jianshu.com/p/1e638b7da640">DOM编程之API学习</a></li><li><a href="http://www.jianshu.com/p/1f2314552e23">JavaScript基础学习</a></li></ul><h4 id="附录八-其他资源"><a href="#附录八-其他资源" class="headerlink" title="附录八 其他资源"></a>附录八 其他资源</h4><hr><ul><li><a href="https://github.com/poetries/mywiki">Github上前端学习资源汇总</a></li><li><a href="https://github.com/poetries/mywiki/tree/master/front-end">WEB 前端开发学习笔记</a></li><li><a href="https://github.com/poetries/mywiki/wiki/%E6%94%B6%E9%9B%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7">前端开发工具箱</a></li><li><a href="https://segmentfault.com/a/1190000006689923">148个资源让你成为CSS专家</a></li><li><a href="http://zh.learnlayout.com/">学习CSS布局-经典必看</a></li></ul><h4 id="附录九-常见问题"><a href="#附录九-常见问题" class="headerlink" title="附录九 常见问题"></a>附录九 常见问题</h4><hr><ul><li><p>前端指路</p><ul><li><a href="http://www.w3cplus.com/css/write-to-front-end-developer-interview.html">写给前端面试者（w3cplus）</a></li><li><a href="http://jiongks.name/blog/how-to-become-a-great-front-end-engineer/">如何成为一名卓越的前端工程师（勾三股四博客）</a></li><li><a href="http://www.epubit.com.cn/article/144">什么是全栈工程师</a></li><li><a href="https://uptodate.frontendrescue.org/zh/">如何跟上前端开发的最新前沿</a></li><li><a href="http://blog.jobbole.com/12749/">浏览器的工作原理</a></li><li><a href="http://www.zhihu.com/question/20269059#answer-19718763">移动前端开发和 Web 前端开发的区别</a></li><li><a href="http://segmentfault.com/q/1010000003723038?utm_source=weekly&utm_medium=email&utm_campaign=email_weekly">大型网站CSS编写与维护</a></li><li><a href="http://segmentfault.com/q/1010000003059724">CSS核心技术关键字</a></li></ul></li><li><p>性能/规范/实践</p><ul><li><a href="http://www.chinaw3c.org/how-to-read-spec-wxx.html">如何阅读W3c规范(王晓轩)</a></li><li><a href="http://www.chinaw3c.org/how-to-read-spec-gb.html">如何阅读W3c规范(高博)</a></li><li><a href="https://developer.yahoo.com/performance/rules.html">雅虎web性能优化军规</a></li><li><a href="http://browserdiet.com/zh/">权威前端性能指南</a></li><li><a href="http://www.html-js.com/article/Front-end-home-best-practice-in-front-of-the-web-high-performance-CSS">高性能css</a></li></ul></li><li><p>一些问答社区</p><ul><li><a href="https://www.quora.com/">quora</a></li><li><a href="http://stackoverflow.com/">stackoverflow</a></li><li><a href="http://www.zhihu.com/">知乎</a></li><li><a href="http://www.html-js.com/qa">前端乱炖问答区</a></li><li><a href="http://segmentfault.com/questions/newest">segmentfault问答区</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html知识点总结👮‍♀️</title>
    <link href="/hexo_blog/2019/10/11/HTML/"/>
    <url>/hexo_blog/2019/10/11/HTML/</url>
    
    <content type="html"><![CDATA[<h3 id="html知识点总结✌️✌️"><a href="#html知识点总结✌️✌️" class="headerlink" title="html知识点总结✌️✌️"></a>html知识点总结✌️✌️</h3><h3 id="1-前端需要注意哪些SEO"><a href="#1-前端需要注意哪些SEO" class="headerlink" title="#1 前端需要注意哪些SEO"></a><a href="http://interview.poetries.top/docs/base.html#_1-%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9Bseo">#</a>1 前端需要注意哪些SEO</h3><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="2-lt-img-gt-的title和alt有什么区别"><a href="#2-lt-img-gt-的title和alt有什么区别" class="headerlink" title="#2 &lt;img&gt;的title和alt有什么区别"></a><a href="http://interview.poetries.top/docs/base.html#_2-img-%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>2 <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3><ul><li>通常当鼠标滑动到元素上的时候显示</li><li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ul><h3 id="3-HTTP的几种请求方法用途"><a href="#3-HTTP的几种请求方法用途" class="headerlink" title="#3 HTTP的几种请求方法用途"></a><a href="http://interview.poetries.top/docs/base.html#_3-http%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%94%A8%E9%80%94">#</a>3 HTTP的几种请求方法用途</h3><ul><li><code>GET</code>方法<ul><li>发送一个请求来取得服务器上的某一资源</li></ul></li><li><code>POST</code>方法<ul><li>向<code>URL</code>指定的资源提交数据或附加新的数据</li></ul></li><li><code>PUT</code>方法<ul><li>跟<code>POST</code>方法很像，也是想服务器提交数据。但是，它们之间有不同。<code>PUT</code>指定了资源在服务器上的位置，而<code>POST</code>没有</li></ul></li><li><code>HEAD</code>方法<ul><li>只请求页面的首部</li></ul></li><li><code>DELETE</code>方法<ul><li>删除服务器上的某资源</li></ul></li><li><code>OPTIONS</code>方法<ul><li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li></ul></li><li><code>TRACE</code>方法<ul><li><code>TRACE</code>方法被用于激发一个远程的，应用层的请求消息回路</li></ul></li><li><code>CONNECT</code>方法<ul><li>把请求连接转换到透明的<code>TCP/IP</code>通道</li></ul></li></ul><h3 id="4-从浏览器地址栏输入url到显示页面的步骤"><a href="#4-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="#4 从浏览器地址栏输入url到显示页面的步骤"></a><a href="http://interview.poetries.top/docs/base.html#_4-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4">#</a>4 从浏览器地址栏输入url到显示页面的步骤</h3><p><strong>基础版本</strong></p><ul><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li><li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li><li>载入解析到的资源文件，渲染页面，完成。</li></ul><p><strong>详细版</strong></p><ol><li><p>在浏览器地址栏输入URL</p></li><li><p>浏览器查看</p><p>缓存</p><p>，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p><ol><li><p>如果资源未缓存，发起新请求</p></li><li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p></li><li><p>检验新鲜通常有两个HTTP头进行控制</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Expires</span><br></code></pre></div></td></tr></table></figure><p>和</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Cache-Control</span><br></code></pre></div></td></tr></table></figure><p>：</p><ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p></li><li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p></li><li><p>浏览器</p><p>获取主机ip地址</p><p>，过程如下：</p><ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><p>打开一个socket与目标IP地址，端口建立TCP链接</p><p>，三次握手如下：</p><ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li><p>TCP链接建立后<strong>发送HTTP请求</strong></p></li><li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p></li><li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p></li><li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p></li><li><p>浏览器接收HTTP响应，然后根据情况选择</p><p>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</p><p>：</p><ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li><p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p></li><li><p>如果资源可缓存，<strong>进行缓存</strong></p></li><li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p></li><li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p></li><li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p></li><li><p>构建DOM树</p><p>：</p><ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p></li><li><p>构建</p><p>CSSOM树</p><p>：</p><ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树 (opens new window)</a></p><p>:</p><ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><p>js解析如下</p><p>：</p><ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete，window触发load事件</li></ol></li><li><p><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</p></li></ol><p><strong>详细简版</strong></p><ol><li>从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到dns查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li><li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li><li>单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括http缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li><li>浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li><li><code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li><li><code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li><li>其它（可以拓展不同的知识模块，如跨域，web安全，<code>hybrid</code>模式等等内容）</li></ol><h3 id="5-如何进行网站性能优化"><a href="#5-如何进行网站性能优化" class="headerlink" title="#5 如何进行网站性能优化"></a><a href="http://interview.poetries.top/docs/base.html#_5-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">#</a>5 如何进行网站性能优化</h3><ul><li><code>content</code>方面<ul><li>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li><li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li><li>减少<code>DOM</code>元素数量</li></ul></li><li><code>Server</code>方面<ul><li>使用<code>CDN</code></li><li>配置<code>ETag</code></li><li>对组件使用<code>Gzip</code>压缩</li></ul></li><li><code>Cookie</code>方面<ul><li>减小<code>cookie</code>大小</li></ul></li><li><code>css</code>方面<ul><li>将样式表放到页面顶部</li><li>不使用<code>CSS</code>表达式</li><li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li></ul></li><li><code>Javascript</code>方面<ul><li>将脚本放到页面底部</li><li>将<code>javascript</code>和<code>css</code>从外部引入</li><li>压缩<code>javascript</code>和<code>css</code></li><li>删除不需要的脚本</li><li>减少<code>DOM</code>访问</li></ul></li><li>图片方面<ul><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化<code>css</code>精灵</li><li>不要在<code>HTML</code>中拉伸图片</li></ul></li></ul><p><strong>你有用过哪些前端性能优化的方法？</strong></p><ul><li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li><li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li><li>当需要设置的样式很多时设置className而不是直接操作style</li><li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li><li>避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)</li><li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li><li>避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</li></ul><p><strong>谈谈性能优化问题</strong></p><ul><li>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器</li><li>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</li><li>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载</li><li>请求带宽：压缩文件，开启GZIP</li></ul><p><strong>前端性能优化最佳实践？</strong></p><ul><li>性能评级工具（PageSpeed 或 YSlow）</li><li>合理设置 HTTP 缓存：Expires 与 Cache-control</li><li>静态资源打包，开启 Gzip 压缩（节省响应流量）</li><li>CSS3 模拟图像，图标base64（降低请求数）</li><li>模块延迟(defer)加载/异步(async)加载</li><li>Cookie 隔离（节省请求流量）</li><li>localStorage（本地存储）</li><li>使用 CDN 加速（访问最近服务器）</li><li>启用 HTTP/2（多路复用，并行加载）</li><li>前端自动化（gulp/webpack）</li></ul><h3 id="6-HTTP状态码及其含义"><a href="#6-HTTP状态码及其含义" class="headerlink" title="#6 HTTP状态码及其含义"></a><a href="http://interview.poetries.top/docs/base.html#_6-http%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89">#</a>6 HTTP状态码及其含义</h3><ul><li><div class="hljs code-wrapper"><pre><code>1XX<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><br>  ：信息状态码<br><br>  - `100 <span class="hljs-keyword">Continue</span>` 继续，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息<br><br>- ```<br>  <span class="hljs-number">2</span>XX<br></code></pre></div></td></tr></table></figure>：成功状态码- `200 OK` 正常返回信息- `201 Created` 请求成功并且服务器创建了新的资源- `202 Accepted` 服务器已接受请求，但尚未处理</code></pre></li><li><div class="hljs code-wrapper"><pre><code>3XX<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><br>  ：重定向<br><br>  - `301 Moved Permanently` 请求的网页已永久移动到新位置。<br>  - `302 Found` 临时性重定向。<br>  - `303 See Other` 临时性重定向，且总是使用 `GET` 请求新的 `URI`。<br>  - `304 <span class="hljs-literal">Not</span> Modified` 自从上次请求后，请求的网页未修改过。<br><br>- ```<br>  <span class="hljs-number">4</span>XX<br></code></pre></div></td></tr></table></figure>：客户端错误- `400 Bad Request` 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。- `401 Unauthorized` 请求未授权。- `403 Forbidden` 禁止访问。- `404 Not Found` 找不到如何与 `URI` 相匹配的资源。</code></pre></li><li><div class="hljs code-wrapper"><pre><code>5XX:<figure class="highlight http"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><br>   <br><br>  服务器错误<br><br>  - `500 Internal Server Error` 最常见的服务器端错误。<br>  - `503 Service Unavailable` 服务器端暂时无法处理请求（可能是过载或维护）。<br><br>### [#](http://interview.poetries.top/docs/base.html#_7-语义化的理解)7 语义化的理解<br><br>- 用正确的标签做正确的事情！<br>- `HTML`语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>- 在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的。<br>- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 `SEO`。<br>- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解<br><br>### [#](http://interview.poetries.top/docs/base.html#_8-介绍一下你对浏览器内核的理解)8 介绍一下你对浏览器内核的理解？<br><br>- 主要分成两部分：渲染引擎(`layout engineer`或`Rendering Engine`)和`JS`引擎<br>- 渲染引擎：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核<br>- `JS`引擎则：解析和执行`javascript`来实现网页的动态效果<br>- 最开始渲染引擎和`JS`引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎<br><br>**常见的浏览器内核有哪些**<br><br>- `Trident`内核：`IE,MaxThon,TT,The World,360`,搜狗浏览器等。[又称MSHTML]<br>- `Gecko`内核：`Netscape6`及以上版本，`FF,MozillaSuite/SeaMonkey`等<br>- `Presto`内核：`Opera7`及以上。 [`Opera`内核原为：Presto，现为：`Blink`;]<br>- `Webkit`内核：`Safari,Chrome`等。 [ `Chrome`的`Blink`（`WebKit`的分支）]<br><br>### [#](http://interview.poetries.top/docs/base.html#_9-html5有哪些新特性、移除了那些元素)9 html5有哪些新特性、移除了那些元素？<br><br>- `HTML5` 现在已经不是 `SGML` 的子集，主要是关于图像，位置，存储，多任务等功能的增加<br>  - 新增选择器 `document.querySelector`、`document.querySelectorAll`<br>  - 拖拽释放(`Drag and drop`) API<br>  - 媒体播放的 `video` 和 `audio`<br>  - 本地存储 `localStorage` 和 `sessionStorage`<br>  - 离线应用 `manifest`<br>  - 桌面通知 `Notifications`<br>  - 语意化标签 `article`、`footer`、`header`、`nav`、`section`<br>  - 增强表单控件 `calendar`、`date`、`time`、`email`、`url`、`search`<br>  - 地理位置 `Geolocation`<br>  - 多任务 `webworker`<br>  - 全双工通信协议 `websocket`<br>  - 历史管理 `history`<br>  - 跨域资源共享(CORS) `Access-Control-Allow-Origin`<br>  - 页面可见性改变事件 `visibilitychange`<br>  - 跨窗口通信 `PostMessage`<br>  - `Form Data` 对象<br>  - 绘画 `canvas`<br>- 移除的元素：<br>  - 纯表现的元素：`basefont`、`big`、`center`、`font`、 `s`、`strike`、`tt`、`u`<br>  - 对可用性产生负面影响的元素：`frame`、`frameset`、`noframes`<br>- 支持`HTML5`新标签：<br>  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签<br>  - 可以利用这一特性让这些浏览器支持`HTML5`新标签<br>  - 浏览器支持新标签后，还需要添加标签默认的样式<br>- 当然也可以直接使用成熟的框架、比如`html5shim`<br><br>**如何区分 HTML 和 HTML5**<br><br>- `DOCTYPE`声明、新增的结构元素、功能元素<br><br>### [#](http://interview.poetries.top/docs/base.html#_10-html5的离线储存怎么使用-工作原理能不能解释一下)10 `HTML5`的离线储存怎么使用，工作原理能不能解释一下？<br><br>- 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件<br>- 原理：`HTML5`的离线存储是基于一个新建的`.appcache`文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像`cookie`一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示<br>- 如何使用：<br>  - 页面头部像下面一样加入一个`manifest`的属性；<br>  - 在`cache.manifest`文件的编写离线存储的资源<br>  - 在离线状态时，操作`window.applicationCache`进行需求实现<br><br>```json<br>CACHE MANIFEST<br>#v0.11<br><span class="hljs-attribute">CACHE:</span><br><span class="hljs-attribute">js/app.js</span><br><span class="hljs-attribute">css/style.css</span><br><span class="hljs-attribute">NETWORK:</span><br><span class="hljs-attribute">resourse/logo.png</span><br><span class="hljs-attribute">FALLBACK:</span><br><span class="hljs-attribute">/offline.html</span><br></code></pre></div></td></tr></table></figure></code></pre></li></ul><h3 id="11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢"><a href="#11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢" class="headerlink" title="#11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢"></a><a href="http://interview.poetries.top/docs/base.html#_11-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9html5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%91%A2">#</a>11 浏览器是怎么对<code>HTML5</code>的离线储存资源进行管理和加载的呢</h3><ul><li>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问<code>app</code>，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过<code>app</code>并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的<code>manifest</code>文件与旧的<code>manifest</code>文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><h3 id="12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="#12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a><a href="http://interview.poetries.top/docs/base.html#_12-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-cookies-sessionstorage-%E5%92%8C-localstorage-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>12 请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h3><ul><li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h3 id="13-iframe有那些缺点？"><a href="#13-iframe有那些缺点？" class="headerlink" title="#13 iframe有那些缺点？"></a><a href="http://interview.poetries.top/docs/base.html#_13-iframe%E6%9C%89%E9%82%A3%E4%BA%9B%E7%BC%BA%E7%82%B9">#</a>13 iframe有那些缺点？</h3><ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><h3 id="14-WEB标准以及W3C标准是什么"><a href="#14-WEB标准以及W3C标准是什么" class="headerlink" title="#14 WEB标准以及W3C标准是什么?"></a><a href="http://interview.poetries.top/docs/base.html#_14-web%E6%A0%87%E5%87%86%E4%BB%A5%E5%8F%8Aw3c%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a>14 WEB标准以及W3C标准是什么?</h3><ul><li>标签闭合、标签小写、不乱嵌套、使用外链<code>css</code>和<code>js</code>、结构行为表现的分离</li></ul><h3 id="15-xhtml和html有什么区别"><a href="#15-xhtml和html有什么区别" class="headerlink" title="#15 xhtml和html有什么区别?"></a><a href="http://interview.poetries.top/docs/base.html#_15-xhtml%E5%92%8Chtml%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>15 xhtml和html有什么区别?</h3><ul><li>一个是功能上的差别<ul><li>主要是<code>XHTML</code>可兼容各大浏览器、手机以及<code>PDA</code>，并且浏览器也能快速正确地编译网页</li></ul></li><li>另外是书写习惯的差别<ul><li><code>XHTML</code> 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</li></ul></li></ul><h3 id="16-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#16-Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="#16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a><a href="http://interview.poetries.top/docs/base.html#_16-doctype%E4%BD%9C%E7%94%A8-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89">#</a>16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><ul><li>页面被加载的时，<code>link</code>会同时被加载，而<code>@imort</code>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载 <code>import</code>只在<code>IE5</code>以上才能识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题 <code>link</code>方式的样式的权重 高于<code>@import</code>的权重</li><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li><li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 <code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h3 id="17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？"><a href="#17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？" class="headerlink" title="#17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？"></a><a href="http://interview.poetries.top/docs/base.html#_17-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3><ul><li>行内元素有：<code>a b span img input select strong</code></li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4… p</code></li><li>空元素：<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li><li>行内元素不可以设置宽高，不独占一行</li><li>块级元素可以设置宽高，独占一行</li></ul><h3 id="18-HTML全局属性-global-attribute-有哪些"><a href="#18-HTML全局属性-global-attribute-有哪些" class="headerlink" title="#18 HTML全局属性(global attribute)有哪些"></a><a href="http://interview.poetries.top/docs/base.html#_18-html%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7-global-attribute-%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>18 HTML全局属性(global attribute)有哪些</h3><ul><li><code>class</code>:为元素设置类标识</li><li><code>data-*</code>: 为元素增加自定义属性</li><li><code>draggable</code>: 设置元素是否可拖拽</li><li><code>id</code>: 元素<code>id</code>，文档内唯一</li><li><code>lang</code>: 元素内容的的语言</li><li><code>style</code>: 行内<code>css</code>样式</li><li><code>title</code>: 元素相关的建议信息</li></ul><h3 id="19-Canvas和SVG有什么区别？"><a href="#19-Canvas和SVG有什么区别？" class="headerlink" title="#19 Canvas和SVG有什么区别？"></a><a href="http://interview.poetries.top/docs/base.html#_19-canvas%E5%92%8Csvg%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>19 Canvas和SVG有什么区别？</h3><ul><li><code>svg</code>绘制出来的每一个图形的元素都是独立的<code>DOM</code>节点，能够方便的绑定事件或用来修改。<code>canvas</code>输出的是一整幅画布</li><li><code>svg</code>输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而<code>canvas</code>输出标量画布，就像一张图片一样，放大会失真或者锯齿</li></ul><h3 id="20-HTML5-为什么只需要写"><a href="#20-HTML5-为什么只需要写" class="headerlink" title="#20 HTML5 为什么只需要写 "></a><a href="http://interview.poetries.top/docs/base.html#_20-html5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99">#</a>20 HTML5 为什么只需要写 <!DOCTYPE HTML></h3><ul><li><code>HTML5</code> 不基于 <code>SGML</code>，因此不需要对<code>DTD</code>进行引用，但是需要<code>doctype</code>来规范浏览器的行为</li><li>而<code>HTML4.01</code>基于<code>SGML</code>,所以需要对<code>DTD</code>进行引用，才能告知浏览器文档所使用的文档类型</li></ul><h3 id="21-如何在页面上实现一个圆形的可点击区域？"><a href="#21-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="#21 如何在页面上实现一个圆形的可点击区域？"></a><a href="http://interview.poetries.top/docs/base.html#_21-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F">#</a>21 如何在页面上实现一个圆形的可点击区域？</h3><ul><li><code>svg</code></li><li><code>border-radius</code></li><li>纯<code>js</code>实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li></ul><h3 id="22-网页验证码是干嘛的，是为了解决什么安全问题"><a href="#22-网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="#22 网页验证码是干嘛的，是为了解决什么安全问题"></a><a href="http://interview.poetries.top/docs/base.html#_22-%E7%BD%91%E9%A1%B5%E9%AA%8C%E8%AF%81%E7%A0%81%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">#</a>22 网页验证码是干嘛的，是为了解决什么安全问题</h3><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h3 id="23-viewport"><a href="#23-viewport" class="headerlink" title="#23 viewport"></a><a href="http://interview.poetries.top/docs/base.html#_23-viewport">#</a>23 viewport</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span> /&gt;    <span class="hljs-comment">// width    设置viewport宽度，为一个正整数，或字符串‘device-width’    // device-width  设备宽度    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数    // user-scalable    是否允许手动缩放</span><br></code></pre></div></td></tr></table></figure><ul><li>延伸提问<ul><li>怎样处理 移动端 <code>1px</code> 被 渲染成 <code>2px</code>问题</li></ul></li></ul><p><strong>局部处理</strong></p><ul><li><code>meta</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>1</code></li><li><code>rem</code>按照设计稿标准走，外加利用<code>transfrome</code> 的<code>scale(0.5)</code> 缩小一倍即可；</li></ul><p><strong>全局处理</strong></p><ul><li><code>mate</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>0.5</code></li><li><code>rem</code> 按照设计稿标准走即可</li></ul><h3 id="24-渲染优化"><a href="#24-渲染优化" class="headerlink" title="#24 渲染优化"></a><a href="http://interview.poetries.top/docs/base.html#_24-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96">#</a>24 渲染优化</h3><ul><li>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）<ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li><li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul></li><li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低<code>CPU</code>消耗，提升渲染性能）</li><li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li><li>对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code><ul><li>小图标优势在于<ul><li>减少<code>HTTP</code>请求</li><li>避免文件跨域</li><li>修改及时生效</li></ul></li></ul></li><li>页面头部的<code>&lt;style&gt;&lt;/style&gt;</code> <code>&lt;script&gt;&lt;/script&gt;</code> 会阻塞页面；（因为 <code>Renderer</code>进程中 <code>JS</code>线程和渲染线程是互斥的）</li><li>页面中空的 <code>href</code> 和 <code>src</code> 会阻塞页面其他资源的加载 (阻塞下载进程)</li><li>网页<code>gzip</code>，<code>CDN</code>托管，<code>data</code>缓存 ，图片服务器</li><li>前端模板 JS+数据，减少由于<code>HTML</code>标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li><li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li><li>少用全局变量、缓存<code>DOM</code>节点查找的结果。减少<code>IO</code>读取操作</li><li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li><li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘<code>IO</code></li></ul><h3 id="25-meta-viewport相关"><a href="#25-meta-viewport相关" class="headerlink" title="#25 meta viewport相关"></a><a href="http://interview.poetries.top/docs/base.html#_25-meta-viewport%E7%9B%B8%E5%85%B3">#</a>25 meta viewport相关</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>  <span class="hljs-comment">&lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">”en”</span>&gt;</span> <span class="hljs-comment">&lt;!--标准的 lang 属性写法--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">’utf-8′</span>&gt;</span>    <span class="hljs-comment">&lt;!--声明文档使用的字符编码--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”X-UA-Compatible”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”IE</span>=<span class="hljs-string">edge,chrome</span>=<span class="hljs-string">1″/</span>&gt;</span>   <span class="hljs-comment">&lt;!--优先使用 IE 最新版本和 Chrome--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”description”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”不超过150个字符”/</span>&gt;</span>       <span class="hljs-comment">&lt;!--页面描述--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”keywords”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">””/</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 页面关键词--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”author”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”name,</span> <span class="hljs-attr">email</span>@<span class="hljs-attr">gmail.com</span>”/&gt;</span>    <span class="hljs-comment">&lt;!--网页作者--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”robots”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”index,follow”/</span>&gt;</span>      <span class="hljs-comment">&lt;!--搜索引擎抓取--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”initial-scale</span>=<span class="hljs-string">1,</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">3,</span> <span class="hljs-attr">minimum-scale</span>=<span class="hljs-string">1,</span> <span class="hljs-attr">user-scalable</span>=<span class="hljs-string">no”</span>&gt;</span> <span class="hljs-comment">&lt;!--为移动设备添加 viewport--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-mobile-web-app-title”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”标题”</span>&gt;</span> <span class="hljs-comment">&lt;!--iOS 设备 begin--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-mobile-web-app-capable”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”yes”/</span>&gt;</span>  <span class="hljs-comment">&lt;!--添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-itunes-app”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”app-id</span>=<span class="hljs-string">myAppStoreID,</span> <span class="hljs-attr">affiliate-data</span>=<span class="hljs-string">myAffiliateData,</span> <span class="hljs-attr">app-argument</span>=<span class="hljs-string">myURL”</span>&gt;</span><span class="hljs-comment">&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”apple-mobile-web-app-status-bar-style”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”black”/</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”format-detection”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”telphone</span>=<span class="hljs-string">no,</span> <span class="hljs-attr">email</span>=<span class="hljs-string">no”/</span>&gt;</span>  <span class="hljs-comment">&lt;!--设置苹果工具栏颜色--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”renderer”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”webkit”</span>&gt;</span> <span class="hljs-comment">&lt;!-- 启用360浏览器的极速模式(webkit)--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”X-UA-Compatible”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”IE</span>=<span class="hljs-string">edge”</span>&gt;</span>     <span class="hljs-comment">&lt;!--避免IE使用兼容模式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”Cache-Control”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no-siteapp”</span> /&gt;</span>    <span class="hljs-comment">&lt;!--不让百度转码--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”HandheldFriendly”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”true”</span>&gt;</span>     <span class="hljs-comment">&lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”MobileOptimized”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”320″</span>&gt;</span>   <span class="hljs-comment">&lt;!--微软的老式浏览器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”screen-orientation”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”portrait”</span>&gt;</span>   <span class="hljs-comment">&lt;!--uc强制竖屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”x5-orientation”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”portrait”</span>&gt;</span>    <span class="hljs-comment">&lt;!--QQ强制竖屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”full-screen”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”yes”</span>&gt;</span>              <span class="hljs-comment">&lt;!--UC强制全屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”x5-fullscreen”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”true”</span>&gt;</span>       <span class="hljs-comment">&lt;!--QQ强制全屏--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”browsermode”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”application”</span>&gt;</span>   <span class="hljs-comment">&lt;!--UC应用模式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”x5-page-mode”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”app”</span>&gt;</span>   <span class="hljs-comment">&lt;!-- QQ应用模式--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”msapplication-tap-highlight”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no”</span>&gt;</span>    <span class="hljs-comment">&lt;!--windows phone 点击无高亮设置页面不缓存--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”pragma”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no-cache”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”cache-control”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”no-cache”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">”expires”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”0″</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么"><a href="#26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么" class="headerlink" title="#26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?"></a><a href="http://interview.poetries.top/docs/base.html#_26-%E4%BD%A0%E5%81%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95%E8%BF%87-%E8%BF%99%E4%BA%9B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a>26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h3><ul><li><code>IE</code>: <code>trident</code>内核</li><li><code>Firefox</code>：<code>gecko</code>内核</li><li><code>Safari</code>:<code>webkit</code>内核</li><li><code>Opera</code>:以前是<code>presto</code>内核，<code>Opera</code>现已改用Google - <code>Chrome</code>的<code>Blink</code>内核</li><li><code>Chrome:Blink</code>(基于<code>webkit</code>，Google与Opera Software共同开发)</li></ul><h3 id="27-div-css的布局较table布局有什么优点？"><a href="#27-div-css的布局较table布局有什么优点？" class="headerlink" title="#27 div+css的布局较table布局有什么优点？"></a><a href="http://interview.poetries.top/docs/base.html#_27-div-css%E7%9A%84%E5%B8%83%E5%B1%80%E8%BE%83table%E5%B8%83%E5%B1%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9">#</a>27 div+css的布局较table布局有什么优点？</h3><ul><li>改版的时候更方便 只要改<code>css</code>文件。</li><li>页面加载速度更快、结构化清晰、页面显示简洁。</li><li>表现与结构相分离。</li><li>易于优化（<code>seo</code>）搜索引擎更友好，排名更容易靠前。</li></ul><h3 id="28-a：img的alt与title有何异同？b：strong与em的异同？"><a href="#28-a：img的alt与title有何异同？b：strong与em的异同？" class="headerlink" title="#28 a：img的alt与title有何异同？b：strong与em的异同？"></a><a href="http://interview.poetries.top/docs/base.html#_28-a-img%E7%9A%84alt%E4%B8%8Etitle%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C-b-strong%E4%B8%8Eem%E7%9A%84%E5%BC%82%E5%90%8C">#</a>28 a：img的alt与title有何异同？b：strong与em的异同？</h3><ul><li><code>alt(alt text)</code>:为不能显示图像、窗体或<code>applets</code>的用户代理（<code>UA</code>），<code>alt</code>属性用来指定替换文字。替换文字的语言由<code>lang</code>属性指定。(在IE浏览器下会在没有<code>title</code>时把<code>alt</code>当成 <code>tool tip</code>显示)</li><li><code>title(tool tip)</code>:该属性为设置该属性的元素提供建议性的信息</li><li><code>strong</code>:粗体强调标签，强调，表示内容的重要性</li><li><code>em</code>:斜体强调标签，更强烈强调，表示内容的强调点</li></ul><h3 id="29-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#29-你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="#29 你能描述一下渐进增强和优雅降级之间的不同吗"></a><a href="http://interview.poetries.top/docs/base.html#_29-%E4%BD%A0%E8%83%BD%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%90%97">#</a>29 你能描述一下渐进增强和优雅降级之间的不同吗</h3><ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><blockquote><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p></blockquote><h3 id="30-为什么利用多个域名来存储网站资源会更有效？"><a href="#30-为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="#30 为什么利用多个域名来存储网站资源会更有效？"></a><a href="http://interview.poetries.top/docs/base.html#_30-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E6%9D%A5%E5%AD%98%E5%82%A8%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E4%BC%9A%E6%9B%B4%E6%9C%89%E6%95%88">#</a>30 为什么利用多个域名来存储网站资源会更有效？</h3><ul><li><code>CDN</code>缓存更方便</li><li>突破浏览器并发限制</li><li>节约<code>cookie</code>带宽</li><li>节约主域名的连接数，优化页面响应速度</li><li>防止不必要的安全问题</li></ul><h3 id="31-简述一下src与href的区别"><a href="#31-简述一下src与href的区别" class="headerlink" title="#31 简述一下src与href的区别"></a><a href="http://interview.poetries.top/docs/base.html#_31-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bsrc%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>31 简述一下src与href的区别</h3><ul><li><code>src</code>用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</li><li><code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>frame</code>等元素</li></ul><blockquote><script src ="js.js"></script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</blockquote><ul><li><code>href</code>是<code>Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li><li><code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>那么浏览器会识别该文档为<code>css</code>文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用<code>link</code>方式来加载<code>css</code>，而不是使用<code>@import</code>方式</li></ul><h3 id="32-知道的网页制作会用到的图片格式有哪些？"><a href="#32-知道的网页制作会用到的图片格式有哪些？" class="headerlink" title="#32 知道的网页制作会用到的图片格式有哪些？"></a><a href="http://interview.poetries.top/docs/base.html#_32-%E7%9F%A5%E9%81%93%E7%9A%84%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>32 知道的网页制作会用到的图片格式有哪些？</h3><ul><li><code>png-8</code>、<code>png-24</code>、<code>jpeg</code>、<code>gif</code>、<code>svg</code></li></ul><blockquote><p>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是<code>Webp</code>,<code>Apng</code>。（是否有关注新技术，新鲜事物）</p></blockquote><ul><li><strong>Webp</strong>：<code>WebP</code>格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有<code>JPEG</code>的<code>2/3</code>，并能节省大量的服务器带宽资源和数据空间。<code>Facebook Ebay</code>等知名网站已经开始测试并使用<code>WebP</code>格式。</li><li>在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小<code>40%</code>。</li><li><strong>Apng</strong>：全称是<code>“Animated Portable Network Graphics”</code>, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 <code>iOS safari 8</code>的支持，有望代替<code>GIF</code>成为下一代动态图标准</li></ul><h3 id="33-在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"><a href="#33-在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="#33 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"></a><a href="http://interview.poetries.top/docs/base.html#_33-%E5%9C%A8css-js%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%BA%BF%E4%B9%8B%E5%90%8E%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD-%E4%BB%8E%E7%94%A8%E6%88%B7%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5%E5%BC%80%E5%A7%8B-%E4%B8%80%E6%AC%A1js%E8%AF%B7%E6%B1%82%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E6%9C%89%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86">#</a>33 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</h3><blockquote><p><code>dns</code>缓存，<code>cdn</code>缓存，浏览器缓存，服务器缓存</p></blockquote><h3 id="34-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#34-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="#34 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"></a><a href="http://interview.poetries.top/docs/base.html#_33-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87-%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99-%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2-%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD-%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C%E3%80%82">#</a>34 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h3><ul><li>图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li><li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li><li>如果图片为css图片，可以使用<code>CSSsprite</code>，<code>SVGsprite</code>，<code>Iconfont</code>、<code>Base64</code>等技术。</li><li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li><li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li></ul><h3 id="35-网页验证码是干嘛的，是为了解决什么安全问题"><a href="#35-网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="#35 网页验证码是干嘛的，是为了解决什么安全问题"></a>#35 网页验证码是干嘛的，是为了解决什么安全问题</h3><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h3 id="36-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"><a href="#36-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？" class="headerlink" title="#36 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"></a>#36 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h3><p>​    </p><ul><li><p>行内元素不可以设置宽高，不独占一行</p></li><li><p>块级元素可以设置宽高，独占一行</p></li></ul><ul><li>行内：</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">JAVASCRIPT<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">abbr</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">acronym</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">bdo</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">big</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dfn</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">samp</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tt</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">var</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>块级：</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">JAVASCRIPT<br><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">noframes</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>空：</li></ul><p>常见的：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">JAVASCRIPT</span><br><span class="hljs-section">&lt;br&gt;</span> <span class="hljs-section">&lt;hr&gt;</span> <span class="hljs-section">&lt;img&gt;</span> <span class="hljs-section">&lt;input&gt;</span> <span class="hljs-section">&lt;link&gt;</span> <span class="hljs-section">&lt;meta&gt;</span><br></code></pre></div></td></tr></table></figure><p>鲜为人知的：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">JAVASCRIPT</span><br><span class="hljs-section">&lt;area&gt;</span> <span class="hljs-section">&lt;base&gt;</span> <span class="hljs-section">&lt;col&gt;</span> <span class="hljs-section">&lt;command&gt;</span> <span class="hljs-section">&lt;embed&gt;</span> <span class="hljs-section">&lt;link&gt;</span> <span class="hljs-section">&lt;meta&gt;</span><span class="hljs-section">&lt;keygen&gt;</span> <span class="hljs-section">&lt;param&gt;</span> <span class="hljs-section">&lt;source&gt;</span> <span class="hljs-section">&lt;track&gt;</span> <span class="hljs-section">&lt;wbr&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World🎁</title>
    <link href="/hexo_blog/2019/02/21/hello-world/"/>
    <url>/hexo_blog/2019/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/hexo_blog/"/>
    <url>/hexo_blog/</url>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="我的博客🎋"><a href="#我的博客🎋" class="headerlink" title="我的博客🎋"></a>我的博客🎋</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分享一些学习工作中的见解或者笔记</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="个人信息🎏"><a href="#个人信息🎏" class="headerlink" title="个人信息🎏"></a>个人信息🎏</h3><blockquote><ul><li>周航/女</li><li>本科/重庆理工大学/计算机系</li><li>工作年限/应届生/本科</li><li>技术博客：<a href="https://link.segmentfault.com/?url=https://wscats.github.io/blog">https://wscats.github.io/blog</a> </li><li>Github：<a href="https://github.com/zhouhanging">https://github.com/zhouhanging</a></li><li>邮箱：<a href="mailto:&#x33;&#x34;&#x39;&#x33;&#x33;&#x32;&#x39;&#55;&#53;&#x36;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;">&#x33;&#x34;&#x39;&#x33;&#x33;&#x32;&#x39;&#55;&#53;&#x36;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;</a></li><li>实习经历：恒生电子股份有限公司()</li><li>期望职位：Web前端程序员/工程师</li><li>期望城市：杭州</li></ul></blockquote><h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><blockquote><ol><li>对前端技术具有浓厚的兴趣，喜欢逛github，掘金等技术论坛；</li><li>具备良好的审美能力，有良好的代码编程习惯；</li><li>学习适应能力强，愿意不断学习新知识丰富自己；</li><li>抗压能力强，有信心在不同的工作强度下进行开发工作；</li><li>性格随和，具有良好的团队合作精神。</li></ol></blockquote><h3 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h3>]]></content>
    
  </entry>
  
  
  
</search>
